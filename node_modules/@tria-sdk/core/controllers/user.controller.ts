import UserService from '../services/user';
import {
  ENV,
  GetAllAddressesResponse,
  GetChainNameByTriaName,
  GetTotalBalanceResponse,
  RampnalysisSupportedResponse,
  RampnalysisUrlResponse,
} from '../types';

export class UserController {
  baseUrl: string;
  user: UserService;
  triaName: string | undefined;

  constructor(baseUrl: string, triaName?: string, environment: ENV = 'mainnet') {
    this.baseUrl = baseUrl;
    this.user = new UserService(baseUrl, environment);
    this.triaName = triaName;
  }

  async get_tID() {
    try {
      const res = await this.user.get_tID();
      return res;
    } catch (err) {
      return err;
    }
  }

  /**
   *
   * @deprecated
   */
  async getActions() {
    try {
      const res = await this.user.getActions();
      return res;
    } catch (err) {
      return err;
    }
  }

  async requestAmount({ tag, payload }: { tag: string; payload: Object }) {
    try {
      const res = await this.user.requestAmount({ tag, payload });
      return res;
    } catch (err) {
      return err;
    }
  }

  async completeAction({ actionId }: { actionId: string }) {
    try {
      const res = await this.user.completeAction({ actionId });
      return res;
    } catch (err) {
      return err;
    }
  }

  async ignoreAction({ actionId }: { actionId: string }) {
    try {
      const res = await this.user.ignoreAction({ actionId });
      return res;
    } catch (err) {
      return err;
    }
  }

  async getConversation({ participantName }: { participantName: string }) {
    try {
      const res = await this.user.getConversation({ participantName });
      return res;
    } catch (err) {
      return err;
    }
  }

  async search(term: string) {
    try {
      const res = await this.user.search({ term });
      return res;
    } catch (err) {
      return err;
    }
  }

  async searchUser(term: string) {
    try {
      const res = await this.user.searchUser({ term });
      return res;
    } catch (err) {
      return err;
    }
  }

  async getHomeScreenHistory() {
    try {
      let res = { actions: [], history: [] };
      if (res.actions.length == 0) {
        let historyRes = await this.user.getAllHistory(this.triaName as string);
        if (historyRes.success && historyRes.history.length > 0)
          res.history = historyRes.history.slice(0, 3);
      }
      return res;
    } catch (err) {
      return err;
    }
  }

  async getAllAddresses(triaName: string): Promise<GetAllAddressesResponse> {
    try {
      const res = await this.user.getAllAddresses((triaName || this.triaName) as string);
      return res as GetAllAddressesResponse;
    } catch (err) {
      throw err;
    }
  }

  async getSubnames() {
    try {
      const res = await this.user.getSubnames();
      return res;
    } catch (err) {
      return err;
    }
  }

  async getAllHistory(
    filter: 'all' | 'transactionSent' | 'transactionReceived' = 'all',
    filterChainNames?: string[],
    triaName?: string
  ) {
    try {
      const res = await this.user.getAllHistory(
        (this.triaName || triaName) as string,
        filter,
        filterChainNames
      );
      return res;
    } catch (err) {
      return err;
    }
  }

  async getOnChainConversation(withTriaName: string, triaName?: string) {
    try {
      const res = await this.user.getOnChainConversation(
        (this.triaName || triaName) as string,
        withTriaName
      );
      return res;
    } catch (err) {
      return err;
    }
  }

  async getAssets(
    filterChainNames?: string[],
    filter?: 'all' | 'favorites',
    sort?: 'amountAsc' | 'amountDesc',
    triaName?: string
  ) {
    try {
      const res = await this.user.getAssets(
        (this.triaName || triaName) as string,
        filterChainNames,
        filter,
        sort
      );
      return res;
    } catch (err) {
      return err;
    }
  }

  async getAssetsForATriaName(
    triaName: string,
    filterChainNames?: [],
    sort?: 'amountAsc' | 'amountDesc'
  ) {
    try {
      const res = await this.user.getAssetsForATriaName(triaName, filterChainNames, sort);
      return res;
    } catch (err) {
      return err;
    }
  }

  async getAsset(chainName: string, tokenAddress?: string, triaName?: string) {
    try {
      const res = await this.user.getAsset(
        (this.triaName || triaName) as string,
        chainName,
        tokenAddress
      );
      return res;
    } catch (err) {
      return err;
    }
  }

  async getAssetBalanceForATriaName(triaName: string, chainName: string, tokenAddress?: string) {
    try {
      const res = await this.user.getAssetBalanceForATriaName(triaName, chainName, tokenAddress);
      return res;
    } catch (err) {
      return err;
    }
  }

  async getAssetDetails(chainName: string, tokenAddress?: string, triaName?: string) {
    try {
      const res = await this.user.getAssetDetails(
        (this.triaName || triaName) as string,
        chainName,
        tokenAddress
      );
      return res;
    } catch (err) {
      return err;
    }
  }

  async getSubnamesForAsset(chainName: string, tokenAddress?: string) {
    try {
      const res = await this.user.getSubnamesForAsset(chainName, tokenAddress);
      return res;
    } catch (err) {
      return err;
    }
  }

  async getAllSubnamesForAsset(chainName: string, tokenAddress?: string) {
    try {
      const res = await this.user.getAllSubnamesForAsset(chainName, tokenAddress);
      return res;
    } catch (err) {
      return err;
    }
  }

  async getAssetHistory(chainName: string, tokenAddress?: string, triaName?: string) {
    try {
      const res = await this.user.getAssetHistory(
        (this.triaName || triaName) as string,
        chainName,
        tokenAddress
      );
      return res;
    } catch (err) {
      return err;
    }
  }

  async getNFTs(
    sort: 'A-Z' | 'Z-A' | 'Ascending buy date' | 'Descending buy date' = 'Descending buy date',
    filter?: 'all' | 'favorites',
    filterByCollectionId?: string,
    filterChainNames?: string[],
    triaName?: string
  ) {
    try {
      const res = await this.user.getNFTs(
        (this.triaName || triaName) as string,
        sort,
        filter,
        filterByCollectionId,
        filterChainNames
      );
      return res;
    } catch (err) {
      return err;
    }
  }

  async getNFTCollections(filterChainNames?: string[], triaName?: string) {
    try {
      const res = await this.user.getNFTCollections(
        (this.triaName || triaName) as string,
        filterChainNames
      );
      return res;
    } catch (err) {
      return err;
    }
  }

  async getNFTDetails(chainName: string, tokenAddress: string, tokenId: string, triaName?: string) {
    try {
      const res = await this.user.getNFTDetails(
        (this.triaName || triaName) as string,
        chainName,
        tokenAddress,
        tokenId
      );
      return res;
    } catch (err) {
      return err;
    }
  }

  async getAllNfts(
    filter?: 'all' | 'favorites',
    filterAssetGroup?: string,
    filterChainNames?: string[]
    // sort?: 'amountAsc' | 'amountDesc'
  ) {
    try {
      const res = await this.user.getAllNfts(filter, filterAssetGroup, filterChainNames);
      return res;
    } catch (err) {
      return err;
    }
  }

  async getNftDetails(chainName: string, tokenAddress: string, tokenId: string) {
    try {
      const res = await this.user.getNftDetails(chainName, tokenAddress, tokenId);
      return res;
    } catch (err) {
      return err;
    }
  }

  async getNftHistory(chainName: string, tokenAddress: string, tokenId: string) {
    try {
      const res = await this.user.getNftHistory(chainName, tokenAddress, tokenId);
      return res;
    } catch (err) {
      return err;
    }
  }

  async getUserByAddress(address: string, chainName: string) {
    try {
      const res = await this.user.getUserByAddress(address, chainName);
      return res;
    } catch (err) {
      return err;
    }
  }

  async getAddressByChainName(triaName: string, chainName: string) {
    try {
      const res = await this.user.getAddressByChainName(triaName, chainName);
      return res;
    } catch (err) {
      return err;
    }
  }

  async getNextSubname() {
    try {
      const res = await this.user.getNextSubname();
      return res;
    } catch (err) {
      return err;
    }
  }

  async convertToken(chainName: string, fromToken: string, fromAmount: number, toToken: string) {
    try {
      const res = await this.user.convertToken(chainName, fromToken, fromAmount, toToken);
      return res;
    } catch (err) {
      return err;
    }
  }

  async getRampnalysisUrl(address: string, coinSymbol: string): Promise<RampnalysisUrlResponse> {
    try {
      const res = await this.user.getRampnalysisUrl(address, coinSymbol);
      return res;
    } catch (err) {
      return { success: false, url: null };
    }
  }

  async getRampnalysisSupportedToken(query: string): Promise<RampnalysisSupportedResponse> {
    try {
      const res = await this.user.getRampnalysisSupportedToken(query);
      return res;
    } catch (err) {
      return { success: false, data: null };
    }
  }

  async getAllNetworks() {
    try {
      const res = await this.user.getAllNetworks();
      return res;
    } catch (err) {
      return err;
    }
  }

  async markAssetAsFavourite(chainName: string, tokenAddress?: string) {
    try {
      const res = await this.user.markAssetAsFavourite(chainName, tokenAddress);
      return res;
    } catch (err) {
      return err;
    }
  }

  async markNFTsAsFavourite(chainName: string, tokenAddress: string, tokenId: string) {
    try {
      const res = await this.user.markNFTsAsFavourite(chainName, tokenAddress, tokenId);
      return res;
    } catch (err) {
      return err;
    }
  }

  async unMarkAssetAsFavourite(chainName: string, tokenAddress?: string) {
    try {
      const res = await this.user.unMarkAssetAsFavourite(chainName, tokenAddress);
      return res;
    } catch (err) {
      return err;
    }
  }

  async unMarkNFTsAsFavourite(chainName: string, tokenAddress: string, tokenId: string) {
    try {
      const res = await this.user.unMarkNFTsAsFavourite(chainName, tokenAddress, tokenId);
      return res;
    } catch (err) {
      return err;
    }
  }

  async getAssetChartData(
    symbol: string,
    timePeriod: 'daily' | 'hourly' = 'daily',
    interval: string = 'daily',
    count: number = 10
  ) {
    try {
      const res = await this.user.getAssetChartData(
        symbol as string,
        timePeriod as 'daily' | 'hourly',
        interval as string,
        count
      );
      return res;
    } catch (err) {
      return err;
    }
  }

  async getAssetChart(
    timePeriod: 'hour' | 'day' | 'week' | 'month' | 'year' | 'max',
    chainName: string,
    tokenAddress?: string
  ) {
    try {
      const res = await this.user.getAssetChart(timePeriod, chainName, tokenAddress);
      return res;
    } catch (err) {
      return err;
    }
  }

  async getTotalBalance(triaName?: string): Promise<GetTotalBalanceResponse> {
    try {
      const res = await this.user.getTotalBalance((this.triaName || triaName) as string);
      return res;
    } catch (err) {
      return { success: false, message: 'Unable to fetch total balance' };
    }
  }

  async getChainNameByTriaName(triaName: string): Promise<GetChainNameByTriaName> {
    try {
      const res = await this.user.getChainNameByTriaName(triaName);
      return res;
    } catch (err) {
      return { success: false, chains: [], message: 'Unable to fetch chains for triaName' };
    }
  }

  async claimDrinks() {
    try {
      const res = await this.user.claimDrinks();
      return res;
    } catch (err) {
      return { success: false, message: 'Unable to claim drinks' };
    }
  }

  async hasClaimed() {
    try {
      const res = await this.user.hasClaimed();
      return res;
    } catch (err) {
      return err;
    }
  }

  async getAvatar(accessToken: string) {
    try {
      const res = await this.user.getAvatar(accessToken);
      return res;
    } catch (err) {
      return err;
    }
  }

  async updateAvatar(accessToken: string) {
    try {
      const res = await this.user.updateAvatar(accessToken);
      return res;
    } catch (err) {
      return err;
    }
  }

  async getPopularToken() {
    try {
      const res = await this.user.getPopularToken();
      return res;
    } catch (err) {
      return err;
    }
  }

  async searchBuyToken(tokenName: string, currentChainName: string) {
    try {
      const res = await this.user.searchBuyToken(tokenName, currentChainName);
      return res;
    } catch (err) {
      return err;
    }
  }

  async addUserActivity(triaName: string, sentToTriaName: string) {
    try {
      const res = await this.user.addUserActivity(triaName, sentToTriaName);
      return res;
    } catch (err) {
      return err;
    }
  }

  async getRecentUsersForUser(triaName: string) {
    try {
      const res = await this.user.getRecentUsersForUser(triaName);
      return res;
    } catch (err) {
      return err;
    }
  }

  async deleteARecentUser(user: string, recentUser: string) {
    try {
      const res = await this.user.deleteARecentUser(user, recentUser);
      return res;
    } catch (err) {
      return err;
    }
  }
}
