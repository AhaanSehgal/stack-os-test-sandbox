import BackendService from './index';
import { ENV } from '../types';
declare class userService extends BackendService {
    environment: ENV;
    constructor(apiUrl: string, environment?: ENV);
    get_tID(): Promise<any>;
    getActions(): Promise<any>;
    requestAmount({ tag, payload }: {
        tag: string;
        payload: Object;
    }): Promise<any>;
    completeAction({ actionId }: {
        actionId: string;
    }): Promise<any>;
    ignoreAction({ actionId }: {
        actionId: string;
    }): Promise<any>;
    getConversation({ participantName }: {
        participantName: string;
    }): Promise<any>;
    search({ term }: {
        term: string;
    }): Promise<any>;
    searchUser({ term }: {
        term: string;
    }): Promise<any>;
    getSubnames(): Promise<any>;
    getAllAddresses(triaName: string): Promise<unknown>;
    getAllHistory(triaName: string, filter?: 'all' | 'transactionSent' | 'transactionReceived', filterChainNames?: string[]): Promise<any>;
    getOnChainConversation(triaName: string, withTriaName: string): Promise<any>;
    getTotalBalance(triaName: string): Promise<any>;
    getAssets(triaName: string, filterChainNames?: string[], filter?: 'all' | 'favorites', sort?: 'amountAsc' | 'amountDesc'): Promise<any>;
    getAssetsForATriaName(triaName: string, filterChainNames?: string[], sort?: 'amountAsc' | 'amountDesc'): Promise<any>;
    getAsset(triaName: string, chainName: string, tokenAddress?: string): Promise<any>;
    getAssetBalanceForATriaName(triaName: string, chainName: string, tokenAddress?: string): Promise<any>;
    getAssetDetails(triaName: string, chainName: string, tokenAddress?: string): Promise<any>;
    getSubnamesForAsset(chainName: string, tokenAddress?: string): Promise<any>;
    getAllSubnamesForAsset(chainName: string, tokenAddress?: string): Promise<any>;
    getAssetHistory(triaName: string, chainName: string, tokenAddress?: string): Promise<any>;
    getNFTs(triaName: string, sort?: 'A-Z' | 'Z-A' | 'Ascending buy date' | 'Descending buy date', filter?: 'all' | 'favorites', filterByCollectionId?: string, filterChainNames?: string[]): Promise<any>;
    getNFTCollections(triaName: string, filterChainNames?: string[]): Promise<any>;
    getNFTDetails(triaName: string, chainName: string, tokenAddress: string, tokenId: string): Promise<any>;
    getAllNfts(filter?: 'all' | 'favorites', filterAssetGroup?: string, filterChainNames?: string[]): Promise<any>;
    getNftDetails(chainName: string, tokenAddress: string, tokenId: string): Promise<any>;
    getNftHistory(chainName: string, tokenAddress: string, tokenId: string): Promise<any>;
    getUserByAddress(address: string, chainName: string): Promise<any>;
    getAddressByChainName(triaName: string, chainName: string): Promise<any>;
    getNextSubname(): Promise<any>;
    getRampnalysisUrl(address: string, coinSymbol: string): Promise<any>;
    getRampnalysisSupportedToken(query: string): Promise<any>;
    convertToken(chainName: string, fromToken: string, fromAmount: number, toToken: string): Promise<any>;
    getAllNetworks(): Promise<any>;
    getChainNameByTriaName(triaName: string): Promise<any>;
    markAssetAsFavourite(chainName: string, tokenAddress?: string): Promise<any>;
    unMarkAssetAsFavourite(chainName: string, tokenAddress?: string): Promise<any>;
    markNFTsAsFavourite(chainName: string, tokenAddress: string, tokenId: string): Promise<any>;
    unMarkNFTsAsFavourite(chainName: string, tokenAddress: string, tokenId: string): Promise<any>;
    getAssetChartData(symbol: string, timePeriod?: 'daily' | 'hourly', interval?: string, count?: number): Promise<any>;
    getAssetChart(timePeriod: 'hour' | 'day' | 'week' | 'month' | 'year' | 'max', chainName: string, tokenAddress?: string): Promise<any>;
    claimDrinks(): Promise<any>;
    hasClaimed(): Promise<any>;
    updateAvatar(accessToken: string): Promise<any>;
    getAvatar(accessToken: string): Promise<any>;
    getPopularToken(): Promise<any>;
    searchBuyToken(tokenName: string, currentChainName: string): Promise<any>;
    addUserActivity(triaName: string, sentToTriaName: string): Promise<any>;
    getRecentUsersForUser(triaName: string): Promise<any>;
    deleteARecentUser(user: string, recentUser: string): Promise<any>;
}
export default userService;
