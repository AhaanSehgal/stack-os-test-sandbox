var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// @ts-ignore
import { ChaCha20Poly1305 } from '@stablelib/chacha20poly1305';
//@ts-ignore
import { pbkdf2Sync, createCipheriv, createDecipheriv, randomBytes } from '../core-lib/crypto';
//@ts-ignore
import crypto from '../core-lib/crypto';
//@ts-ignore
import { Buffer } from '../core-lib/buffer';
//@ts-ignore
import * as secrets from 'sss-tria';
export const generateShadowHash = ({ secret, salt }) => __awaiter(void 0, void 0, void 0, function* () {
    let derivedKey = pbkdf2Sync(secret, salt, 5000, 32, 'sha512');
    return derivedKey;
});
export const generateSHA256 = (inputData) => {
    const hash = crypto.createHash('sha256');
    hash.update(inputData, 'utf-8');
    return hash.digest('hex');
};
export function encryptAES256(key, data) {
    const iv = randomBytes(16);
    const cipher = createCipheriv('aes-256-cbc', key, iv);
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return iv.toString('hex') + ':' + encrypted;
}
export function decryptAES(ciphertext, key, iv) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log({ ciphertext, key, iv });
        const decipher = createDecipheriv('aes-256-cbc', key, iv);
        let decrypted = decipher.update(ciphertext, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    });
}
export function shamir(secret, shares, threshold) {
    //@ts-ignore
    let shards = secrets.share(secret, shares, threshold);
    return shards;
}
export function combine(shares) {
    return secrets.combine(shares);
}
export function ChaCha20Poly1305_Encrypt(key, nonce, data) {
    const instance = new ChaCha20Poly1305(new Uint8Array(key));
    const encryptedData = instance.seal(new Uint8Array(nonce), data);
    return Buffer.from(encryptedData);
}
export function ChaCha20Poly1305_Dcrypt(key, nonce, data) {
    //console.log({ key, nonce, data });
    const instance = new ChaCha20Poly1305(new Uint8Array(key));
    const encryptedData = instance.open(new Uint8Array(Buffer.from(nonce, 'hex')), data);
    if (!encryptedData)
        return 'decryption failed!!';
    return Buffer.from(encryptedData).toString();
}
