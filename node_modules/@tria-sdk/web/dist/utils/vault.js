var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ChaCha20Poly1305_Dcrypt, combine, decryptAES, generateSHA256 } from "./crypto";
import { shamir } from '../utils/crypto';
//@ts-ignore
import { Buffer } from '../core-lib/buffer';
import IPFSService from "../services/ipfs";
import ArweaveService from "../services/arweave";
//@ts-ignore
import * as secrets from 'sss-tria';
export const reconstruct = (tID, shadowHash, apiUrl) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const ipfs = new IPFSService(apiUrl);
        const arweave = new ArweaveService(apiUrl);
        const SHA256ShadowHash = generateSHA256(shadowHash.toString('hex'));
        console.log("1");
        const { keyLinkShare1IPNS, keyLinkShare2IPNS } = yield ipfs.getKeyLinkShards(tID, SHA256ShadowHash);
        console.log("2");
        const pathShare1IPNS = yield ipfs.resolveName(keyLinkShare1IPNS[0].keyLinkShare1IPNS);
        //console.log(pathShare1IPNS)
        console.log("3");
        const pathShare2IPNS = yield ipfs.resolveName(keyLinkShare2IPNS[0].keyLinkShare2IPNS);
        //console.log(pathShare2IPNS)
        console.log("4");
        const keyLinkShare1Content = yield ipfs.fetchIPFSData(pathShare1IPNS);
        console.log("5");
        const keyLinkShare2Content = yield ipfs.fetchIPFSData(pathShare2IPNS);
        const encryptedKeyLink = combine([keyLinkShare1Content, keyLinkShare2Content]);
        //console.log(secrets.hex2str(encryptedKeyLink))
        const encryptedText = secrets.hex2str(encryptedKeyLink);
        console.log("decryptAES...");
        const decryptedData = yield decryptAES(encryptedText.split(':')[1], shadowHash, Buffer.from(encryptedText.split(':')[0], 'hex'));
        const keyLinks = JSON.parse(decryptedData);
        //console.log({ keyLinks });
        const vaultEncryptedShares = [];
        console.log("6");
        const vaultShare1IPNSPath = yield ipfs.resolveName(keyLinks.ipns[0]);
        console.log("7");
        const vaultShare2IPNSPath = yield ipfs.resolveName(keyLinks.ipns[1]);
        //console.log({ vaultShare1IPNSPath, vaultShare2IPNSPath })
        console.log("8");
        vaultEncryptedShares.push(JSON.parse(yield ipfs.fetchIPFSData(vaultShare1IPNSPath)));
        9;
        console.log("9");
        vaultEncryptedShares.push(JSON.parse(yield ipfs.fetchIPFSData(vaultShare2IPNSPath)));
        // console.log("vaultEncryptedShares1", vaultEncryptedShares);
        // console.log("keyLinks.arweaveTxId[0]", keyLinks.arweaveTxId[0]);
        // console.log("keyLinks.arweaveTxId[1]", keyLinks.arweaveTxId[1]);
        console.log("10");
        vaultEncryptedShares.push(yield arweave.getData(keyLinks.arweaveTxId[0].id));
        console.log("11");
        vaultEncryptedShares.push(yield arweave.getData(keyLinks.arweaveTxId[1].id));
        // console.log("vaultEncryptedShares2", vaultEncryptedShares);
        // console.log("keyLinks.ChaChaKey.data", keyLinks.ChaChaKey.data)
        const decryptedShares = [];
        console.log("chacha...");
        vaultEncryptedShares.map((encryptedShare) => {
            //@ts-ignore
            const parsedData = JSON.parse(JSON.stringify(encryptedShare));
            // console.log("parsedData", parsedData)
            decryptedShares.push(ChaCha20Poly1305_Dcrypt(keyLinks.ChaChaKey.data, parsedData.nonce, new Uint8Array(Buffer.from(parsedData.encryptedShare, 'hex'))));
            // console.log(data)
        });
        const encryptedVault = combine(decryptedShares.slice(0, 3));
        const encryptedVaultText = secrets.hex2str(encryptedVault);
        // console.log("encryptedVaultText", encryptedVaultText)
        const decryptedVaultData = yield decryptAES(encryptedVaultText.split(':')[1], shadowHash, Buffer.from(encryptedVaultText.split(':')[0], 'hex'));
        const parsedDecryptedVaultData = JSON.parse(decryptedVaultData);
        // console.log({ parsedDecryptedVaultData });
        delete parsedDecryptedVaultData.keyPairs1;
        delete parsedDecryptedVaultData.keyPairs2;
        return {
            vault: parsedDecryptedVaultData
        };
    }
    catch (err) {
        console.log(err);
    }
});
export const shardNonEvmVaultKeys = (nonEVMValut) => __awaiter(void 0, void 0, void 0, function* () {
    let nonEvmShard1Vault = {};
    let nonEvmShard2Vault = {};
    for (let triaName of Object.keys(nonEVMValut)) {
        nonEvmShard1Vault[triaName] = {};
        nonEvmShard2Vault[triaName] = {};
        for (let chain of Object.keys(nonEVMValut[triaName])) {
            const privateKey = nonEVMValut[triaName][chain].privateKey;
            if (privateKey) {
                const pkShards = shamir(secrets.str2hex(privateKey), 2, 2);
                delete nonEVMValut[triaName][chain].privateKey;
                nonEvmShard1Vault[triaName][chain] = Object.assign(Object.assign({}, nonEVMValut[triaName][chain]), { shard: pkShards[0] });
                nonEvmShard2Vault[triaName][chain] = Object.assign(Object.assign({}, nonEVMValut[triaName][chain]), { shard: pkShards[1] });
            }
        }
    }
    // api request
    return { nonEvmShard1Vault, nonEvmShard2Vault };
});
