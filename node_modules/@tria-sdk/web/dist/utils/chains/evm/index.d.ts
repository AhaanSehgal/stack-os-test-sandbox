import { ethers } from 'ethers';
import { SendPayload, SwapPayload, ApprovePayload, CheckTokenAllowance, NFTDetails } from '../../../types/chain';
import { Chain } from '../../../interfaces/chain';
import { ContractDetails, FeeResponse, ReadContractResponse, SwapTargetResponse, TxnObjectResponse, TxnResponse, WalletType } from '../../../types';
/**
 * EVM Class for all interactions with EVM compatible chains
 *
 * we use the rpcUrl for making chain provider
 * and chainId for swap on 1inch api
 *
 * https://docs.1inch.io/docs/aggregation-protocol/api/swagger
 */
export declare class EVM implements Chain {
    private rpcUrl;
    private chainId;
    private chainName;
    private okxDexApiUrl;
    private triaApiBaseUrl;
    walletType: WalletType;
    /**
     * In case of EVM, uses the rpcUrl to make a provider
     *
     * Sets the chain id and provider instance
     *
     * @param chainId - A chain id for using 1inch apis.
     * @param rpcUrl - A rpcUrl for the provider
     */
    constructor(baseUrl: string, chainId: number, rpcUrl: string, chainName?: string, walletType?: WalletType);
    /**
     * Get RPC provider for embedded or external wallet
     *
     * @returns providerInstance
     */
    getProvider(): ethers.providers.JsonRpcProvider;
    /**
     * Derives new wallet for a chain using mnemonic and derivation path
     *
     * Returns the publicKey and privateKey
     *
     * @param mnemonic - An account address.
     * @param derivationPath - derivation path chain specific and derivationIndex calc?
     * @param derivationPathIndex - index
     * @returns The public key and private key.
     */
    createWallet(mnemonic: string, derivationPathIndex: number): Promise<{
        address: string;
        privateKey: string;
    }>;
    getTokenDetails(tokenAddress?: string): Promise<{
        name: any;
        symbol: any;
        decimals: any;
    }>;
    /**
     * Gets balance for native token or asset
     *
     * Returns the currently initialized keyring that manages
     * the specified `address` if one exists.
     *
     * @param accountAddress - An account address.
     * @param tokenAddress - A asset contract address
     * @returns The keyring of the account, if it exists.
     */
    getBalance(accountAddress: string, tokenAddress?: string): Promise<{
        name: any;
        symbol: any;
        balance: number;
        balanceInUnits: any;
        decimals: any;
    }>;
    /**
     * Checks the validity of a txn based on the balance and transfer amount.
     *
     *
     * @param accountAddress - An account address.
     * @param amount - Amount to transfer
     * @param tokenAddress - A asset contract address // optional
     * @returns The keyring of the account, if it exists.
     */
    checkSendValidity(accountAddress: string, amount: number, tokenAddress?: string): Promise<boolean>;
    /**
     * Sends the token amount
     *
     * @param signer - for signing txns
     * @param tokenAddress - if transferring a ERC20 token
     * @param amount - amount to transfer
     *
     * @returns Returns the txn object or hash - tbd
     */
    send({ signer, fromAddress, tokenAddress, recipientAddress, amount, }: SendPayload): Promise<TxnResponse>;
    getSendFee(fromAddress: string, recipientAddress: string, amount: number, tokenAddress?: string): Promise<FeeResponse>;
    getSendTxnObject(fromAddress: string, recipientAddress: string, amount: number, tokenAddress?: string): Promise<TxnObjectResponse>;
    /**
     * Swap tokens using 1inch aggregator
     *
     * Swap from asset to asset working
     * Naitve token to asset params to be figured out
     *
     * @param signer - to broadcast swap txn
     * @param fromTokenAddress - token to be swapped
     * @param toTokenAddress - token to be returned
     * @param amount - from amount - in number e.g. 0.1 ETH
     * @param fromAddress - address performing txn
     * @param slippage - in percentage e.g. 1%
     *
     */
    swap({ signer, fromTokenAddress, toTokenAddress, amount, slippage }: SwapPayload): Promise<TxnObjectResponse | TxnResponse>;
    getSwapTxnObject(fromAddress: string, fromTokenAddress: string, toTokenAddress: string, amount: number, slippage: number): Promise<TxnObjectResponse>;
    getSwapFee(fromAddress: string, fromTokenAddress: string, toTokenAddress: string, amount: number, slippage: number): Promise<FeeResponse>;
    getEstimateFee(txnObject: Object): Promise<FeeResponse>;
    getSwapTargets(fromTokenAddress: string | null, listLength: number, query?: string): Promise<SwapTargetResponse[]>;
    stake(signer: ethers.Wallet | ethers.providers.JsonRpcSigner, address: string, amount: number): Promise<TxnResponse>;
    /**
     * Approve tokens to be spent by 1inch router contract
     *
     * @param signer
     * @param tokenAddress - token contract address to be swapped
     * @param accountAddress
     * @returns
     */
    approve({ signer, fromAddress, tokenAddress, amount, spender, }: ApprovePayload): Promise<TxnResponse>;
    getApproveFee(fromAddress: string, tokenAddress: string, amount: number, spender: string): Promise<FeeResponse>;
    getApproveTxnObject(fromAddress: string, tokenAddress: string, amount: number, spender: string): Promise<TxnObjectResponse>;
    private swapOn1inch;
    private swapOnOkx;
    approveOn1inch({ tokenAddress, parsedAmount }: any): Promise<{
        success: boolean;
        txnObject: any;
        message?: undefined;
    } | {
        success: boolean;
        message: string;
        txnObject?: undefined;
    }>;
    approveOnOkx({ tokenAddress, parsedAmount, fromAddress }: any): Promise<{
        success: boolean;
        txnObject: {
            data: any;
            from: any;
            to: any;
            gasLimit: string;
            gasPrice: string;
            value: number;
        };
        message?: undefined;
    } | {
        success: boolean;
        message: string;
        txnObject?: undefined;
    }>;
    /**
     *
     * Checks allowance for the 1inch router contract address
     *
     * @param accountAddress - account holding tokens
     * @param tokenAddress - token to check allowance
     * @param amount - amount to be spent, e.g. 0.1 ETH
     *
     * @returns bool if allowance needed or not
     */
    checkTokenAllowance({ accountAddress, tokenAddress, amount, spender, }: CheckTokenAllowance): Promise<boolean>;
    getAllowanceOnOkx({ accountAddress, tokenAddress }: any): Promise<any>;
    /**
     * Broadcasts the txn on-chain.
     *
     * @param signer
     * @param txnObject - Txn object data to broadcast
     * @returns
     */
    broadcastTransaction(signer: ethers.Wallet | ethers.providers.JsonRpcSigner, txnObject: Object): Promise<TxnResponse>;
    /**
     * Helper function for creating contract instance
     *
     * Returns the contract instance
     *
     * TODO - add error handling for invalid erc20 contract addresss
     *
     * @param contractAddress - An account address.
     * @param abi - A asset contract address
     * @returns The contract instance.
     */
    getContract(contractAddress: string, signer?: ethers.Wallet | ethers.providers.JsonRpcSigner, abi?: Object[]): Promise<{
        contract: ethers.Contract;
    }>;
    callContract(contractDetails: ContractDetails, signer: ethers.Wallet | ethers.providers.JsonRpcSigner): Promise<TxnResponse>;
    getCallContractFee(contractDetails: ContractDetails, fromAddress: string): Promise<FeeResponse>;
    createCallContractTxnObject(contractDetails: ContractDetails, fromAddress: string): Promise<TxnObjectResponse>;
    readContract(contractDetails: ContractDetails): Promise<ReadContractResponse>;
    /**
     * Helper function for creating signer and getting nonce and gas
     *
     * @param privateKey - A private key.
     * @returns The signer, nonce, gas, gasPrice.
     */
    getSigner(privateKey?: string): Promise<{
        signer: ethers.Wallet | ethers.providers.JsonRpcSigner;
    }>;
    getGasDetailsAndNonce(fromAddress: string): Promise<{
        nonce: number;
        gasPrice: ethers.BigNumber | null;
        gasLimit: number;
    }>;
    signMessage(signer: ethers.Wallet | ethers.providers.JsonRpcSigner, message: string | ethers.utils.Bytes): Promise<string>;
    getTxnDetails(txnHash: string): Promise<ethers.providers.TransactionReceipt>;
    isContractAddress(address: string): Promise<boolean>;
    isERC20Address(address: string): Promise<boolean>;
    is1inchRouterContract(address: string): Promise<boolean>;
    get1inchRouterContractAddress(): Promise<any>;
    getSendNFTFee(fromAddress: string, recipientAddress: string, nftDetails: NFTDetails): Promise<FeeResponse>;
    sendNFT(signer: ethers.Wallet | ethers.providers.JsonRpcSigner, fromAddress: string, recipientAddress: string, nftDetails: NFTDetails): Promise<TxnResponse>;
    getSendNFTTxnObject(fromAddress: string, recipientAddress: string, { type, tokenAddress, tokenId, amount }: NFTDetails): Promise<TxnObjectResponse>;
    /**
     * Bali beta specific.
     * To redeem food coupons.
     *
     */
    burnNFT(signer: ethers.Wallet | ethers.providers.JsonRpcSigner, { type, tokenAddress, tokenId, amount }: NFTDetails): Promise<TxnResponse>;
}
