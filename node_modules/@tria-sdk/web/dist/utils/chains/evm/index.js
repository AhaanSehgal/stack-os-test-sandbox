var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ethers } from 'ethers';
import axios from 'axios';
import erc20Abi from './utils/abis/erc20';
import { LIDO_ABI, LIDO_ADDRESS } from './utils/abi';
import { nativeTokenDetails, txnBaseUrl } from '../../helper/constants';
import { getTokenPrice } from '../../coingecko/getPrices';
import { checksumAddress } from '../../helper/checksum';
// import Decimal from 'decimal.js';
// import { getBalanceInTokens } from '../../helper/format';
import { erc1155ABI } from './utils/abis/erc1155';
import { erc721ABI } from './utils/abis/erc721';
import { CouponsABI } from './utils/abis/CouponsAbi';
import { getEthersProvider, getEthersSigner } from './utils/adapter';
/**
 * EVM Class for all interactions with EVM compatible chains
 *
 * we use the rpcUrl for making chain provider
 * and chainId for swap on 1inch api
 *
 * https://docs.1inch.io/docs/aggregation-protocol/api/swagger
 */
export class EVM {
    /**
     * In case of EVM, uses the rpcUrl to make a provider
     *
     * Sets the chain id and provider instance
     *
     * @param chainId - A chain id for using 1inch apis.
     * @param rpcUrl - A rpcUrl for the provider
     */
    constructor(baseUrl, chainId, rpcUrl, chainName, walletType) {
        this.okxDexApiUrl = 'https://www.okx.com/api/v5/dex/aggregator';
        this.walletType = walletType;
        console.log(`EVM chain instance for ${chainId} ${chainName}`, { walletType });
        // this.providerInstance = providerInstance;
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.chainName = chainName;
        this.triaApiBaseUrl = `${baseUrl}/api/v1`;
    }
    /**
     * Get RPC provider for embedded or external wallet
     *
     * @returns providerInstance
     */
    getProvider() {
        var _a;
        const providerInstance = ((_a = this.walletType) === null || _a === void 0 ? void 0 : _a.embedded) || !this.walletType
            ? new ethers.providers.JsonRpcProvider(this.rpcUrl)
            : getEthersProvider({ chainId: this.chainId });
        return providerInstance;
    }
    /**
     * Derives new wallet for a chain using mnemonic and derivation path
     *
     * Returns the publicKey and privateKey
     *
     * @param mnemonic - An account address.
     * @param derivationPath - derivation path chain specific and derivationIndex calc?
     * @param derivationPathIndex - index
     * @returns The public key and private key.
     */
    createWallet(mnemonic, derivationPathIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallet = ethers.Wallet.fromMnemonic(mnemonic, `m/44'/60'/0'/0/${derivationPathIndex}`);
            return {
                address: wallet.address,
                privateKey: wallet.privateKey,
            };
        });
    }
    getTokenDetails(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let decimals;
                let name;
                let symbol;
                if (tokenAddress) {
                    const { contract } = yield this.getContract(tokenAddress);
                    name = yield contract.name();
                    symbol = yield contract.symbol();
                    decimals = yield contract.decimals();
                }
                else {
                    //@ts-ignore
                    name = nativeTokenDetails[this.chainName].name;
                    //@ts-ignore
                    symbol = nativeTokenDetails[this.chainName].symbol;
                    decimals = 18;
                }
                return {
                    name,
                    symbol,
                    decimals,
                };
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * Gets balance for native token or asset
     *
     * Returns the currently initialized keyring that manages
     * the specified `address` if one exists.
     *
     * @param accountAddress - An account address.
     * @param tokenAddress - A asset contract address
     * @returns The keyring of the account, if it exists.
     */
    getBalance(accountAddress, tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let balance;
                const { name, symbol, decimals } = yield this.getTokenDetails(tokenAddress);
                if (tokenAddress) {
                    const { contract } = yield this.getContract(tokenAddress);
                    // console.log(contract);
                    balance = yield contract.balanceOf(accountAddress);
                }
                else {
                    balance = yield this.getProvider().getBalance(accountAddress);
                }
                return {
                    name,
                    symbol,
                    balance: parseFloat(decimals ? ethers.utils.formatUnits(balance, decimals) : ethers.utils.formatEther(balance)),
                    balanceInUnits: balance.toString(),
                    decimals,
                };
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * Checks the validity of a txn based on the balance and transfer amount.
     *
     *
     * @param accountAddress - An account address.
     * @param amount - Amount to transfer
     * @param tokenAddress - A asset contract address // optional
     * @returns The keyring of the account, if it exists.
     */
    checkSendValidity(accountAddress, amount, tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            let { balanceInUnits: accountBalance, decimals } = yield this.getBalance(accountAddress, tokenAddress);
            let transferAmount = decimals
                ? ethers.utils.parseUnits(amount.toString(), decimals)
                : ethers.utils.parseEther(amount.toString());
            // console.log({ transferAmount: transferAmount.toString(), accountBalance });
            return transferAmount.lt(ethers.BigNumber.from(accountBalance));
        });
    }
    /**
     * Sends the token amount
     *
     * @param signer - for signing txns
     * @param tokenAddress - if transferring a ERC20 token
     * @param amount - amount to transfer
     *
     * @returns Returns the txn object or hash - tbd
     */
    send({ signer, fromAddress, tokenAddress, recipientAddress, amount, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.getSendTxnObject(fromAddress, recipientAddress, amount, tokenAddress);
            if (res.success && (res === null || res === void 0 ? void 0 : res.txnObject)) {
                const txnRes = yield this.broadcastTransaction(signer, res === null || res === void 0 ? void 0 : res.txnObject);
                return txnRes;
            }
            else
                return res;
        });
    }
    getSendFee(fromAddress, recipientAddress, amount, tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('getSendTxnObject');
            const res = yield this.getSendTxnObject(fromAddress, recipientAddress, amount, tokenAddress);
            if (res.success) {
                const fee = yield this.getEstimateFee(res.txnObject);
                return fee;
            }
            else {
                return res;
            }
        });
    }
    getSendTxnObject(fromAddress, recipientAddress, amount, tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const valid = yield this.checkSendValidity(fromAddress, amount, // in number, e.g. 0.1 ETH
            tokenAddress);
            const { gasPrice, gasLimit, nonce } = yield this.getGasDetailsAndNonce(fromAddress);
            if (valid)
                try {
                    let txnObject;
                    if (tokenAddress) {
                        const { contract } = yield this.getContract(tokenAddress);
                        const decimals = yield contract.decimals();
                        console.log({ decimals });
                        txnObject = yield contract.populateTransaction.transfer(recipientAddress, ethers.utils.parseUnits(amount.toString(), decimals), {
                            gasPrice,
                            nonce,
                        });
                        console.log({ res: txnObject });
                    }
                    else {
                        txnObject = {
                            to: recipientAddress,
                            value: ethers.utils.parseEther(amount.toString()),
                            gasPrice,
                            nonce,
                            data: '0x',
                        };
                    }
                    return { success: true, txnObject: Object.assign(Object.assign({}, txnObject), { from: fromAddress }) };
                }
                catch (error) {
                    // throw error;
                    return { success: false, message: 'Error creating send txn object' };
                }
            else
                return { success: false, message: 'Not a valid txn, insufficient funds' };
        });
    }
    /**
     * Swap tokens using 1inch aggregator
     *
     * Swap from asset to asset working
     * Naitve token to asset params to be figured out
     *
     * @param signer - to broadcast swap txn
     * @param fromTokenAddress - token to be swapped
     * @param toTokenAddress - token to be returned
     * @param amount - from amount - in number e.g. 0.1 ETH
     * @param fromAddress - address performing txn
     * @param slippage - in percentage e.g. 1%
     *
     */
    swap({ signer, fromTokenAddress, toTokenAddress, amount, slippage }) {
        return __awaiter(this, void 0, void 0, function* () {
            const fromAddress = yield signer.getAddress();
            const res = yield this.getSwapTxnObject(fromAddress, fromTokenAddress, toTokenAddress, amount, slippage);
            if (res.success && (res === null || res === void 0 ? void 0 : res.txnObject)) {
                const txnRes = yield this.broadcastTransaction(signer, res === null || res === void 0 ? void 0 : res.txnObject);
                return txnRes;
            }
            else {
                return res;
            }
        });
    }
    getSwapTxnObject(fromAddress, fromTokenAddress, toTokenAddress, amount, slippage) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('getSwapTxnObject');
            let contract;
            if (fromTokenAddress) {
                const res = yield this.getContract(fromTokenAddress);
                contract = res.contract;
            }
            const decimals = contract ? yield (contract === null || contract === void 0 ? void 0 : contract.decimals()) : 18;
            console.log({ decimals });
            const spender = yield this.get1inchRouterContractAddress();
            const valid = yield this.checkTokenAllowance({
                accountAddress: fromAddress,
                tokenAddress: fromTokenAddress,
                amount,
                spender,
            });
            console.log({ valid });
            const parsedAmount = ethers.utils.parseUnits(amount.toString(), decimals).toString();
            const swapParams = {
                fromTokenAddress,
                toTokenAddress,
                parsedAmount,
                fromAddress,
                slippage: slippage.toString(),
            };
            if (valid) {
                let txnObject;
                if (this.chainId == 66) {
                    const res = yield this.swapOnOkx(swapParams);
                    if (res.success) {
                        txnObject = res === null || res === void 0 ? void 0 : res.txnObject;
                    }
                    else
                        return res;
                }
                else {
                    const res = yield this.swapOn1inch(swapParams);
                    if (res.success) {
                        txnObject = res === null || res === void 0 ? void 0 : res.txnObject;
                    }
                    else
                        return res;
                }
                return { success: true, txnObject };
            }
            else
                return { success: false, message: 'Invalid swap txn, increase allowance' };
        });
    }
    getSwapFee(fromAddress, fromTokenAddress, toTokenAddress, amount, slippage) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.getSwapTxnObject(fromAddress, fromTokenAddress, toTokenAddress, amount, slippage);
            if (res.success) {
                const fee = yield this.getEstimateFee(res.txnObject);
                return fee;
            }
            else {
                return res;
            }
        });
    }
    getEstimateFee(txnObject) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                console.log('estimating gas..', txnObject);
                const estimatedGas = yield this.getProvider().estimateGas(txnObject);
                console.log('gas', estimatedGas.toString());
                const gasPrice = yield this.getProvider().getGasPrice();
                const tokenPrice = yield getTokenPrice(this.chainName);
                const gasFeeInWei = estimatedGas.mul(gasPrice);
                const gasFeeInEth = ethers.utils.formatEther(gasFeeInWei); // string
                // console.log({ gasFeeInEth });
                let gasFeeInUsd;
                if (tokenPrice === null || tokenPrice === void 0 ? void 0 : tokenPrice.usd) {
                    gasFeeInUsd = parseFloat(gasFeeInEth) * (tokenPrice === null || tokenPrice === void 0 ? void 0 : tokenPrice.usd);
                }
                return { success: true, fee: { eth: gasFeeInEth, usd: gasFeeInUsd === null || gasFeeInUsd === void 0 ? void 0 : gasFeeInUsd.toString() } };
            }
            catch (err) {
                // throw err;
                return {
                    success: false,
                    message: 'Insufficient gas or error while estimating fee',
                    error: err,
                };
            }
        });
    }
    getSwapTargets(fromTokenAddress, listLength, query) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield axios.get(`${this.triaApiBaseUrl}/chain/${this.chainId}/tokens`);
                const tokens = data === null || data === void 0 ? void 0 : data.tokens;
                let swapTargets = [];
                for (let [key, token] of Object.entries(tokens)) {
                    // @ts-ignore
                    const tokenAddress = token === null || token === void 0 ? void 0 : token.address;
                    const target = {
                        // @ts-ignore
                        name: token === null || token === void 0 ? void 0 : token.name,
                        // @ts-ignore
                        symbol: token === null || token === void 0 ? void 0 : token.symbol,
                        tokenAddress: tokenAddress !== '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'
                            ? checksumAddress(tokenAddress)
                            : null,
                        // @ts-ignore
                        logoUrl: token === null || token === void 0 ? void 0 : token.logoURI,
                        // decimals
                    };
                    if (target.tokenAddress === fromTokenAddress)
                        continue;
                    if (!query)
                        swapTargets.push(target);
                    // @ts-ignore
                    else if (query && (token === null || token === void 0 ? void 0 : token.symbol.toLowerCase().includes(query.toLowerCase()))) {
                        swapTargets.push(target);
                    }
                }
                return swapTargets.slice(0, listLength);
            }
            catch (error) {
                // throw new Error(`Error swapping token ${fromTokenAddress}: `);
                throw new Error(error);
            }
        });
    }
    stake(signer, address, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const MY_REWARDS_ADDRESS = address; // same as user // 'YOUR_REWARDS_ADDRESS';
            const { contract: lidoContract } = yield this.getContract(LIDO_ADDRESS, signer, LIDO_ABI);
            const txnObject = lidoContract.submit(MY_REWARDS_ADDRESS, {
                from: address,
                value: ethers.utils.parseEther(amount.toString()),
            });
            const txnRes = yield this.broadcastTransaction(signer, txnObject);
            return txnRes;
        });
    }
    /**
     * Approve tokens to be spent by 1inch router contract
     *
     * @param signer
     * @param tokenAddress - token contract address to be swapped
     * @param accountAddress
     * @returns
     */
    approve({ signer, fromAddress, tokenAddress, amount, spender, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!tokenAddress)
                return { success: false, message: 'Token address is null' };
            console.log({ fromAddress, tokenAddress, amount });
            const res = yield this.getApproveTxnObject(fromAddress, tokenAddress, amount, spender);
            if (res.success && (res === null || res === void 0 ? void 0 : res.txnObject)) {
                console.log('broadcasting approve');
                console.log('res?.txnObject ', res === null || res === void 0 ? void 0 : res.txnObject);
                const txnRes = yield this.broadcastTransaction(signer, res === null || res === void 0 ? void 0 : res.txnObject);
                return txnRes;
            }
            else
                return res;
        });
    }
    getApproveFee(fromAddress, tokenAddress, amount, spender) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!tokenAddress)
                return { success: false, message: 'Token address is null' };
            const res = yield this.getApproveTxnObject(fromAddress, tokenAddress, amount, spender);
            if (res.success) {
                console.log('res.txnObject ', res.txnObject);
                const fee = yield this.getEstimateFee(res.txnObject);
                return fee;
            }
            else {
                return res;
            }
        });
    }
    getApproveTxnObject(fromAddress, tokenAddress, amount, spender) {
        return __awaiter(this, void 0, void 0, function* () {
            const { contract } = yield this.getContract(tokenAddress);
            const decimals = yield contract.decimals();
            const parsedAmount = ethers.utils.parseUnits(amount.toString(), decimals);
            try {
                const txnObject = yield contract.populateTransaction.approve(spender, parsedAmount);
                return { success: true, txnObject: Object.assign(Object.assign({}, txnObject), { from: fromAddress }) };
            }
            catch (error) {
                // throw error;
                return { success: false, message: `Error approving token.` };
            }
        });
    }
    // async getApproveTxnObject(
    //   fromAddress: string,
    //   tokenAddress: string,
    //   amount: number,
    //   contractAddress: string
    // ): Promise<TxnObjectResponse> {
    //   const { contract } = await this.getContract(tokenAddress);
    //   const decimals = await contract.decimals();
    //   const parsedAmount = ethers.utils.parseUnits(amount.toString(), decimals);
    //   try {
    //     /* or get spenderAddress, i.e., 1inch router contract address
    //       and call approve function
    //     */
    //     let txnObject;
    //     if (this.chainId == 66) {
    //       // OKX
    //       const res = await this.approveOnOkx({
    //         tokenAddress,
    //         parsedAmount: parsedAmount.toString(),
    //         fromAddress,
    //       });
    //       if (res.success) {
    //         txnObject = res?.txnObject;
    //       } else return res;
    //     } else {
    //       // Other EVMs except CELO
    //       const res = await this.approveOn1inch({ tokenAddress, parsedAmount });
    //       if (res.success) {
    //         txnObject = res?.txnObject;
    //       } else return res;
    //     }
    //     console.log({ parsedAmount, txnObject, fromAddress });
    //     return {
    //       success: true,
    //       txnObject: {
    //         ...txnObject,
    //         from: fromAddress,
    //         gasPrice: ethers.utils.hexlify(parseInt(txnObject?.gasPrice)),
    //         value: ethers.utils.hexlify(parseInt(txnObject?.value)),
    //       },
    //     };
    //   } catch (error: any) {
    //     // throw error;
    //     return { success: false, message: `Error approving tokens on 1inch ${tokenAddress}` };
    //   }
    // }
    swapOn1inch({ fromTokenAddress, toTokenAddress, parsedAmount, fromAddress, slippage, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            console.log('swapOn1inch');
            try {
                const { data } = yield axios.get(`${this.triaApiBaseUrl}/chain/${this.chainId}/swap`, {
                    params: {
                        fromTokenAddress,
                        toTokenAddress,
                        fromAddress,
                        parsedAmount,
                        slippage,
                    },
                });
                const swapTxnObject = Object.assign(Object.assign({}, data.tx), { gasLimit: ethers.utils.hexlify(data.tx.gas), 
                    // not working hexlifying these.
                    gasPrice: ethers.utils.hexlify(parseInt(data.tx.gasPrice)), value: ethers.utils.hexlify(parseInt(data.tx.value)) });
                delete swapTxnObject['gas'];
                console.log({ swapOn1inch: swapTxnObject });
                return { success: true, txnObject: swapTxnObject };
            }
            catch (error) {
                // throw new Error(`Error swapping token ${fromTokenAddress}: `);
                // throw error;
                return {
                    success: false,
                    message: ((_a = error === null || error === void 0 ? void 0 : error.data) === null || _a === void 0 ? void 0 : _a.description) || 'Error estimating swap details, check if enough gas',
                };
            }
        });
    }
    swapOnOkx({ fromTokenAddress, toTokenAddress, parsedAmount, fromAddress, slippage, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data: swapData } = yield axios.get(`${this.okxDexApiUrl}/swap`, {
                    params: {
                        chainId: this.chainId,
                        fromTokenAddress,
                        toTokenAddress,
                        amount: parsedAmount,
                        userWalletAddress: fromAddress,
                        slippage: slippage, // in percent 0.5 -> 0.5%
                    },
                });
                const { data, from, gasPrice, gas, to, value } = swapData.data[0].tx;
                // console.log({ gasPrice, gas });
                const swapTxnObject = {
                    data,
                    from,
                    gasPrice: ethers.utils.hexlify(parseInt(gasPrice)),
                    gasLimit: ethers.utils.hexlify(parseInt(gas)),
                    to,
                    value: ethers.utils.hexlify(parseInt(value)),
                };
                return { success: true, txnObject: swapTxnObject };
            }
            catch (error) {
                // throw new Error(`Error swapping token ${fromTokenAddress}: `);
                // throw new Error(error);
                return {
                    success: false,
                    message: ((_a = error === null || error === void 0 ? void 0 : error.data) === null || _a === void 0 ? void 0 : _a.description) || 'Error estimating swap details, try increasing slippage',
                };
            }
        });
    }
    approveOn1inch({ tokenAddress, parsedAmount }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                /* or get spenderAddress, i.e., 1inch router contract address
                  and call approve function
                */
                const { data: approveTxnObject } = yield axios.get(`${this.triaApiBaseUrl}/chain/${this.chainId}/approve/transaction`, {
                    params: {
                        tokenAddress,
                        parsedAmount /* if not mentioned, approves infinite amount */,
                    },
                });
                return { success: true, txnObject: approveTxnObject };
            }
            catch (error) {
                // throw new Error(`Error approving tokens on 1inch ${tokenAddress}: `);
                // throw new Error(error);
                return { success: false, message: 'Error creating approve txn object' };
            }
        });
    }
    approveOnOkx({ tokenAddress, parsedAmount, fromAddress }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                /* or get spenderAddress, i.e., 1inch router contract address
                  and call approve function
                */
                const { data } = yield axios.get(`${this.okxDexApiUrl}/approve-transaction`, {
                    params: {
                        chainId: this.chainId,
                        tokenContractAddress: tokenAddress,
                        approveAmount: parsedAmount /* if not mentioned, approves infinite amount */,
                    },
                });
                const txnRes = data.data[0];
                const txnObject = {
                    data: txnRes.data,
                    from: fromAddress,
                    to: tokenAddress,
                    gasLimit: ethers.utils.hexlify(parseInt(txnRes.gasLimit)),
                    gasPrice: ethers.utils.hexlify(parseInt(txnRes.gasPrice)),
                    value: 0,
                };
                return { success: true, txnObject };
            }
            catch (error) {
                // throw new Error(`Error approving tokens on 1inch ${tokenAddress}: `);
                // throw new Error(error);
                return { success: false, message: 'Error making approve txn object on OKX' };
            }
        });
    }
    /**
     *
     * Checks allowance for the 1inch router contract address
     *
     * @param accountAddress - account holding tokens
     * @param tokenAddress - token to check allowance
     * @param amount - amount to be spent, e.g. 0.1 ETH
     *
     * @returns bool if allowance needed or not
     */
    checkTokenAllowance({ accountAddress, tokenAddress, amount, spender, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!tokenAddress)
                return true;
            const { contract } = yield this.getContract(tokenAddress);
            const amountToSpend = ethers.utils.parseUnits(amount.toString(), yield contract.decimals());
            // let allowance;
            console.log('checkTokenAllowance', { accountAddress, tokenAddress, amount, spender });
            // if (this.chainId == 66) {
            //   // OKX
            //   allowance = await this.getAllowanceOnOkx({ accountAddress, tokenAddress });
            //   allowance = ethers.BigNumber.from(allowance);
            // } else {
            //   // allowance = await this.getAllowanceOn1inch({ accountAddress, tokenAddress });
            //   // const spender = await this.get1inchRouterContractAddress();
            //   allowance = await contract.allowance(accountAddress, spender);
            // }
            const allowance = yield contract.allowance(accountAddress, spender);
            console.log({
                allowanceNum: allowance.toString(),
                amountToSpendString: amountToSpend.toString(),
            });
            return allowance >= amountToSpend;
        });
    }
    // async getAllowanceOn1inch({ accountAddress, tokenAddress }: any) {
    //   try {
    //     const {
    //       data: { allowance },
    //     } = await axios.get(`${this.oneinchApiBaseUrl}/${this.chainId}/approve/allowance`, {
    //       headers: {
    //         Accept: 'application/json',
    //         Authorization: `Bearer ${this.oneinchApiKey}`,
    //       },
    //       params: {
    //         tokenAddress: tokenAddress,
    //         walletAddress: accountAddress,
    //       },
    //     });
    //     console.log(allowance);
    //     return allowance;
    //   } catch (err) {
    //     throw err;
    //   }
    // }
    getAllowanceOnOkx({ accountAddress, tokenAddress }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield axios.get(`${this.okxDexApiUrl}/get-allowance`, {
                    params: {
                        chainId: this.chainId,
                        userWalletAddress: accountAddress,
                        tokenContractAddress: tokenAddress,
                    },
                });
                const allowance = data.data[0].allowanceAmount; // string "0"
                return allowance;
            }
            catch (err) {
                throw err;
            }
        });
    }
    /**
     * Broadcasts the txn on-chain.
     *
     * @param signer
     * @param txnObject - Txn object data to broadcast
     * @returns
     */
    broadcastTransaction(signer, txnObject) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const txn = yield signer.sendTransaction(txnObject);
                // await txn.wait();
                return {
                    success: true,
                    data: {
                        txnId: txn.hash,
                        // @ts-ignore
                        viewInExplorer: `${txnBaseUrl[this.chainName]}/${txn.hash}`,
                        wait: txn.wait,
                    },
                };
            }
            catch (error) {
                // throw error;
                return {
                    success: false,
                    message: 'Error signing transaction.',
                };
            }
        });
    }
    /**
     * Helper function for creating contract instance
     *
     * Returns the contract instance
     *
     * TODO - add error handling for invalid erc20 contract addresss
     *
     * @param contractAddress - An account address.
     * @param abi - A asset contract address
     * @returns The contract instance.
     */
    getContract(contractAddress, signer, abi) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const contractAbi = abi || erc20Abi;
                const contract = new ethers.Contract(contractAddress, contractAbi, signer ? signer : this.getProvider());
                return {
                    contract,
                };
            }
            catch (err) {
                throw new Error('Error making contract instance');
            }
        });
    }
    callContract(contractDetails, signer) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const fromAddress = yield signer.getAddress();
                const res = yield this.createCallContractTxnObject(contractDetails, fromAddress);
                if (res.success && (res === null || res === void 0 ? void 0 : res.txnObject)) {
                    const txnRes = yield this.broadcastTransaction(signer, res === null || res === void 0 ? void 0 : res.txnObject);
                    return txnRes;
                }
                else
                    return res;
            }
            catch (error) {
                console.error('Error interacting with the contract:', error);
                throw error;
            }
        });
    }
    getCallContractFee(contractDetails, fromAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.createCallContractTxnObject(contractDetails, fromAddress);
            if (res.success) {
                const fee = yield this.getEstimateFee(res.txnObject);
                return fee;
            }
            else {
                return res;
            }
        });
    }
    createCallContractTxnObject(contractDetails, fromAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { contractAddress, abi, functionName, args, value } = contractDetails;
                const { contract } = yield this.getContract(contractAddress, undefined, abi);
                const { gasPrice, nonce } = yield this.getGasDetailsAndNonce(fromAddress);
                // Invoke the contract function
                const txnObject = yield contract.populateTransaction[functionName](...args, {
                    value: value ? ethers.utils.parseEther(value.toString()) : 0,
                    gasPrice,
                    nonce,
                });
                // Handle the result
                console.log('createCallContractTxnObject', txnObject);
                return { success: true, txnObject: Object.assign(Object.assign({}, txnObject), { from: fromAddress }) };
            }
            catch (error) {
                console.error(error);
                return { success: false, message: 'Error creating contract calling txn object' };
            }
        });
    }
    readContract(contractDetails) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { contractAddress, abi, functionName, args } = contractDetails;
                const { contract } = yield this.getContract(contractAddress, undefined, abi);
                // Invoke the contract function
                const data = yield contract[functionName](...args);
                // Handle the result
                console.log('readContract', data);
                return { success: true, data };
            }
            catch (error) {
                console.error(error);
                return { success: false, message: 'Error reading contract', error };
            }
        });
    }
    /**
     * Helper function for creating signer and getting nonce and gas
     *
     * @param privateKey - A private key.
     * @returns The signer, nonce, gas, gasPrice.
     */
    getSigner(privateKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = privateKey
                ? new ethers.Wallet(privateKey, this.getProvider())
                : (yield getEthersSigner({ chainId: this.chainId }));
            // const { nonce, gasPrice, gasLimit } = await this.getGasDetailsAndNonce(
            //   await signer.getAddress()
            // );
            return {
                signer,
                // nonce,
                // gasPrice,
                // gasLimit,
            };
        });
    }
    getGasDetailsAndNonce(fromAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const gasPrice = (yield this.getProvider().getFeeData()).gasPrice; // await getProvider().getGasPrice();
            const gasLimit = 21000;
            const nonce = yield this.getProvider().getTransactionCount(fromAddress);
            return {
                nonce,
                gasPrice,
                gasLimit,
            };
        });
    }
    signMessage(signer, message) {
        return __awaiter(this, void 0, void 0, function* () {
            const signature = yield signer.signMessage(message);
            return signature;
        });
    }
    getTxnDetails(txnHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const txn = yield this.getProvider().getTransactionReceipt(txnHash);
            return txn; // status -> 0,1
        });
    }
    isContractAddress(address) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const checkSumAddress = ethers.utils.getAddress(address);
                const code = yield this.getProvider().getCode(checkSumAddress);
                if (code !== '0x')
                    return true;
                else
                    return false;
            }
            catch (error) {
                // throw error;
                return false;
            }
        });
    }
    isERC20Address(address) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const checkSumAddress = ethers.utils.getAddress(address);
                const { contract } = yield this.getContract(checkSumAddress);
                yield contract.balanceOf(checkSumAddress);
                yield contract.decimals();
                yield contract.totalSupply();
                return true;
            }
            catch (error) {
                console.log('Not erc20 contract');
                return false;
            }
        });
    }
    is1inchRouterContract(address) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const routerAddress = yield this.get1inchRouterContractAddress();
                if (address.toLowerCase() === routerAddress.toLowerCase())
                    return true;
                else
                    return false;
            }
            catch (error) {
                return false;
            }
        });
    }
    get1inchRouterContractAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data: { address: routerAddress }, } = yield axios.get(`${this.triaApiBaseUrl}/chain/${this.chainId}/approve/spender`);
                return routerAddress;
            }
            catch (err) {
                throw new Error('Unable to fetch 1inch router contract address');
            }
        });
    }
    getSendNFTFee(fromAddress, recipientAddress, nftDetails) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.getSendNFTTxnObject(fromAddress, recipientAddress, nftDetails);
            if (res.success) {
                const fee = yield this.getEstimateFee(res === null || res === void 0 ? void 0 : res.txnObject);
                return fee;
            }
            else
                return res;
        });
    }
    sendNFT(signer, fromAddress, recipientAddress, nftDetails) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.getSendNFTTxnObject(fromAddress, recipientAddress, nftDetails);
            if (res.success) {
                const txnRes = yield this.broadcastTransaction(signer, res === null || res === void 0 ? void 0 : res.txnObject);
                return txnRes;
            }
            else
                return res;
        });
    }
    getSendNFTTxnObject(fromAddress, recipientAddress, { type, tokenAddress, tokenId, amount }) {
        return __awaiter(this, void 0, void 0, function* () {
            let txnObject;
            const { gasPrice, nonce } = yield this.getGasDetailsAndNonce(fromAddress);
            try {
                if (type == 'ERC1155') {
                    const { contract } = yield this.getContract(tokenAddress, undefined, erc1155ABI);
                    txnObject = yield contract.populateTransaction.safeTransferFrom(fromAddress, recipientAddress, tokenId, amount, '0x', {
                        gasPrice,
                        nonce,
                    });
                }
                else if (type == 'ERC721') {
                    const { contract } = yield this.getContract(tokenAddress, undefined, erc721ABI);
                    txnObject = yield contract.populateTransaction.safeTransferFrom(fromAddress, recipientAddress, tokenId, {
                        gasPrice,
                        nonce,
                    });
                }
                else {
                    return { success: false, message: 'NFT type not mentioned' };
                }
                txnObject = Object.assign(Object.assign({}, txnObject), { from: fromAddress });
                return {
                    success: true,
                    txnObject,
                };
            }
            catch (err) {
                return {
                    success: false,
                    message: 'Error creating NFT send txn Object',
                };
            }
        });
    }
    /**
     * Bali beta specific.
     * To redeem food coupons.
     *
     */
    burnNFT(signer, { type, tokenAddress, tokenId, amount }) {
        return __awaiter(this, void 0, void 0, function* () {
            const fromAddress = yield signer.getAddress();
            let txnObject;
            if (type == 'ERC1155') {
                try {
                    const { contract } = yield this.getContract(tokenAddress, undefined, CouponsABI);
                    const { gasPrice, nonce } = yield this.getGasDetailsAndNonce(fromAddress);
                    txnObject = yield contract.populateTransaction.burn(tokenId, amount, { gasPrice, nonce });
                }
                catch (err) {
                    return { success: false, message: 'BURN not supported', error: err };
                }
            }
            //  else if (type == 'ERC721') {
            //   const { contract } = await this.getContract(tokenAddress, undefined, erc721ABI);
            //   txnObject = await contract.populateTransaction.burn(tokenId);
            // }
            else
                return { success: false, message: 'NFT type not supported.' };
            const txnRes = yield this.broadcastTransaction(signer, txnObject);
            return txnRes;
        });
    }
}
