var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
//@ts-ignore
import { Biconomy } from '@biconomy/mexa';
// import "dotenv/config";
import * as ethers from 'ethers';
import ABI from '../../interfaces/abis/dsc.json';
// import { contractAddress, ownerAddress, ownerPrivateKey } from "./constants";
import * as sigUtil from '@metamask/eth-sig-util';
import { DSC_ADDRESS, POLYGON_TESTNET_RPC_URL, BICONOMY_API_KEY } from '../constants';
export const relayer = (userPrivateKey, // for client side signature
userAddress, hash, link) => __awaiter(void 0, void 0, void 0, function* () {
    console.log({ userPrivateKey, userAddress, hash, link });
    try {
        const jsonRPCProvider = new ethers.providers.JsonRpcProvider(POLYGON_TESTNET_RPC_URL);
        const userSigner = new ethers.Wallet(userPrivateKey, jsonRPCProvider);
        const biconomy = new Biconomy(jsonRPCProvider, {
            apiKey: BICONOMY_API_KEY,
            debug: true,
            contractAddresses: [DSC_ADDRESS],
        });
        console.log('Waiting for biconomy relayer txn..');
        yield new Promise((resolve) => biconomy.onEvent(biconomy.READY, resolve));
        const contractInterface = new ethers.utils.Interface(ABI);
        const functionSignature = contractInterface.encodeFunctionData('store', [hash, link]);
        const rawTx = {
            to: DSC_ADDRESS,
            data: functionSignature,
            from: userAddress,
        };
        const signedTx = yield userSigner.signTransaction(rawTx);
        const forwardData = yield biconomy.getForwardRequestAndMessageToSign(signedTx);
        const userSignature = sigUtil.signTypedData({
            privateKey: Buffer.from(userPrivateKey, 'hex'),
            data: forwardData.eip712Format,
            version: sigUtil.SignTypedDataVersion.V3,
        });
        console.log({ userSignature });
        const data = {
            signature: userSignature,
            forwardRequest: forwardData.request,
            rawTransaction: signedTx,
            signatureType: biconomy.EIP712_SIGN,
        };
        console.log({ data });
        const provider = biconomy.getEthersProvider();
        const txHash = yield provider.send('eth_sendRawTransaction', [data]);
        console.log({ txHash });
        // console.log('txn.waitingng....');
        // await provider.waitForTransaction(txHash);
        console.log('Txn initiated for hash link storage!!');
        //do something
    }
    catch (error) {
        // console.log(error);
        throw error;
    }
});
