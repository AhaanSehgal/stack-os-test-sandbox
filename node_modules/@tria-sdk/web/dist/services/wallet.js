var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import BackendService from './index';
import { errorHandler } from '../utils/helper';
class WalletService extends BackendService {
    constructor(apiUrl) {
        super(apiUrl);
    }
    add(password, pin, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield this.triaAxios.post('/wallet/add', {
                    password: password,
                    chainName: chainName,
                    pin: pin,
                }, {});
                return data;
            }
            catch (err) {
                return errorHandler(err);
            }
        });
    }
    updateSubName({ newSubName, oldSubName, password, pin }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield this.triaAxios.post('/wallet/update-subname', {
                    newSubName,
                    oldSubName,
                    password,
                    pin,
                });
                return data;
            }
            catch (err) {
                return errorHandler(err);
            }
        });
    }
    removeSubname({ subname, password, pin }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield this.triaAxios.post('/wallet/remove-address', {
                    subname,
                    password,
                    pin,
                });
                return data;
            }
            catch (err) {
                return errorHandler(err);
            }
        });
    }
    resolveTriaName({ chainName, lookUpTriaName }, environment) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield this.triaAxios.post('/wallet/resolveTriaName', {
                    chainName,
                    lookUpTriaName,
                });
                return data;
            }
            catch (err) {
                throw Error('Unable to resolve DID.');
            }
        });
    }
    // async resolveTriaNameSG(
    //   { chainName, lookUpTriaName }: ResolveTriaName,
    //   environment?: ENV
    // ): Promise<{ address: string }> {
    //   try {
    //     const did = lookUpTriaName;
    //     var data = JSON.stringify({
    //       query: `query MyQuery($id: ID!, $didName: String!, $chainNameVar: String!) {
    //         didToEvmAddress(id: $id) {
    //           did
    //           evmAddress
    //         }
    //         didToNonEvmAddresses(where: {did: $didName, chain_: {chainName: $chainNameVar}}) {
    //           did
    //           nonEvmAddress
    //           chain {
    //             id
    //             chainName
    //           }
    //         }
    //       }`,
    //       variables: { id: did, didName: did, chainNameVar: chainName },
    //     });
    //     var config = {
    //       method: 'post',
    //       url: getSubgraphUrl(environment),
    //       headers: {
    //         'Content-Type': 'application/json',
    //       },
    //       data: data,
    //     };
    //     const { data: didData } = await axios(config);
    //     console.log({ didData });
    //     const evmAddress = didData?.data?.didToEvmAddress?.evmAddress;
    //     if (!evmAddress) throw Error('DID does not exist!');
    //     // if chainName is not in EVM
    //     // return didData.data.didToNonEvmAddresses[0].nonEvmAddress;
    //     return { address: evmAddress };
    //   } catch (err) {
    //     throw Error('Unable to resolve DID.');
    //   }
    // }
    addNonEvmShards({ accountKeys }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield this.triaAxios.post('/wallet/add-nonEVMShards', {
                    shardedAccountKeys: accountKeys,
                });
                return data;
            }
            catch (err) {
                return errorHandler(err);
            }
        });
    }
}
export default WalletService;
