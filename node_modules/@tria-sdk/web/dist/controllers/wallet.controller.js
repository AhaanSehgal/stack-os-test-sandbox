var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { isChainSupported } from '@tria-sdk/core';
import { checksumAddress } from '../utils/helper/checksum';
import { isValidAddress } from '../utils/helper/isValidAddress';
import { KeyringController } from './keyring.controller';
// 1. Extending Keyring only for memStore for tempVault in embedded wallet case, and getSigner function
export class WalletController extends KeyringController {
    constructor({ baseUrl, walletType, selectedChainName, environment = 'mainnet' }) {
        super({ baseUrl, walletType, selectedChainName, environment });
        if (isChainSupported(selectedChainName))
            this.selectedChainName = selectedChainName;
    }
    signMessage(message, chainName) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { signer, chainInstance, triaName } = yield this.getSigner((this.selectedChainName || chainName));
                console.log({ signer });
                // @ts-ignore
                const res = yield chainInstance.signMessage(signer, message);
                if ((_a = this.walletType) === null || _a === void 0 ? void 0 : _a.embedded) {
                    this.postMessage({
                        type: 'Sign Message',
                        success: true,
                        data: { triaName, message, signature: res },
                    });
                }
                return res;
            }
            catch (err) {
                console.error(err);
                if ((_b = this.walletType) === null || _b === void 0 ? void 0 : _b.embedded) {
                    this.postMessage({
                        type: 'Sign Message',
                        success: false,
                        data: { message: err.message || 'Error signing message!' },
                    });
                }
            }
        });
    }
    waitForTransaction(txn) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            yield ((_a = txn === null || txn === void 0 ? void 0 : txn.data) === null || _a === void 0 ? void 0 : _a.wait());
            if ((_b = this.walletType) === null || _b === void 0 ? void 0 : _b.embedded) {
                this.postMessage({
                    type: 'Send',
                    success: true,
                    data: { res: txn },
                });
            }
            return txn;
        });
    }
    send(payload, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (payload.amount <= 0)
                return { success: false, message: 'Invalid amount' };
            const chain = (this.selectedChainName || chainName);
            const { signer, chainInstance, triaName, address: fromAddress } = yield this.getSigner(chain);
            console.log({ payload });
            if (isChainSupported(chain)) {
                const { recipientTriaName } = payload;
                let recipientAddress;
                if (!recipientTriaName.includes('@tria') && isValidAddress(recipientTriaName))
                    recipientAddress = checksumAddress(payload.recipientTriaName);
                else
                    recipientAddress = yield this.resolveTriaName(payload.recipientTriaName, chain);
                const sendPayload = {
                    signer,
                    recipientAddress,
                    fromAddress,
                    amount: payload.amount,
                    tokenAddress: payload.tokenAddress,
                };
                const res = yield chainInstance.send(sendPayload);
                if (res.success)
                    this.userService.addUserActivity((triaName || payload.fromTriaName), recipientTriaName);
                return res;
            }
            else {
                return { success: false, message: 'Chain not supported.' };
            }
        });
    }
    approve(payload, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            const { amount, tokenAddress, spender } = payload;
            if (amount <= 0)
                return { success: false, message: 'Invalid amount' };
            const chain = (this.selectedChainName || chainName);
            const { signer, chainInstance, address: fromAddress } = yield this.getSigner(chain);
            //@ts-ignore
            const res = yield (chainInstance === null || chainInstance === void 0 ? void 0 : chainInstance.approve({
                signer,
                fromAddress,
                tokenAddress,
                amount,
                spender,
            }));
            return res;
        });
    }
    swap(payload, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (payload.fromAmount <= 0)
                return { success: false, message: 'Invalid amount' };
            const chain = (this.selectedChainName || chainName);
            const { signer, chainInstance, address: fromAddress } = yield this.getSigner(chain);
            const swapPayload = {
                signer,
                fromAddress,
                fromTokenAddress: payload.fromTokenAddress,
                toTokenAddress: payload.toTokenAddress,
                amount: payload.fromAmount,
                slippage: payload.slippage || 1, // default 1%
            };
            // @ts-ignore
            const res = yield (chainInstance === null || chainInstance === void 0 ? void 0 : chainInstance.swap(swapPayload));
            return res;
            /** API call /swap (chainName, swapPayload) */
            // const tx = this.nonEVMService.swap("SHARD1", "CHAINAME", "PAYLOAD");
        });
    }
    sendNFT(recipientTriaName, nftDetails, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (nftDetails.amount <= 0)
                return { success: false, message: 'Invalid amount' };
            const chain = (this.selectedChainName || chainName);
            const { signer, chainInstance, address: fromAddress } = yield this.getSigner(chain);
            if (isChainSupported(chain)) {
                let recipientAddress;
                if (!recipientTriaName.includes('@tria') && isValidAddress(recipientTriaName))
                    recipientAddress = checksumAddress(recipientTriaName);
                else
                    recipientAddress = yield this.resolveTriaName(recipientTriaName, chain);
                // @ts-ignore
                const res = yield (chainInstance === null || chainInstance === void 0 ? void 0 : chainInstance.sendNFT(signer, fromAddress, recipientAddress, nftDetails));
                return res;
            }
            else {
                return { success: false, message: 'Chain not supported.' };
            }
        });
    }
    /**
     * Bali beta specific
     *
     */
    burnNFT(nftDetails, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (nftDetails.amount <= 0)
                return { success: false, message: 'Invalid amount' };
            const chain = (this.selectedChainName || chainName);
            const { signer, chainInstance } = yield this.getSigner(chain);
            if (isChainSupported(chain)) {
                // @ts-ignore
                const res = yield (chainInstance === null || chainInstance === void 0 ? void 0 : chainInstance.burnNFT(signer, nftDetails));
                return res;
            }
            else {
                return { success: false, message: 'Chain not supported.' };
            }
        });
    }
    /**
     * Interact with any external contract
     * @param contractDetails
     * @param chainName
     * @returns
     */
    callContract(contractDetails, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            const chain = (this.selectedChainName || chainName);
            const { signer, chainInstance } = yield this.getSigner(chain);
            if (isChainSupported(chain)) {
                // @ts-ignore
                const res = yield (chainInstance === null || chainInstance === void 0 ? void 0 : chainInstance.callContract(contractDetails, signer));
                return res;
            }
            else {
                return { success: false, message: 'Chain not supported.' };
            }
        });
    }
    readContract(contractDetails, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            const chain = (this.selectedChainName || chainName);
            const chainInstance = this.chains[chain];
            if (isChainSupported(chain)) {
                // @ts-ignore
                const res = yield (chainInstance === null || chainInstance === void 0 ? void 0 : chainInstance.readContract(contractDetails));
                return res;
            }
            else {
                return { success: false, message: 'Chain not supported.' };
            }
        });
    }
}
