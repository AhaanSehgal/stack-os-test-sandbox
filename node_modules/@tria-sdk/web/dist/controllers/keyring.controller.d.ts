import { PersistStorage } from '../storage/storage';
import WalletService from '../services/wallet';
import UserService from '../services/user';
import { RemoveAddressArgs, TriaArgs, UpdateSubNameArgs, ReconstructResponse, AddWalletResponse, ExportMnemonicResponse, ExportPrivateKeyResponse, UpdatedWalletAddresses, SocialLoginResponse, Vault, EvmChainData, OAuthDataArgs, InitParams, ENV } from '../types';
import ObservableStore from 'obs-store';
import NONEVMService from '../services/nonevm';
import { Multichain } from '../utils/helper/multichain';
import DIDService from '../services/did';
import { AuthController } from '@tria-sdk/core';
export declare class KeyringController extends Multichain {
    #private;
    apiUrl: string;
    memStore: ObservableStore<Object>;
    store: PersistStorage;
    nonEVMService: NONEVMService;
    walletService: WalletService;
    userService: UserService;
    didService: DIDService;
    authController: AuthController;
    environment: ENV;
    /**
     * Constructs a new instance of the Tria class.
     * @param apiUrl - The URL of the API.
     */
    constructor({ baseUrl, walletType, sentryDns, environment }: TriaArgs);
    init(): Promise<void>;
    fullUpdate(password: string, pin: string): Promise<any>;
    getLocalKeys({ loginType, triaName, socialName, userId, input }: InitParams): {
        shard2LocalKey: string;
        hashLocalKey: string;
    };
    generateNewPassword(): string;
    /**
     * @version 2
     * @description use to generate the vault so that it can be call sepreately for DID creation
     */
    generateVault(triaName: string, importedMnemonic?: string): Promise<{
        vault: Vault;
        publicVault: any;
    }>;
    getSigner(chainName: string, privateKey?: string): Promise<{
        signer: any;
        chainInstance: import("../interfaces/chain").Chain;
        triaName: string | null | undefined;
        address: any;
    }>;
    /**
     * @version 2
     * @description use to generate the evmChainData for did
     */
    generateEVMChainData(vault: Vault): Promise<EvmChainData>;
    /**
     * @version 2
     * @description native wallet creation using triaName and password
     * @todo Push shard to contract using relayer
     */
    createAccount({ triaName, password, mnemonic, origin, }: {
        triaName: string;
        password: string;
        mnemonic?: string;
        origin?: string;
    }): Promise<{
        success: boolean;
        data: any;
    }>;
    /**
     * @version 2
     * @description For wallet creation using socails
     * @todo verify user already exist ONCHAIN
     * @todo Push shard to contract using relayer
     */
    socialogin({ triaName, password, platform, userId, isPasswordLess, accessToken, origin, }: {
        triaName: string;
        password: string;
        platform: string;
        userId: string;
        accessToken: string;
        isPasswordLess: boolean;
        origin?: string;
    }): Promise<SocialLoginResponse>;
    /**
     * @description Get the account
     * @param triaName triaName for native users
     * @param password password required for encrypt/decrypt in native case user will enter password and in all other case tria managing
     * @param userId In social login
     * @param socialName platform name twitter, google ...
     * @param input email or phone number in case of OTP login otherwise provide null
     * @param hash hash from the server in case of OTP login
     */
    getVault({ triaName, password, userId, socialName, input, hash, link, native, origin, accessToken, }: {
        triaName?: string;
        password: string;
        userId?: string;
        socialName?: string | null;
        input?: string | null;
        hash?: string | null;
        link?: boolean;
        native?: boolean;
        origin?: string;
        accessToken?: string;
    }): Promise<{
        exists: boolean;
        data: Vault | null;
    }>;
    /**
     * @version 2
     */
    getOTP(input: string): Promise<String>;
    /**
     * @version 2
     */
    verifyOTP({ otp, session, input }: {
        otp: string;
        session: string;
        input: string;
    }): Promise<{
        hash: any;
        password: any;
    }>;
    /**
     * @version 2
     */
    initiateEmailLinkAuth({ email, password, origin, }: {
        email: string;
        password: string;
        origin?: string;
    }): Promise<String>;
    /**
     * @version 2
     */
    emailLinkVerification({ code, email }: {
        code: string;
        email: string;
    }): Promise<{
        verify: any;
    } | undefined>;
    /**
     * @version 2
     * @param hash We get from backend
     * @param input user email or phone number
     * @param password to encrypt the data will get from backend
     * @param triaName users triaName
     * @param type ["LINK", "OTP"]
     *
     */
    generateAccountByOTPOrLINK({ hash, input, password, triaName, type, origin, }: {
        triaName: string;
        input: string;
        hash: string;
        password: string;
        type: string;
        origin?: string;
    }): Promise<{
        success: boolean;
    }>;
    /**
     * @description shard the vault and call the ShardStorage api
     */
    shardAndPushTheVault({ vault, dsc_hash, password, shard1LocalKey, shard2LocalKey, oauthData, hashLocalKey, }: {
        vault: Vault;
        dsc_hash: string;
        password: string;
        shard1LocalKey: string;
        shard2LocalKey: string;
        hashLocalKey: string;
        oauthData?: OAuthDataArgs;
    }): Promise<{
        success: boolean;
        error?: undefined;
    } | {
        success: boolean;
        error: unknown;
    }>;
    /**
     * @description delete shard
     */
    deleteShardAfterSaved({ hash, localStorageKeyForHash, localStorageKeyForShard2, }: {
        hash: string;
        localStorageKeyForHash: string;
        localStorageKeyForShard2: string;
    }): Promise<void>;
    /**
     * @version 2
     * @returns Boolean
     */
    isShardPresent(hash: string): Promise<boolean>;
    getUserSession(): Promise<any>;
    /**
     *
     */
    generateUserSession({ vault, accessToken }: {
        vault: Vault;
        accessToken?: string;
    }): Promise<void>;
    detectLoggedInAccount(): Promise<void>;
    /**
     * Asynchronously reconstructs User Vault.
     * @param tID - The ID of the User.
     * @param triaName - The Tria name of the User.
     * @param password - The password for authentication.
     * @returns A Promise that resolves to the reconstructed Decrypted Vault.
     */
    reconstruct(password: string, pin: string): Promise<ReconstructResponse>;
    /**
     *
     * @param username users tria name
     * @param password users password
     * @param pin user pin
     * @param chainName chain name for which user want to add wallet
     */
    addWallet(password: string, pin: string, chainName: string): Promise<UpdatedWalletAddresses>;
    updateSubName({ newSubName, oldSubName, password, pin, }: UpdateSubNameArgs): Promise<AddWalletResponse>;
    removeAddress({ subname, password, pin }: RemoveAddressArgs): Promise<AddWalletResponse>;
    /**
     * Private method use to get users key from memory
     * @param triaName Trianame
     * @param chainName Chain name for which users password needed
     * @returns keypair
     */
    /**
     * @todo Password & pin verification
     * @param password Password
     * @param pin Pin
     */
    exportMemonic(password: string, pin: string): Promise<ExportMnemonicResponse>;
    /**
     * @todo Password & pin verification
     * @param triaName triaName
     * @param password Password
     * @param pin Pin
     * @param chainName chainName
     */
    exportPrivateKey(triaName: string, password: string, pin: string, chainName: string): Promise<ExportPrivateKeyResponse>;
    /**
     *@description this function is for inMemory data persist
     */
    persistMemoryData(): Promise<void>;
    logout(): Promise<{
        success: boolean;
    }>;
    cleanOnLogout(): Promise<{
        success: boolean;
    }>;
    /**
     * @param triaName triaName
     * @param chainName chainName
     */
    resolveTriaName(triaName: string, chainName: string): Promise<string>;
    /**
     * For message passing between windows and iframes
     * @param windowTo
     * @param message
     */
    postMessage(message: Object, sameOrigin?: boolean): void;
    storeInTriaStore(publicVault: Object): void;
    storeConnectedAppInSession(dappUrl?: string): void;
}
