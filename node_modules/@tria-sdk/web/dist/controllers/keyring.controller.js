var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _KeyringController_instances, _KeyringController_resolveTriaName;
import { PersistStorage } from '../storage/storage';
import WalletService from '../services/wallet';
import UserService from '../services/user';
import generatePassword from 'generate-password';
//@ts-ignore
import ObservableStore from 'obs-store';
import { generateShadowHash, decryptAES, encryptAES256, shamir, generateSHA256, combine, } from '../utils/crypto';
import { reconstruct, shardNonEvmVaultKeys } from '../utils/vault';
import { VAULT, NON_EVM_LIST, NON_EVM_VAULT, KEY_STORE, TEMP_MEM_STORE, getConfigForShardStorage, } from '../utils/constants';
import NONEVMService from '../services/nonevm';
import { filterNonEVM } from '../utils/helper';
//@ts-ignore
import crypto from '../core-lib/crypto';
import { Multichain } from '../utils/helper/multichain';
//@ts-ignore
import { Buffer } from '../core-lib/buffer';
import * as bip39 from 'bip39';
import dscAbi from '../interfaces/abis/dsc.json';
import { ethers } from 'ethers';
//@ts-ignore
import * as secrets from 'sss-tria';
import { fetchContent, pinToIpfs } from '../utils/ipfs';
import DIDService from '../services/did';
import { AuthController, isEvmChain } from '@tria-sdk/core';
import * as Sentry from '@sentry/browser';
// 1. Extending Multichain only for getSigner for evmChainData for did creation
export class KeyringController extends Multichain {
    /**
     * Constructs a new instance of the Tria class.
     * @param apiUrl - The URL of the API.
     */
    constructor({ baseUrl, walletType, sentryDns, environment }) {
        super(baseUrl, walletType);
        _KeyringController_instances.add(this);
        this.apiUrl = baseUrl;
        this.store = new PersistStorage();
        this.nonEVMService = new NONEVMService(this.apiUrl);
        this.walletService = new WalletService(this.apiUrl);
        this.userService = new UserService(this.apiUrl);
        this.didService = new DIDService(this.apiUrl);
        this.authController = new AuthController(this.apiUrl);
        this.environment = environment || 'mainnet';
        if (sentryDns) {
            console.log('sentryDns', sentryDns);
            Sentry.init({
                dsn: sentryDns,
                release: 'tria-sdk/web',
                integrations: [new Sentry.BrowserTracing(), new Sentry.Replay()],
                tracesSampleRate: 1.0,
                tracePropagationTargets: ['localhost', /^https:\/\/yourserver\.io\/api/],
                replaysSessionSampleRate: 0.1,
                replaysOnErrorSampleRate: 1.0,
            });
        }
        // const oldMemData = this.store.getValue(TEMP_MEM_STORE);
        // this.store.removeValue(TEMP_MEM_STORE);
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const init = this.store.getValue('init');
            const { loginType, triaName, socialName, userId, input } = init;
            const tempVault = this.store.getValue('tempVault');
            const accessToken = this.store.getValue('accessToken');
            console.log('tempVault', tempVault);
            if (tempVault) {
                const data = yield this.authController.getKey(accessToken);
                try {
                    const cipherText = tempVault.split(':')[1];
                    const iv = tempVault.split(':')[0];
                    const decryptedVault = yield decryptAES(cipherText, Buffer.from(data.key, 'hex'), Buffer.from(iv, 'hex'));
                    this.memStore = new ObservableStore(decryptedVault);
                    const { hashLocalKey, shard2LocalKey } = this.getLocalKeys({
                        loginType,
                        triaName,
                        socialName,
                        userId,
                        input,
                    });
                    if (this.store.getValue(hashLocalKey)) {
                        this.deleteShardAfterSaved({
                            hash: this.store.getValue(hashLocalKey),
                            localStorageKeyForHash: hashLocalKey,
                            localStorageKeyForShard2: shard2LocalKey,
                        });
                    }
                    console.log('this.memStore', JSON.parse(this.memStore.getState()));
                }
                catch (err) {
                    console.log('err', err);
                    throw err;
                }
            }
            else {
                this.memStore = new ObservableStore({
                    vault: {},
                });
            }
        });
    }
    fullUpdate(password, pin) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.reconstruct(password, pin);
            const addresses = yield this.userService.getAllAddresses();
            return addresses;
        });
    }
    getLocalKeys({ loginType, triaName, socialName, userId, input }) {
        switch (loginType) {
            case 'native':
                if (triaName) {
                    const shard2LocalKey = `${triaName}:native:$2`;
                    const hashLocalKey = `${triaName}:native:hash`;
                    return { shard2LocalKey, hashLocalKey };
                }
                else {
                    throw new Error('TriaName Required for native');
                }
            case 'otp':
                if (input) {
                    const shard2LocalKey = `${input}:otp:$2`;
                    const hashLocalKey = `${input}:otp:hash`;
                    return { shard2LocalKey, hashLocalKey };
                }
                else {
                    throw new Error('Input Required for Otp creation method');
                }
            case 'social':
                if (socialName && userId) {
                    const shard2LocalKey = `${socialName}:${userId}:$2`;
                    const hashLocalKey = `${socialName}:${userId}:hash`;
                    return { shard2LocalKey, hashLocalKey };
                }
                else {
                    throw new Error('socialName && userId Social method');
                }
            default:
                throw new Error(`Invalid Login Type: ${loginType}`);
        }
    }
    generateNewPassword() {
        const newPassword = generatePassword.generate({
            length: 12,
            numbers: true,
            symbols: true,
            uppercase: true,
            excludeSimilarCharacters: true, // Exclude similar characters (e.g., 'i', 'l', '1', 'L', etc.)
        });
        return newPassword;
    }
    /**
     * @version 2
     * @description use to generate the vault so that it can be call sepreately for DID creation
     */
    generateVault(triaName, importedMnemonic) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                console.log(triaName, importedMnemonic);
                console.log('generating mnemonic');
                const mnemonic = importedMnemonic || bip39.generateMnemonic();
                console.log('mnemonic');
                // const mnemonic = 'design large bone swallow frost wisdom evoke bike lunch okay report tomato';
                const wallet = ethers.Wallet.fromMnemonic(mnemonic, `m/44'/60'/0'/0/0`);
                const publicVault = { triaName, evm: { address: wallet.address } };
                const vault = {
                    triaName: triaName,
                    mnemonic: mnemonic,
                    evm: {
                        address: wallet.address,
                        privateKey: wallet.privateKey,
                    },
                };
                return { vault, publicVault };
            }
            catch (err) {
                console.log(err);
                //@ts-ignore
                Sentry.captureException(new Error(err.message), {
                    tags: { key: 'generateVault' },
                });
                throw err;
            }
        });
    }
    getSigner(chainName, privateKey) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const chainInstance = this.chains[chainName];
            let signer, triaName, address;
            if (((_a = this.walletType) === null || _a === void 0 ? void 0 : _a.embedded) || !this.walletType) {
                console.log('embedded walet with password');
                if (!privateKey) {
                    ({ privateKey, triaName, address } = yield __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_resolveTriaName).call(this, chainName));
                    console.log({ privateKey });
                }
                // @ts-ignore
                ({ signer } = yield chainInstance.getSigner(privateKey));
            }
            else {
                // @ts-ignore
                ({ signer } = yield chainInstance.getSigner());
                address = yield signer.getAddress();
                triaName = null;
            }
            return { signer, chainInstance, triaName, address };
        });
    }
    /**
     * @version 2
     * @description use to generate the evmChainData for did
     */
    generateEVMChainData(vault) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const evmAddress = ethers.utils.getAddress(vault.evm.address);
            const evmMessage = {
                address: evmAddress,
                timestamp: new Date().getTime(),
            };
            const chainName = this.environment == 'testnet' ? 'MUMBAI' : 'POLYGON';
            const { signer, chainInstance } = yield this.getSigner(chainName, (_a = vault === null || vault === void 0 ? void 0 : vault.evm) === null || _a === void 0 ? void 0 : _a.privateKey);
            // @ts-ignore
            const signature = yield chainInstance.signMessage(signer, JSON.stringify(evmMessage));
            return {
                address: evmAddress,
                message: evmMessage,
                signature,
            };
        });
    }
    /**
     * @version 2
     * @description native wallet creation using triaName and password
     * @todo Push shard to contract using relayer
     */
    createAccount({ triaName, password, mnemonic, origin, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!triaName && !password) {
                    throw Error('TriaName and Password Required');
                }
                //checking DID exist or not
                let isAvailable = yield this.didService.checkDID(triaName);
                if (!isAvailable) {
                    throw Error('DID not Available!');
                }
                const { vault, publicVault } = yield this.generateVault(triaName, mnemonic);
                const evmChainData = yield this.generateEVMChainData(vault);
                // DID creation
                const args = {
                    did: triaName,
                    evmChainData: evmChainData,
                    nonEvmChainsData: [],
                };
                let res = (yield this.didService.createDID(args));
                if (!res.success) {
                    throw Error('DID creation failed!');
                }
                const dsc_key = generateSHA256(`${triaName}:${password}`);
                const shard1LocalKey = `${triaName}:native:$1`;
                const shard2LocalKey = `${triaName}:native:$2`;
                const hashLocalKey = `${triaName}:native:hash`;
                const ress = yield this.shardAndPushTheVault({
                    vault: vault,
                    dsc_hash: dsc_key,
                    password: password,
                    shard1LocalKey: shard1LocalKey,
                    shard2LocalKey: shard2LocalKey,
                    hashLocalKey: hashLocalKey,
                });
                // shard management
                // will replace this my secure random number
                if (ress.success) {
                    this.storeInTriaStore(publicVault);
                    this.store.setValue('init', JSON.stringify({ loginType: 'native', triaName, socialName: '', userId: '', input: '' }));
                    this.postMessage({
                        type: 'Tria Sign up',
                        success: true,
                        data: publicVault,
                    });
                    this.storeConnectedAppInSession(origin);
                    yield this.deleteShardAfterSaved({
                        hash: dsc_key,
                        localStorageKeyForShard2: shard2LocalKey,
                        localStorageKeyForHash: hashLocalKey,
                    });
                    // await this.generateUserSession({ vault: vault });
                    return { success: true, data: publicVault };
                }
                else {
                    throw ress.error;
                }
            }
            catch (err) {
                console.error(err);
                //@ts-ignore
                Sentry.captureException(new Error(err.message), {
                    tags: { key: 'createAccount' },
                });
                this.postMessage({
                    type: 'Tria Sign up',
                    success: false,
                    data: { triaName, message: err.message || 'Error signing up, please try again!' },
                });
                throw err;
            }
        });
    }
    /**
     * @version 2
     * @description For wallet creation using socails
     * @todo verify user already exist ONCHAIN
     * @todo Push shard to contract using relayer
     */
    socialogin({ triaName, password, platform, userId, isPasswordLess, accessToken, origin, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                console.log('keyring socialogin', { triaName, password, platform, userId, isPasswordLess });
                let isAvailable = yield this.didService.checkDID(triaName);
                if (!isAvailable) {
                    throw Error('DID not Available!');
                }
                if (isPasswordLess) {
                    password = this.generateNewPassword();
                    console.log('generated password', password);
                }
                const { vault, publicVault } = yield this.generateVault(triaName);
                const evmChainData = yield this.generateEVMChainData(vault);
                // DID creation
                const args = {
                    did: triaName,
                    evmChainData: evmChainData,
                    nonEvmChainsData: [],
                };
                let res = (yield this.didService.createDID(args));
                if (!res.success) {
                    throw Error('DID creation failed!');
                }
                const dsc_key = generateSHA256(`${userId}:${password}`);
                const shard1LocalKey = `${platform}:${userId}:$1`;
                const shard2LocalKey = `${platform}:${userId}:$2`;
                const hashLocalKey = `${platform}:${userId}:hash`;
                // const oauthData: OAuthDataArgs = {
                //   userOauthId: userId,
                //   success: true,
                //   isPasswordRequired: !isPasswordLess,
                //   password: isPasswordLess ? password : '',
                // };
                const ress = yield this.shardAndPushTheVault({
                    vault: vault,
                    dsc_hash: dsc_key,
                    password: password,
                    shard1LocalKey: shard1LocalKey,
                    shard2LocalKey: shard2LocalKey,
                    hashLocalKey: hashLocalKey,
                });
                console.log('userId', userId);
                const triaNameHash = generateSHA256(triaName);
                yield this.authController.saveOauthUser({
                    triaNameHash: triaNameHash,
                    userOauthId: userId,
                    isPasswordRequired: !isPasswordLess,
                    password: isPasswordLess ? password : '',
                    platform: platform,
                    accessToken: accessToken,
                });
                if (ress.success) {
                    this.storeInTriaStore(publicVault);
                    this.store.setValue('init', JSON.stringify({ loginType: 'social', triaName, socialName: platform, userId, input: '' }));
                    this.postMessage({
                        type: 'Social Sign up',
                        success: true,
                        data: publicVault,
                    }, true);
                    this.storeConnectedAppInSession(origin);
                    yield this.generateUserSession({ vault: vault, accessToken: accessToken });
                    return { success: true, data: vault.evm.address };
                }
                else {
                    throw ress.error;
                }
            }
            catch (err) {
                console.error(err);
                //@ts-ignore
                Sentry.captureException(new Error(err.message), {
                    tags: { key: 'socialogin' },
                });
                this.postMessage({
                    type: 'Social Sign up',
                    success: false,
                    data: { triaName, message: err.message || 'Error signing up, please try again!' },
                }, true);
                return { success: false, data: null };
            }
        });
    }
    /**
     * @description Get the account
     * @param triaName triaName for native users
     * @param password password required for encrypt/decrypt in native case user will enter password and in all other case tria managing
     * @param userId In social login
     * @param socialName platform name twitter, google ...
     * @param input email or phone number in case of OTP login otherwise provide null
     * @param hash hash from the server in case of OTP login
     */
    getVault({ triaName, password, userId, socialName, input, hash, link, native, origin, accessToken, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                console.log({
                    triaName,
                    password,
                    userId,
                    socialName,
                    input,
                    hash,
                    link,
                    native,
                    origin,
                });
                //console.log(`${userId || triaName}:${password}`);
                let dsc_key;
                if (userId) {
                    dsc_key = generateSHA256(`${userId}:${password}`);
                }
                else if (triaName && native) {
                    dsc_key = generateSHA256(`${triaName}:${password}`);
                }
                else if (input) {
                    dsc_key = hash;
                }
                let salt;
                console.log('input && link', input && link);
                console.log('input && link', link);
                if (userId)
                    salt = this.store.getValue(`SALT:${socialName}:${userId}:$`);
                else if (triaName && native)
                    salt = this.store.getValue(`SALT:${triaName}:native:$`);
                else if (input && !link)
                    salt = this.store.getValue(`SALT:${input}:otp:$`);
                else if (input && link)
                    salt = this.store.getValue(`SALT:${input}:link:$`);
                console.log('SALT:${input}:link:$', `SALT:${input}:link:$`);
                console.log('salt', salt);
                console.log('derived key', password, salt.toString('hex'), 5000, 32, 'sha512');
                let derivedKey = crypto.pbkdf2Sync(password, salt.toString('hex'), 5000, 32, 'sha512');
                const { DSC_ADDRESS, RPC_URL } = getConfigForShardStorage(this.environment);
                const provider = new ethers.providers.JsonRpcProvider(RPC_URL);
                const contract = new ethers.Contract(DSC_ADDRESS, dscAbi, provider);
                // console.log('dsc_key', dsc_key);
                let ipfsPath = yield contract.hashToLink(dsc_key);
                console.log('ipfsPath', ipfsPath);
                let encRandomNumber;
                if (!ipfsPath) {
                    if (userId) {
                        console.log('`${socialName}:${userId}:$2`', `${socialName}:${userId}:$2`);
                        ipfsPath = this.store.getValue(`${socialName}:${userId}:$2`);
                        encRandomNumber = this.store.getValue(`encyRandomNumber:${socialName}:${userId}:$`);
                    }
                    else if (triaName && native) {
                        console.log('${triaName}:native:$2', `${triaName}:native:$2`);
                        ipfsPath = this.store.getValue(`${triaName}:native:$2`);
                        encRandomNumber = this.store.getValue(`encyRandomNumber:${triaName}:native:$`);
                    }
                    else if (input && !link) {
                        console.log('${input}:otp:$2', `${input}:otp:$2`);
                        ipfsPath = this.store.getValue(`${input}:otp:$2`);
                        encRandomNumber = this.store.getValue(`encyRandomNumber:${input}:otp:$`);
                    }
                    else if (input && link) {
                        console.log('${input}:link:$2', `${input}:link:$2`);
                        ipfsPath = this.store.getValue(`${input}:link:$2`);
                        encRandomNumber = this.store.getValue(`encyRandomNumber:${input}:link:$`);
                    }
                }
                if (userId) {
                    console.log('`${socialName}:${userId}:$2`', `${socialName}:${userId}:$2`);
                    encRandomNumber = this.store.getValue(`encyRandomNumber:${socialName}:${userId}:$`);
                }
                else if (triaName && native) {
                    console.log('${triaName}:native:$2', `${triaName}:native:$2`);
                    encRandomNumber = this.store.getValue(`encyRandomNumber:${triaName}:native:$`);
                }
                else if (input && !link) {
                    console.log('${input}:otp:$2', `${input}:otp:$2`);
                    encRandomNumber = this.store.getValue(`encyRandomNumber:${input}:otp:$`);
                }
                else if (input && link) {
                    console.log('${input}:link:$2', `${input}:link:$2`);
                    encRandomNumber = this.store.getValue(`encyRandomNumber:${input}:link:$`);
                }
                console.log('ipfsPath', ipfsPath);
                if (!ipfsPath) {
                    return { exists: false, data: null };
                }
                let lshard;
                if (userId)
                    lshard = this.store.getValue(`${socialName}:${userId}:$1`).encyShard;
                else if (triaName && native)
                    lshard = this.store.getValue(`${triaName}:native:$1`).encyShard;
                else if (input && !link)
                    lshard = this.store.getValue(`${input}:otp:$1`).encyShard;
                else if (input && link)
                    lshard = this.store.getValue(`${input}:link:$1`).encyShard;
                const ipfsShard = yield fetchContent(ipfsPath);
                console.log('lshard', lshard);
                const encryptedVault = secrets.hex2str(combine([lshard, ipfsShard]));
                console.log('encryptedVault', encryptedVault.toString());
                console.log("encryptedVault.split(':')[1]", encryptedVault.split(':')[1]);
                console.log(Buffer.from(encryptedVault.split(':')[0], 'hex'));
                console.log('derivedKey', derivedKey.toString('hex'));
                console.log('encryptedVault', encryptedVault);
                console.log('encRandomNumber', encRandomNumber);
                let decRandomNumber = yield decryptAES(encRandomNumber.split(':')[1], derivedKey, Buffer.from(encRandomNumber.split(':')[0], 'hex'));
                console.log('decRandomNumber', decRandomNumber);
                decRandomNumber = decRandomNumber.replace(/^"|"$/g, '');
                // console.log('decRandomNumber', decRandomNumber.length);
                console.log('ipfsPath', ipfsPath);
                console.log({ lshard, ipfsShard });
                console.log({ encryptedVault });
                const decryptedData = yield decryptAES(encryptedVault.split(':')[1], Buffer.from(decRandomNumber, 'hex'), Buffer.from(encryptedVault.split(':')[0], 'hex'));
                console.log('decryptedData', decryptedData);
                const vault = JSON.parse(decryptedData);
                console.log('decryptedData', vault);
                const publicVault = { triaName: vault === null || vault === void 0 ? void 0 : vault.triaName, evm: { address: (_a = vault === null || vault === void 0 ? void 0 : vault.evm) === null || _a === void 0 ? void 0 : _a.address } };
                if (userId) {
                    this.store.setValue('init', JSON.stringify({
                        loginType: 'social',
                        triaName,
                        socialName: socialName,
                        userId,
                        input: '',
                    }));
                }
                else if (triaName && native) {
                    this.store.setValue('init', JSON.stringify({ loginType: 'native', triaName, socialName: '', userId: '', input: '' }));
                }
                else if (input && !link) {
                    this.store.setValue('init', JSON.stringify({ loginType: 'otp', triaName, socialName: '', userId: '', input }));
                }
                else if (input && link) {
                    this.store.setValue('init', JSON.stringify({ loginType: 'link', triaName, socialName: '', userId: '', input }));
                }
                this.storeInTriaStore(publicVault);
                this.postMessage({
                    type: 'Log in',
                    success: true,
                    data: publicVault,
                }, userId || socialName ? true : false);
                this.storeConnectedAppInSession(origin);
                if (!userId) {
                    yield this.generateUserSession({ vault: vault });
                }
                else if (userId) {
                    yield this.generateUserSession({ vault: vault, accessToken: accessToken });
                }
                return { exists: true, data: vault };
            }
            catch (err) {
                console.error(err);
                //@ts-ignore
                Sentry.captureException(new Error(err.message), {
                    tags: { key: 'getVault' },
                    // extra: {
                    //   functionArgs: {
                    //     triaName,
                    //     password,
                    //     userId,
                    //     socialName,
                    //     input,
                    //     hash,
                    //     link,
                    //     native,
                    //     origin,
                    //   }
                    // }
                });
                this.postMessage({
                    type: 'Log in',
                    success: false,
                    data: { triaName, message: err.message || 'Incorrect username or password' },
                }, userId || socialName ? true : false);
                return { exists: false, data: null };
            }
        });
    }
    /**
     * @version 2
     */
    getOTP(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const { session } = yield this.authController.initiateOTP(input);
            return session;
        });
    }
    /**
     * @version 2
     */
    verifyOTP({ otp, session, input }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { hash, password } = yield this.authController.verifyOTP({ otp, session, input });
            return { hash, password };
        });
    }
    /**
     * @version 2
     */
    initiateEmailLinkAuth({ email, password, origin, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.authController.initiateEmailLinkAuth({ email, password, origin });
            return res;
        });
    }
    /**
     * @version 2
     */
    emailLinkVerification({ code, email }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { verify } = yield this.authController.emailLinkVerification({ code, email });
                // this.postMessage(
                //   {
                //     type: 'Email Link Sign up',
                //     success: true,
                //     data: { verify },
                //   },
                //   true
                // );
                return { verify };
            }
            catch (err) {
                console.log(err);
                // this.postMessage(
                //   {
                //     type: 'Email Link Sign up',
                //     success: false,
                //     data: null,
                //   },
                //   true
                // );
            }
        });
    }
    /**
     * @version 2
     * @param hash We get from backend
     * @param input user email or phone number
     * @param password to encrypt the data will get from backend
     * @param triaName users triaName
     * @param type ["LINK", "OTP"]
     *
     */
    generateAccountByOTPOrLINK({ hash, input, password, triaName, type, origin, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const TYPES = ['link', 'otp'];
            if (!TYPES.includes(type)) {
                throw new Error('Invalid account creation method');
            }
            const { vault, publicVault } = yield this.generateVault(triaName);
            const evmChainData = yield this.generateEVMChainData(vault);
            // DID creation
            const args = {
                did: triaName,
                evmChainData: evmChainData,
                nonEvmChainsData: [],
            };
            let res = (yield this.didService.createDID(args));
            if (!res.success) {
                throw Error('DID creation failed!');
            }
            const shard1LocalKey = `${input}:${type}:$1`;
            const shard2LocalKey = `${input}:${type}:$2`;
            const hashLocalKey = `${input}:${type}:hash`;
            const ress = yield this.shardAndPushTheVault({
                vault,
                dsc_hash: hash,
                password,
                shard1LocalKey,
                shard2LocalKey: shard2LocalKey,
                hashLocalKey: hashLocalKey,
            });
            if (ress.success) {
                this.storeInTriaStore(publicVault);
                this.store.setValue('init', JSON.stringify({ loginType: TYPES, triaName, socialName: '', userId: '', input }));
                this.storeConnectedAppInSession(origin);
                // this.postMessage({
                //   type: `${type} Sign up`,
                //   success: true,
                //   data: publicVault,
                // });
                //await this.generateUserSession({ vault: vault });
                return { success: true };
            }
            else {
                throw ress.error;
            }
        });
    }
    /**
     * @description shard the vault and call the ShardStorage api
     */
    shardAndPushTheVault({ vault, dsc_hash, password, shard1LocalKey, shard2LocalKey, oauthData, hashLocalKey, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const salt = crypto.randomBytes(16);
                const randomNumber = crypto.randomBytes(32);
                console.log('password', password);
                let derivedKey = crypto.pbkdf2Sync(password, salt.toString('hex'), 5000, 32, 'sha512');
                console.log('randomNumber.toString', JSON.stringify(randomNumber.toString('hex')));
                console.log('derivedKey', derivedKey.toString('hex'));
                const encryptedRandomNumber = encryptAES256(derivedKey, JSON.stringify(randomNumber.toString('hex')));
                this.store.setValue(`encyRandomNumber:${shard1LocalKey.slice(0, -1)}`, encryptedRandomNumber);
                // enctrypt the vault
                const encryptedWallet = encryptAES256(randomNumber, JSON.stringify(vault));
                // shard the encrypted vault
                const [lshard, ipfsShard] = shamir(secrets.str2hex(encryptedWallet), 2, 2);
                const lstore = {
                    encyShard: lshard,
                };
                const ipfsPath = yield pinToIpfs(ipfsShard);
                // save the shard to local storage
                this.store.setValue(shard1LocalKey, JSON.stringify(lstore));
                this.store.setValue(shard2LocalKey, JSON.stringify(ipfsPath));
                this.store.setValue(hashLocalKey, JSON.stringify(dsc_hash));
                this.store.setValue(`SALT:${shard1LocalKey.slice(0, -1)}`, JSON.stringify(salt.toString('hex')));
                // call the shard storage
                let shardStorageRes = (yield this.didService.shardStorage({
                    hash: dsc_hash,
                    link: ipfsPath,
                }));
                if (!shardStorageRes.success) {
                    throw Error('DID creation failed!');
                }
                return { success: true };
            }
            catch (err) {
                //@ts-ignore
                Sentry.captureException(new Error(err.message), {
                    tags: { key: 'shardAndPushTheVault' },
                    // extra: {
                    //   functionArgs: {
                    //     triaName,
                    //     password,
                    //     userId,
                    //     socialName,
                    //     input,
                    //     hash,
                    //     link,
                    //     native,
                    //     origin,
                    //   }
                    // }
                });
                return { success: false, error: err };
            }
        });
    }
    /**
     * @description delete shard
     */
    deleteShardAfterSaved({ hash, localStorageKeyForHash, localStorageKeyForShard2, }) {
        return __awaiter(this, void 0, void 0, function* () {
            let intervalID = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                let shardElement = yield this.isShardPresent(hash);
                if (shardElement) {
                    console.log('Shard is present!');
                    //delete data from localStorage
                    this.store.removeValue(localStorageKeyForHash);
                    this.store.removeValue(localStorageKeyForShard2);
                    clearInterval(intervalID);
                }
                else {
                    console.log('Shard is not saved yet');
                }
            }), 10000);
        });
    }
    /**
     * @version 2
     * @returns Boolean
     */
    isShardPresent(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let shardExistsResponse = (yield this.didService.shardExists(hash));
                if (!shardExistsResponse.success) {
                    throw Error('Check Shard API Error!');
                }
                return shardExistsResponse.response;
            }
            catch (err) {
                throw err;
            }
        });
    }
    getUserSession() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.authController.getSession();
            return data;
        });
    }
    /**
     *
     */
    generateUserSession({ vault, accessToken }) {
        return __awaiter(this, void 0, void 0, function* () {
            //api request for cookie set and it will return key too
            const { key } = yield this.authController.getKey(accessToken);
            console.log('key', key);
            const keyBytes = Buffer.from(key, 'hex');
            // store the decrypted vault in obsStore
            this.memStore = new ObservableStore({
                vault: vault,
            });
            //use the key and salt to encrypt the vault
            const encryptedVault = encryptAES256(keyBytes, JSON.stringify(vault));
            //store the encrypted vault in localstorage for now
            this.store.setValue('tempVault', JSON.stringify(encryptedVault));
        });
    }
    detectLoggedInAccount() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let vault = (_a = this.memStore) === null || _a === void 0 ? void 0 : _a.getState();
            vault = JSON.parse(vault);
            const account = { triaName: vault === null || vault === void 0 ? void 0 : vault.triaName, evm: { address: (_b = vault === null || vault === void 0 ? void 0 : vault.evm) === null || _b === void 0 ? void 0 : _b.address } };
            this.postMessage({
                type: 'Detected Logged in Tria account',
                success: true,
                data: account,
            });
        });
    }
    /**
     * Asynchronously reconstructs User Vault.
     * @param tID - The ID of the User.
     * @param triaName - The Tria name of the User.
     * @param password - The password for authentication.
     * @returns A Promise that resolves to the reconstructed Decrypted Vault.
     */
    reconstruct(password, pin) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { tID } = yield this.userService.get_tID();
                const shadowHash = yield generateShadowHash({
                    secret: `${password}:${pin}`,
                    salt: tID,
                });
                console.log('reconstructing...');
                let decryptedVault = yield reconstruct(tID, shadowHash, this.apiUrl);
                const nonEvmVault = filterNonEVM(decryptedVault === null || decryptedVault === void 0 ? void 0 : decryptedVault.vault.accountKeys, NON_EVM_LIST);
                const { nonEvmShard1Vault, nonEvmShard2Vault } = yield shardNonEvmVaultKeys(nonEvmVault);
                console.log({ nonEvmShard1Vault, nonEvmShard2Vault });
                yield this.walletService.addNonEvmShards({ accountKeys: nonEvmShard2Vault });
                // const keyForVault = await generateShadowHash({
                //   secret: `${pin}`,
                //   salt: tID,
                // });
                let encryptedVault = encryptAES256(shadowHash, JSON.stringify(decryptedVault));
                this.store.setValue(VAULT, JSON.stringify(encryptedVault));
                this.store.setValue(NON_EVM_VAULT, JSON.stringify(nonEvmShard1Vault));
                decryptedVault === null || decryptedVault === void 0 ? true : delete decryptedVault.vault.memonic;
                const memData = { vault: {}, nEVMVault: {} };
                memData[VAULT] = decryptedVault === null || decryptedVault === void 0 ? void 0 : decryptedVault.vault;
                memData[NON_EVM_VAULT] = nonEvmShard1Vault;
                this.memStore.putState(memData);
                this.store.setValue(KEY_STORE, JSON.stringify((_a = decryptedVault === null || decryptedVault === void 0 ? void 0 : decryptedVault.vault.accountKeysdecryptedVault) === null || _a === void 0 ? void 0 : _a.vault.accountKeys));
                return { success: true };
            }
            catch (err) {
                console.log(err);
                return { success: false };
            }
        });
    }
    /**
     *
     * @param username users tria name
     * @param password users password
     * @param pin user pin
     * @param chainName chain name for which user want to add wallet
     */
    addWallet(password, pin, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            const walletService = new WalletService(this.apiUrl);
            try {
                yield walletService.add(password, pin, chainName);
                return yield this.fullUpdate(password, pin);
            }
            catch (err) {
                console.log(err);
                return { success: false, list: [] };
            }
        });
    }
    updateSubName({ newSubName, oldSubName, password, pin, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.walletService.updateSubName({ newSubName, oldSubName, password, pin });
            return yield this.fullUpdate(password, pin);
        });
    }
    removeAddress({ subname, password, pin }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.walletService.removeSubname({ subname, password, pin });
            return yield this.userService.getAllAddresses();
        });
    }
    /**
     * Private method use to get users key from memory
     * @param triaName Trianame
     * @param chainName Chain name for which users password needed
     * @returns keypair
     */
    /**
     * @todo Password & pin verification
     * @param password Password
     * @param pin Pin
     */
    exportMemonic(password, pin) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { tID } = yield this.userService.get_tID();
                const shadowHash = yield generateShadowHash({
                    secret: `${password}:${pin}`,
                    salt: tID,
                });
                const encryptedVault = yield this.store.getValue(VAULT);
                const hexIV = encryptedVault.split(':')[0];
                const cipher = encryptedVault.split(':')[1];
                const IV = Buffer.from(hexIV, 'hex');
                const decryptedVault = yield decryptAES(cipher, shadowHash, IV);
                const parsedVault = JSON.parse(decryptedVault);
                const memonic = parsedVault.vault.memonic;
                return {
                    success: true,
                    mnemonic: memonic,
                };
            }
            catch (err) {
                console.log(err);
                return {
                    success: false,
                    mnemonic: null,
                };
            }
        });
    }
    /**
     * @todo Password & pin verification
     * @param triaName triaName
     * @param password Password
     * @param pin Pin
     * @param chainName chainName
     */
    exportPrivateKey(triaName, password, pin, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { tID } = yield this.userService.get_tID();
                const shadowHash = yield generateShadowHash({
                    secret: `${password}:${pin}`,
                    salt: tID,
                });
                const encryptedVault = yield this.store.getValue(VAULT);
                const hexIV = encryptedVault.split(':')[0];
                const cipher = encryptedVault.split(':')[1];
                const IV = Buffer.from(hexIV, 'hex');
                const decryptedVault = yield decryptAES(cipher, shadowHash, IV);
                const parsedVault = JSON.parse(decryptedVault);
                console.log('parsedVault', parsedVault);
                const accountKeys = parsedVault.vault.accountKeys;
                const privateKey = accountKeys[triaName][chainName]['privateKey'];
                return {
                    success: true,
                    privateKey: privateKey,
                };
            }
            catch (err) {
                console.log(err);
                return {
                    success: false,
                    privateKey: null,
                };
            }
        });
    }
    /**
     *@description this function is for inMemory data persist
     */
    persistMemoryData() {
        return __awaiter(this, void 0, void 0, function* () {
            this.store.setValue(TEMP_MEM_STORE, JSON.stringify(this.memStore.getState()));
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.authController.logout();
            this.cleanOnLogout();
            this.postMessage({
                type: 'Logout',
                success: true,
            });
            return { success: true };
        });
    }
    cleanOnLogout() {
        return __awaiter(this, void 0, void 0, function* () {
            this.store.removeValue('tempVault');
            this.store.removeValue('tria.wallet.store');
            this.memStore = new ObservableStore({});
            return { success: true };
        });
    }
    /**
     * @param triaName triaName
     * @param chainName chainName
     */
    resolveTriaName(triaName, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.walletService.resolveTriaName({ chainName, lookUpTriaName: triaName }, this.environment);
            return res.address;
        });
    }
    /**
     * For message passing between windows and iframes
     * @param windowTo
     * @param message
     */
    postMessage(message, sameOrigin = false) {
        var _a, _b;
        console.log('postMessage', message);
        console.log({ sameOrigin });
        if (sameOrigin) {
            const bc = new BroadcastChannel('Tria Auth Channel');
            bc.postMessage(JSON.stringify(message));
            if ((_a = window === null || window === void 0 ? void 0 : window.opener) === null || _a === void 0 ? void 0 : _a.postMessage) {
                window.opener.postMessage(JSON.stringify(message), '*');
            }
            return;
        }
        if ((_b = window === null || window === void 0 ? void 0 : window.opener) === null || _b === void 0 ? void 0 : _b.postMessage) {
            window.opener.postMessage(JSON.stringify(message), '*');
        }
        else if (window === null || window === void 0 ? void 0 : window.parent) {
            window.parent.postMessage(JSON.stringify(message), document.referrer);
        }
    }
    storeInTriaStore(publicVault) {
        this.store.setValue('tria.wallet.store', JSON.stringify(publicVault));
    }
    storeConnectedAppInSession(dappUrl) {
        const connectedApps = 'tria.connected.apps';
        try {
            const appUrl = dappUrl || document.referrer;
            let prevApps = window.localStorage.getItem(connectedApps);
            let allApps;
            if (prevApps) {
                console.log(prevApps);
                const apps = JSON.parse(prevApps);
                // to avoid duplicates
                if (apps.includes(appUrl))
                    return;
                apps.push(appUrl);
                allApps = JSON.stringify(apps);
            }
            else {
                allApps = JSON.stringify([appUrl]);
            }
            console.log({ allApps });
            window.localStorage.setItem(connectedApps, allApps);
        }
        catch (err) {
            window.localStorage.removeItem(connectedApps);
        }
    }
}
_KeyringController_instances = new WeakSet(), _KeyringController_resolveTriaName = function _KeyringController_resolveTriaName(chainName) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        console.log('fetching vault');
        let vault = yield ((_a = this.memStore) === null || _a === void 0 ? void 0 : _a.getState());
        if (vault)
            vault = JSON.parse(vault);
        console.log({ vault });
        let privateKey, address;
        if (isEvmChain(chainName)) {
            privateKey = (_b = vault === null || vault === void 0 ? void 0 : vault.evm) === null || _b === void 0 ? void 0 : _b.privateKey;
            address = (_c = vault === null || vault === void 0 ? void 0 : vault.evm) === null || _c === void 0 ? void 0 : _c.address;
        } // else implement for non evm
        return {
            privateKey: privateKey,
            address: address,
            triaName: vault === null || vault === void 0 ? void 0 : vault.triaName,
        };
    });
};
