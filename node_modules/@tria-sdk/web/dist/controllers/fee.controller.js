var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Multichain } from '../utils/helper/multichain';
import WalletService from '../services/wallet';
import { isChainSupported } from '@tria-sdk/core';
import { checksumAddress } from '../utils/helper/checksum';
import { isValidAddress } from '../utils/helper/isValidAddress';
export class FeeController extends Multichain {
    /**
     * Constructs a new instance of the Tria class.
     * @param apiUrl - The URL of the API.
     */
    constructor({ baseUrl, walletType, selectedChainName, environment = 'mainnet' }) {
        super(baseUrl, walletType);
        this.apiUrl = baseUrl;
        this.walletService = new WalletService(this.apiUrl);
        if (isChainSupported(selectedChainName))
            this.selectedChainName = selectedChainName;
        this.environment = environment;
    }
    /**
     * @param triaName triaName
     * @param chainName chainName
     */
    resolveTriaName(triaName, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.walletService.resolveTriaName({ chainName, lookUpTriaName: triaName }, this.environment);
            return res.address;
        });
    }
    checkTokenAllowance(triaName, chainName, payload) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const chain = (this.selectedChainName || chainName);
            const { tokenAddress, amount, spender } = payload;
            if (amount <= 0)
                return { success: false, message: 'Invalid amount' };
            if (!tokenAddress)
                return { success: true, allowance: true };
            const address = yield this.resolveTriaName(triaName, chain);
            // @ts-ignore
            const res = yield ((_a = this.chains[chain]) === null || _a === void 0 ? void 0 : _a.checkTokenAllowance({
                accountAddress: address,
                tokenAddress,
                amount,
                spender,
            }));
            return { success: true, allowance: res };
        });
    }
    getSendFee(chainName, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const chain = (this.selectedChainName || chainName);
            if (payload.amount <= 0)
                return { success: false, message: 'Invalid amount' };
            console.log('getSendFee ', { chain, payload });
            if (isChainSupported(chain)) {
                const fromAddress = yield this.resolveTriaName(payload === null || payload === void 0 ? void 0 : payload.fromTriaName, chain);
                const { recipientTriaName } = payload;
                let recipientAddress;
                if (!recipientTriaName.includes('@tria') && isValidAddress(recipientTriaName))
                    recipientAddress = checksumAddress(payload.recipientTriaName);
                else
                    recipientAddress = yield this.resolveTriaName(payload.recipientTriaName, chain);
                // const recipientAddress = await this.resolveTriaName(payload.recipientTriaName, chain);
                const res = yield this.chains[chain].getSendFee(fromAddress, recipientAddress, payload.amount, payload === null || payload === void 0 ? void 0 : payload.tokenAddress);
                return res;
            }
            else {
                return { success: false, message: 'Chain not supported' };
            }
        });
    }
    getApproveFee(triaName, chainName, payload) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const chain = (this.selectedChainName || chainName);
            const { amount, tokenAddress, spender } = payload;
            if (amount <= 0)
                return { success: false, message: 'Invalid amount' };
            const fromAddress = yield this.resolveTriaName(triaName, chain);
            // @ts-ignore
            const res = yield ((_a = this.chains[chain]) === null || _a === void 0 ? void 0 : _a.getApproveFee(fromAddress, tokenAddress, amount, spender));
            return res;
        });
    }
    getCallContractFee(triaName, chainName, contractDetails) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const chain = (this.selectedChainName || chainName);
            const fromAddress = yield this.resolveTriaName(triaName, chain);
            // @ts-ignore
            const res = yield ((_a = this.chains[chain]) === null || _a === void 0 ? void 0 : _a.getCallContractFee(contractDetails, fromAddress));
            return res;
        });
    }
    getSwapTargets(chainName, fromTokenAddress, listLength, query) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const chain = (this.selectedChainName || chainName);
            // @ts-ignore
            const res = yield ((_a = this.chains[chain]) === null || _a === void 0 ? void 0 : _a.getSwapTargets(fromTokenAddress, listLength, query));
            return res;
        });
    }
    getSwapFee(chainName, payload) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const chain = (this.selectedChainName || chainName);
            if (payload.fromAmount <= 0)
                return { success: false, message: 'Invalid amount' };
            const fromAddress = yield this.resolveTriaName(payload === null || payload === void 0 ? void 0 : payload.triaName, chain);
            const { fromTokenAddress, toTokenAddress, fromAmount, slippage } = payload;
            // @ts-ignore
            const res = yield ((_a = this.chains[chain]) === null || _a === void 0 ? void 0 : _a.getSwapFee(fromAddress, fromTokenAddress, toTokenAddress, fromAmount, slippage));
            return res;
        });
    }
    getSendNFTFee(chainName, fromTriaName, recipientTriaName, nftDetails) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const chain = (this.selectedChainName || chainName);
            if (nftDetails.amount <= 0)
                return { success: false, message: 'Invalid amount' };
            if (isChainSupported(chain)) {
                const fromAddress = yield this.resolveTriaName(fromTriaName, chain);
                let recipientAddress;
                if (!recipientTriaName.includes('@tria') && isValidAddress(recipientTriaName))
                    recipientAddress = checksumAddress(recipientTriaName);
                else
                    recipientAddress = yield this.resolveTriaName(recipientTriaName, chain);
                // @ts-ignore
                const res = yield ((_a = this.chains[chain]) === null || _a === void 0 ? void 0 : _a.getSendNFTFee(fromAddress, recipientAddress, nftDetails));
                return res;
            }
            else if (isChainSupported(chain)) {
                return { success: false, message: 'Chain not supported' };
            }
            else {
                return { success: false, message: 'Chain not supported' };
            }
        });
    }
}
