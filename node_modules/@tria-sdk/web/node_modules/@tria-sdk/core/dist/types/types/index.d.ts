import { DidDataResponse } from '../utils/did/types';
export type ENV = 'testnet' | 'mainnet-staging' | 'mainnet';
export interface TriaArgs {
    baseUrl: string;
}
export interface Send {
    fromTriaName: string;
    recipientTriaName: string;
    amount: number;
    tokenAddress?: string | number | Object;
}
export interface Swap {
    triaName: string;
    fromTokenAddress: string;
    toTokenAddress: string;
    fromAmount: number;
    slippage: number;
}
export interface Login {
    triaName: string;
    password: string;
    pin: string;
}
export interface Register {
    username: string;
    usernameExtension: string;
    passwordVerify: string;
    password: string;
    pin: string;
}
export interface DeleteAccount {
    password: string;
    pin: string;
}
export interface UpdateSubNameArgs {
    password: string;
    pin: string;
    oldSubName: string;
    newSubName: string;
}
export interface RemoveAddressArgs {
    subname: string;
    password: string;
    pin: string;
}
export interface UpdatePasswordArgs {
    oldPassword: string;
    newPassword: string;
    verifyNewPassword: string;
    pin: string;
}
export interface PinAndPasswordVerifyArgs {
    triaName: string;
    pin: string;
    password: string;
}
export interface PasswordVerifyResponse {
    message: string;
    isPasswordCorrect: boolean;
    success: boolean;
}
export interface PinAndPasswordVerifyResponse {
    message: string;
    isPinPassCorrect: boolean;
    success: boolean;
}
export interface DeleteAccountResponse {
    message: string;
    success: boolean;
}
export interface PasswordVerifyArgs {
    password: string;
}
export interface PinVerifyArgs {
    pin: string;
}
export interface PinVerifyResponse {
    message: string;
    isPinCorrect: boolean;
    success: boolean;
}
export interface UpdatePinArgs {
    oldPin: string;
    newPin: string;
    verifyNewPin: string;
    password: string;
}
export interface ResolveTriaName {
    lookUpTriaName: string;
    chainName: string;
}
export interface AccountKeys {
    [index: string]: {
        [index: string]: Key;
    };
}
export interface Key {
    address?: string;
    privateKey?: string;
    publicKey?: string;
}
export interface NONEvmAccountKeys {
    [index: string]: {
        [index: string]: sharKey;
    };
}
export interface AddNonEvmShards {
    accountKeys: NONEvmAccountKeys;
}
export interface sharKey {
    address?: string;
    shard?: string;
    publicKey?: string;
}
export interface AddWalletResponse {
    list: UpdatedWalletInfoList;
    success: boolean;
}
interface UpdatedWalletInfoList extends Array<WalletInfo> {
}
interface WalletInfo {
    creationMethod: CreationMethod;
    addresses: AddressList;
}
interface AddressList extends Array<Address> {
}
interface Address {
    subname: Nullable<string>;
    address: string;
    isDeleted: Nullable<boolean>;
    chain: string;
}
declare enum CreationMethod {
    Onboarding = 1,
    ManualCreation = 2,
    ManualImport = 3
}
type Nullable<T> = T | undefined | null;
export interface ExportPrivateKeyResponse {
    success: boolean;
    privateKey: string | null;
}
export interface ExportMnemonicResponse {
    success: boolean;
    mnemonic: string | null;
}
export interface ReconstructResponse {
    success: boolean;
}
export interface UpdatedWalletAddresses {
    list: UpdatedWalletInfoList;
    success: boolean;
}
export interface RampnalysisUrlResponse {
    url: string | null;
    success: boolean;
}
export interface RampnalysisSupportedResponse {
    data: RampnalysisAssets[] | null;
    success: boolean;
}
export interface RampnalysisAssets {
    coinSymbol: string;
    assetLogo: string;
    chainName: string;
    chainLogo: string;
}
export interface FeeResponse {
    success: boolean;
    fee?: {
        eth: string;
        usd?: string;
    };
    message?: string;
    error?: any;
}
export interface CheckTokenAllowanceResponse {
    success: boolean;
    allowance?: boolean;
    message?: string;
}
export interface TxnObjectResponse {
    success: boolean;
    txnObject?: Object;
    message?: string;
}
export interface TxnResponse {
    success: boolean;
    data?: {
        txnId: string;
        viewInExplorer: string;
        wait: Function;
    };
    message?: string;
    error?: any;
}
export interface SwapTargetResponse {
    name: string;
    symbol: string;
    tokenAddress: string | null;
    logoUrl: string;
}
export interface GetTotalBalanceResponse {
    success: boolean;
    data?: {
        balance: number;
        balance1dBefore: number;
        percentChangeIn24hr: number;
    };
    message?: string;
}
export interface GetChainNameByTriaName {
    success: boolean;
    chains: [];
    message: string;
}
export interface NFTDetails {
    type: string;
    tokenAddress: string;
    tokenId: string;
    amount: number;
}
export interface NFTDetail {
    type: string;
    tokenAddress: string;
    tokenUri: string;
}
export type GetAllAddressesResponse = {
    success: boolean;
    data: DidDataResponse | null;
    message?: string;
};
export interface KeyringControllerInterface {
    apiUrl: string;
    reconstruct(password: string, pin: string): Promise<ReconstructResponse>;
    addWallet(password: string, pin: string, chainName: string): Promise<UpdatedWalletAddresses>;
    getSendFee(chainName: string, payload: Send): Promise<FeeResponse>;
    send(pin: string, chainName: string, payload: Send): Promise<TxnResponse>;
    updateSubName(args: UpdateSubNameArgs): Promise<UpdatedWalletAddresses>;
    removeAddress(args: RemoveAddressArgs): Promise<UpdatedWalletAddresses>;
    checkTokenAllowance(triaName: string, chainName: string, tokenAddress: string | null, amount: number): Promise<CheckTokenAllowanceResponse>;
    getApproveFee(triaName: string, chainName: string, tokenAddress: string, amount: number): Promise<FeeResponse>;
    approve(pin: string, triaName: string, chainName: string, tokenAddress: string, amount: number): Promise<TxnResponse>;
    getSwapTargets(chainName: string, fromTokenAddress: string | null, listLength: number, query?: string): Promise<SwapTargetResponse[]>;
    getSwapFee(chainName: string, payload: Swap): Promise<FeeResponse>;
    swap(pin: string, chainName: string, payload: Swap): Promise<TxnResponse>;
    resolveTriaName(triaName: string, chainName: string): Promise<string>;
    exportMemonic(password: string, pin: string): Promise<ExportMnemonicResponse>;
    exportPrivateKey(triaName: string, password: string, pin: string, chainName: string): Promise<ExportPrivateKeyResponse>;
    getSendNFTFee(chainName: string, fromTriaName: string, recipientTriaName: string, nftDetails: NFTDetails): Promise<FeeResponse>;
    sendNFT(pin: string, chainName: string, fromTriaName: string, recipientTriaName: string, nftDetails: NFTDetails): Promise<TxnResponse>;
    burnNFT(pin: string, chainName: string, fromTriaName: string, nftDetails: NFTDetails): Promise<TxnResponse>;
    claimNFT(pin: string, chainName: string, fromTriaName: string, nftDetails: NFTDetails): Promise<TxnResponse>;
    createNFT(pin: string, chainName: string, fromTriaName: string, nftDetail: NFTDetail): Promise<TxnResponse>;
}
export {};
