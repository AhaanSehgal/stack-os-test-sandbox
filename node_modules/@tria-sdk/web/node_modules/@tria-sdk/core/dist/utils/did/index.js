"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAddresses = void 0;
const axios_1 = __importDefault(require("axios"));
const constants_1 = require("../constants");
const getAddresses = (triaName, environment) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        console.log('DID resolving..');
        var data = JSON.stringify({
            query: `query MyQuery($id: ID!, $didName: String!) {
              didToEvmAddress(id: $id) {
                did
                evmAddress
              }
              didToNonEvmAddresses(where: {did: $didName}) {
                did
                nonEvmAddress
                chain {
                  id
                  chainName
                }
              }
            }`,
            variables: { id: triaName, didName: triaName },
        });
        var config = {
            method: 'post',
            url: (0, constants_1.getSubgraphUrl)(environment),
            headers: {
                'Content-Type': 'application/json',
            },
            data: data,
        };
        const { data: { data: didData }, } = yield (0, axios_1.default)(config);
        if (didData)
            return { success: true, data: didData };
        else
            return { success: false, data: null, message: 'DID does not exist' };
    }
    catch (err) {
        throw err;
    }
});
exports.getAddresses = getAddresses;
// export const resolveATriaName = async (triaName: string, chainName: string, environment?: ENV) => {
//   // const triaName = subnameToTriaName(lookUpTriaName);
//   try {
//     console.log('DID resolving..');
//     var data = JSON.stringify({
//       query: `query MyQuery($id: ID!, $didName: String!, $chainNameVar: String!) {
//             didToEvmAddress(id: $id) {
//               did
//               evmAddress
//             }
//             didToNonEvmAddresses(where: {did: $didName, chain_: {chainName: $chainNameVar}}) {
//               did
//               nonEvmAddress
//               chain {
//                 id
//                 chainName
//               }
//             }
//           }`,
//       variables: { id: triaName, didName: triaName, chainNameVar: chainName },
//     });
//     var config = {
//       method: 'post',
//       url: getSubgraphUrl(environment),
//       headers: {
//         'Content-Type': 'application/json',
//         Cookie:
//           '__cf_bm=Erpt9czA1mmUmdjRKr.2U0FfrQ4LdaZCpjcr2y_rjMo-1696236863-0-AbqNv0BCbA3FLaJV95V45r2NkHsJBBnYthsTHTogS5n1XPwkRMDwz5HY3Op+cTGwwG0gFXfj/74MGfpq/GwObUk=',
//       },
//       data: data,
//     };
//     const { data: didData } = await axios(config);
//     console.log({ didData });
//     const evmAddress = didData?.data?.didToEvmAddress?.evmAddress;
//     if (!evmAddress) throw Error('DID does not exist!');
//     // if chainName is not in EVM
//     // return didData.data.didToNonEvmAddresses[0].nonEvmAddress;
//     return { address: evmAddress };
//   } catch (err) {
//     throw Error('Unable to resolve DID.');
//   }
// };
