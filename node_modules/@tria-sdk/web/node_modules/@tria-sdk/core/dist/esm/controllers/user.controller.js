import UserService from '../services/user';
import { ENV, GetAllAddressesResponse, GetChainNameByTriaName, GetTotalBalanceResponse, RampnalysisSupportedResponse, RampnalysisUrlResponse, } from '../types';
export class UserController {
    constructor(baseUrl, triaName, environment = 'mainnet') {
        this.baseUrl = baseUrl;
        this.user = new UserService(baseUrl, environment);
        this.triaName = triaName;
    }
    async get_tID() {
        try {
            const res = await this.user.get_tID();
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getActions() {
        try {
            const res = await this.user.getActions();
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async requestAmount({ tag, payload }) {
        try {
            const res = await this.user.requestAmount({ tag, payload });
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async completeAction({ actionId }) {
        try {
            const res = await this.user.completeAction({ actionId });
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async ignoreAction({ actionId }) {
        try {
            const res = await this.user.ignoreAction({ actionId });
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getConversation({ participantName }) {
        try {
            const res = await this.user.getConversation({ participantName });
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async search(term) {
        try {
            const res = await this.user.search({ term });
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async searchUser(term) {
        try {
            const res = await this.user.searchUser({ term });
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getHomeScreenHistory() {
        try {
            let res = { actions: [], history: [] };
            if (res.actions.length == 0) {
                let historyRes = await this.user.getAllHistory(this.triaName);
                if (historyRes.success && historyRes.history.length > 0)
                    res.history = historyRes.history.slice(0, 3);
            }
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getAllAddresses(triaName) {
        try {
            const res = await this.user.getAllAddresses((triaName || this.triaName));
            return res;
        }
        catch (err) {
            throw err;
        }
    }
    async getSubnames() {
        try {
            const res = await this.user.getSubnames();
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getAllHistory(filter = 'all', filterChainNames, triaName) {
        try {
            const res = await this.user.getAllHistory((this.triaName || triaName), filter, filterChainNames);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getOnChainConversation(withTriaName, triaName) {
        try {
            const res = await this.user.getOnChainConversation((this.triaName || triaName), withTriaName);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getAssets(filterChainNames, filter, sort, triaName) {
        try {
            const res = await this.user.getAssets((this.triaName || triaName), filterChainNames, filter, sort);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getAssetsForATriaName(triaName, filterChainNames, sort) {
        try {
            const res = await this.user.getAssetsForATriaName(triaName, filterChainNames, sort);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getAsset(chainName, tokenAddress, triaName) {
        try {
            const res = await this.user.getAsset((this.triaName || triaName), chainName, tokenAddress);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getAssetBalanceForATriaName(triaName, chainName, tokenAddress) {
        try {
            const res = await this.user.getAssetBalanceForATriaName(triaName, chainName, tokenAddress);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getAssetDetails(chainName, tokenAddress, triaName) {
        try {
            const res = await this.user.getAssetDetails((this.triaName || triaName), chainName, tokenAddress);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getSubnamesForAsset(chainName, tokenAddress) {
        try {
            const res = await this.user.getSubnamesForAsset(chainName, tokenAddress);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getAllSubnamesForAsset(chainName, tokenAddress) {
        try {
            const res = await this.user.getAllSubnamesForAsset(chainName, tokenAddress);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getAssetHistory(chainName, tokenAddress, triaName) {
        try {
            const res = await this.user.getAssetHistory((this.triaName || triaName), chainName, tokenAddress);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getNFTs(sort = 'Descending buy date', filter, filterByCollectionId, filterChainNames, triaName) {
        try {
            const res = await this.user.getNFTs((this.triaName || triaName), sort, filter, filterByCollectionId, filterChainNames);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getNFTCollections(filterChainNames, triaName) {
        try {
            const res = await this.user.getNFTCollections((this.triaName || triaName), filterChainNames);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getNFTDetails(chainName, tokenAddress, tokenId, triaName) {
        try {
            const res = await this.user.getNFTDetails((this.triaName || triaName), chainName, tokenAddress, tokenId);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getAllNfts(filter, filterAssetGroup, filterChainNames) {
        try {
            const res = await this.user.getAllNfts(filter, filterAssetGroup, filterChainNames);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getNftDetails(chainName, tokenAddress, tokenId) {
        try {
            const res = await this.user.getNftDetails(chainName, tokenAddress, tokenId);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getNftHistory(chainName, tokenAddress, tokenId) {
        try {
            const res = await this.user.getNftHistory(chainName, tokenAddress, tokenId);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getUserByAddress(address, chainName) {
        try {
            const res = await this.user.getUserByAddress(address, chainName);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getAddressByChainName(triaName, chainName) {
        try {
            const res = await this.user.getAddressByChainName(triaName, chainName);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getNextSubname() {
        try {
            const res = await this.user.getNextSubname();
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async convertToken(chainName, fromToken, fromAmount, toToken) {
        try {
            const res = await this.user.convertToken(chainName, fromToken, fromAmount, toToken);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getRampnalysisUrl(address, coinSymbol) {
        try {
            const res = await this.user.getRampnalysisUrl(address, coinSymbol);
            return res;
        }
        catch (err) {
            return { success: false, url: null };
        }
    }
    async getRampnalysisSupportedToken(query) {
        try {
            const res = await this.user.getRampnalysisSupportedToken(query);
            return res;
        }
        catch (err) {
            return { success: false, data: null };
        }
    }
    async getAllNetworks() {
        try {
            const res = await this.user.getAllNetworks();
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async markAssetAsFavourite(chainName, tokenAddress) {
        try {
            const res = await this.user.markAssetAsFavourite(chainName, tokenAddress);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async markNFTsAsFavourite(chainName, tokenAddress, tokenId) {
        try {
            const res = await this.user.markNFTsAsFavourite(chainName, tokenAddress, tokenId);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async unMarkAssetAsFavourite(chainName, tokenAddress) {
        try {
            const res = await this.user.unMarkAssetAsFavourite(chainName, tokenAddress);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async unMarkNFTsAsFavourite(chainName, tokenAddress, tokenId) {
        try {
            const res = await this.user.unMarkNFTsAsFavourite(chainName, tokenAddress, tokenId);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getAssetChartData(symbol, timePeriod = 'daily', interval = 'daily', count = 10) {
        try {
            const res = await this.user.getAssetChartData(symbol, timePeriod, interval, count);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getAssetChart(timePeriod, chainName, tokenAddress) {
        try {
            const res = await this.user.getAssetChart(timePeriod, chainName, tokenAddress);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getTotalBalance(triaName) {
        try {
            const res = await this.user.getTotalBalance((this.triaName || triaName));
            return res;
        }
        catch (err) {
            return { success: false, message: 'Unable to fetch total balance' };
        }
    }
    async getChainNameByTriaName(triaName) {
        try {
            const res = await this.user.getChainNameByTriaName(triaName);
            return res;
        }
        catch (err) {
            return { success: false, chains: [], message: 'Unable to fetch chains for triaName' };
        }
    }
    async claimDrinks() {
        try {
            const res = await this.user.claimDrinks();
            return res;
        }
        catch (err) {
            return { success: false, message: 'Unable to claim drinks' };
        }
    }
    async hasClaimed() {
        try {
            const res = await this.user.hasClaimed();
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getAvatar(accessToken) {
        try {
            const res = await this.user.getAvatar(accessToken);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async updateAvatar(accessToken) {
        try {
            const res = await this.user.updateAvatar(accessToken);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getPopularToken() {
        try {
            const res = await this.user.getPopularToken();
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async searchBuyToken(tokenName, currentChainName) {
        try {
            const res = await this.user.searchBuyToken(tokenName, currentChainName);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async addUserActivity(triaName, sentToTriaName) {
        try {
            const res = await this.user.addUserActivity(triaName, sentToTriaName);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async getRecentUsersForUser(triaName) {
        try {
            const res = await this.user.getRecentUsersForUser(triaName);
            return res;
        }
        catch (err) {
            return err;
        }
    }
    async deleteARecentUser(user, recentUser) {
        try {
            const res = await this.user.deleteARecentUser(user, recentUser);
            return res;
        }
        catch (err) {
            return err;
        }
    }
}
//# sourceMappingURL=user.controller.js.map