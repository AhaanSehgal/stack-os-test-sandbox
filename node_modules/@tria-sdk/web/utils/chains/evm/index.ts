import { ethers } from 'ethers';
import axios from 'axios';
import {
  SendPayload,
  SwapPayload,
  ApprovePayload,
  CheckTokenAllowance,
  NFTDetails,
  NFTDetail,
} from '../../../types/chain';
import erc20Abi from './utils/abis/erc20';
import { Chain } from '../../../interfaces/chain';
import { LIDO_ABI, LIDO_ADDRESS } from './utils/abi';
import { nativeTokenDetails, txnBaseUrl } from '../../helper/constants';
import { getTokenPrice } from '../../coingecko/getPrices';
import { checksumAddress } from '../../helper/checksum';
import {
  ContractDetails,
  FeeResponse,
  ReadContractResponse,
  SwapTargetResponse,
  TxnObjectResponse,
  TxnResponse,
  WalletType,
} from '../../../types';
// import Decimal from 'decimal.js';
// import { getBalanceInTokens } from '../../helper/format';
import { erc1155ABI } from './utils/abis/erc1155';
import { erc721ABI } from './utils/abis/erc721';
import { CouponsABI } from './utils/abis/CouponsAbi';
import { getEthersProvider, getEthersSigner } from './utils/adapter';

/**
 * EVM Class for all interactions with EVM compatible chains
 *
 * we use the rpcUrl for making chain provider
 * and chainId for swap on 1inch api
 *
 * https://docs.1inch.io/docs/aggregation-protocol/api/swagger
 */
export class EVM implements Chain {
  // private providerInstance: ethers.providers.JsonRpcProvider;
  private rpcUrl: string;
  private chainId: number;
  private chainName: string;
  private okxDexApiUrl: string = 'https://www.okx.com/api/v5/dex/aggregator';
  private triaApiBaseUrl: string;
  public walletType: WalletType;

  /**
   * In case of EVM, uses the rpcUrl to make a provider
   *
   * Sets the chain id and provider instance
   *
   * @param chainId - A chain id for using 1inch apis.
   * @param rpcUrl - A rpcUrl for the provider
   */
  constructor(
    baseUrl: string,
    chainId: number,
    rpcUrl: string,
    chainName?: string,
    walletType?: WalletType
  ) {
    this.walletType = walletType as WalletType;
    console.log(`EVM chain instance for ${chainId} ${chainName}`, { walletType });

    // this.providerInstance = providerInstance;
    this.rpcUrl = rpcUrl;
    this.chainId = chainId;
    this.chainName = chainName as string;
    this.triaApiBaseUrl = `${baseUrl}/api/v1`;
  }

  /**
   * Get RPC provider for embedded or external wallet
   *
   * @returns providerInstance
   */
  getProvider(): ethers.providers.JsonRpcProvider {
    const providerInstance =
      this.walletType?.embedded || !this.walletType
        ? new ethers.providers.JsonRpcProvider(this.rpcUrl)
        : (getEthersProvider({ chainId: this.chainId }) as ethers.providers.JsonRpcProvider);
    return providerInstance;
  }

  /**
   * Derives new wallet for a chain using mnemonic and derivation path
   *
   * Returns the publicKey and privateKey
   *
   * @param mnemonic - An account address.
   * @param derivationPath - derivation path chain specific and derivationIndex calc?
   * @param derivationPathIndex - index
   * @returns The public key and private key.
   */
  async createWallet(
    mnemonic: string,
    derivationPathIndex: number
  ): Promise<{ address: string; privateKey: string }> {
    const wallet = ethers.Wallet.fromMnemonic(mnemonic, `m/44'/60'/0'/0/${derivationPathIndex}`);
    return {
      address: wallet.address,
      privateKey: wallet.privateKey,
    };
  }

  async getTokenDetails(tokenAddress?: string) {
    try {
      let decimals;
      let name;
      let symbol;
      if (tokenAddress) {
        const { contract } = await this.getContract(tokenAddress);
        name = await contract.name();
        symbol = await contract.symbol();
        decimals = await contract.decimals();
      } else {
        //@ts-ignore
        name = nativeTokenDetails[this.chainName].name;
        //@ts-ignore
        symbol = nativeTokenDetails[this.chainName].symbol;
        decimals = 18;
      }
      return {
        name,
        symbol,
        decimals,
      };
    } catch (error) {
      throw error;
    }
  }

  /**
   * Gets balance for native token or asset
   *
   * Returns the currently initialized keyring that manages
   * the specified `address` if one exists.
   *
   * @param accountAddress - An account address.
   * @param tokenAddress - A asset contract address
   * @returns The keyring of the account, if it exists.
   */
  async getBalance(accountAddress: string, tokenAddress?: string) {
    try {
      let balance;
      const { name, symbol, decimals } = await this.getTokenDetails(tokenAddress);
      if (tokenAddress) {
        const { contract } = await this.getContract(tokenAddress);
        // console.log(contract);
        balance = await contract.balanceOf(accountAddress);
      } else {
        balance = await this.getProvider().getBalance(accountAddress);
      }
      return {
        name,
        symbol,
        balance: parseFloat(
          decimals ? ethers.utils.formatUnits(balance, decimals) : ethers.utils.formatEther(balance)
        ),
        balanceInUnits: balance.toString(), // bignumber
        decimals,
      };
    } catch (error) {
      throw error;
    }
  }

  /**
   * Checks the validity of a txn based on the balance and transfer amount.
   *
   *
   * @param accountAddress - An account address.
   * @param amount - Amount to transfer
   * @param tokenAddress - A asset contract address // optional
   * @returns The keyring of the account, if it exists.
   */
  async checkSendValidity(accountAddress: string, amount: number, tokenAddress?: string) {
    let { balanceInUnits: accountBalance, decimals } = await this.getBalance(
      accountAddress,
      tokenAddress
    );
    let transferAmount = decimals
      ? ethers.utils.parseUnits(amount.toString(), decimals)
      : ethers.utils.parseEther(amount.toString());
    // console.log({ transferAmount: transferAmount.toString(), accountBalance });

    return transferAmount.lt(ethers.BigNumber.from(accountBalance));
  }

  /**
   * Sends the token amount
   *
   * @param signer - for signing txns
   * @param tokenAddress - if transferring a ERC20 token
   * @param amount - amount to transfer
   *
   * @returns Returns the txn object or hash - tbd
   */
  async send({
    signer,
    fromAddress,
    tokenAddress,
    recipientAddress,
    amount,
  }: SendPayload): Promise<TxnResponse> {
    const res = await this.getSendTxnObject(
      fromAddress as string,
      recipientAddress,
      amount,
      tokenAddress as string
    );
    if (res.success && res?.txnObject) {
      const txnRes = await this.broadcastTransaction(signer, res?.txnObject);
      return txnRes;
    } else return res;
  }

  async getSendFee(
    fromAddress: string,
    recipientAddress: string,
    amount: number,
    tokenAddress?: string
  ): Promise<FeeResponse> {
    console.log('getSendTxnObject');
    const res = await this.getSendTxnObject(
      fromAddress as string,
      recipientAddress,
      amount,
      tokenAddress as string
    );
    if (res.success) {
      const fee = await this.getEstimateFee(res.txnObject as Object);
      return fee;
    } else {
      return res;
    }
  }

  async getSendTxnObject(
    fromAddress: string,
    recipientAddress: string,
    amount: number,
    tokenAddress?: string
  ): Promise<TxnObjectResponse> {
    const valid = await this.checkSendValidity(
      fromAddress as string,
      amount, // in number, e.g. 0.1 ETH
      tokenAddress as string
    );

    const { gasPrice, gasLimit, nonce } = await this.getGasDetailsAndNonce(fromAddress);

    if (valid)
      try {
        let txnObject;
        if (tokenAddress) {
          const { contract } = await this.getContract(tokenAddress as string);
          const decimals = await contract.decimals();
          console.log({ decimals });

          txnObject = await contract.populateTransaction.transfer(
            recipientAddress,
            ethers.utils.parseUnits(amount.toString(), decimals),
            {
              gasPrice,
              nonce,
            }
          );

          console.log({ res: txnObject });
        } else {
          txnObject = {
            to: recipientAddress,
            value: ethers.utils.parseEther(amount.toString()),
            gasPrice,
            nonce,
            data: '0x',
          };
        }
        return { success: true, txnObject: { ...txnObject, from: fromAddress } };
      } catch (error) {
        // throw error;
        return { success: false, message: 'Error creating send txn object' };
      }
    else return { success: false, message: 'Not a valid txn, insufficient funds' };
  }

  /**
   * Swap tokens using 1inch aggregator
   *
   * Swap from asset to asset working
   * Naitve token to asset params to be figured out
   *
   * @param signer - to broadcast swap txn
   * @param fromTokenAddress - token to be swapped
   * @param toTokenAddress - token to be returned
   * @param amount - from amount - in number e.g. 0.1 ETH
   * @param fromAddress - address performing txn
   * @param slippage - in percentage e.g. 1%
   *
   */
  async swap({ signer, fromTokenAddress, toTokenAddress, amount, slippage }: SwapPayload) {
    const fromAddress = await signer.getAddress();

    const res = await this.getSwapTxnObject(
      fromAddress,
      fromTokenAddress,
      toTokenAddress,
      amount,
      slippage
    );
    if (res.success && res?.txnObject) {
      const txnRes = await this.broadcastTransaction(signer, res?.txnObject);
      return txnRes;
    } else {
      return res;
    }
  }

  async getSwapTxnObject(
    fromAddress: string,
    fromTokenAddress: string,
    toTokenAddress: string,
    amount: number,
    slippage: number
  ): Promise<TxnObjectResponse> {
    console.log('getSwapTxnObject');
    let contract;
    if (fromTokenAddress) {
      const res = await this.getContract(fromTokenAddress);
      contract = res.contract;
    }

    const decimals = contract ? await contract?.decimals() : 18;

    console.log({ decimals });

    const spender = await this.get1inchRouterContractAddress();
    const valid = await this.checkTokenAllowance({
      accountAddress: fromAddress,
      tokenAddress: fromTokenAddress,
      amount,
      spender,
    });

    console.log({ valid });

    const parsedAmount = ethers.utils.parseUnits(amount.toString(), decimals).toString();
    const swapParams = {
      fromTokenAddress,
      toTokenAddress,
      parsedAmount,
      fromAddress,
      slippage: slippage.toString(),
    };
    if (valid) {
      let txnObject;
      if (this.chainId == 66) {
        const res = await this.swapOnOkx(swapParams);
        if (res.success) {
          txnObject = res?.txnObject;
        } else return res;
      } else {
        const res = await this.swapOn1inch(swapParams);
        if (res.success) {
          txnObject = res?.txnObject;
        } else return res;
      }
      return { success: true, txnObject };
    } else return { success: false, message: 'Invalid swap txn, increase allowance' };
  }

  async getSwapFee(
    fromAddress: string,
    fromTokenAddress: string,
    toTokenAddress: string,
    amount: number,
    slippage: number
  ): Promise<FeeResponse> {
    const res = await this.getSwapTxnObject(
      fromAddress as string,
      fromTokenAddress,
      toTokenAddress,
      amount,
      slippage
    );
    if (res.success) {
      const fee = await this.getEstimateFee(res.txnObject as Object);
      return fee;
    } else {
      return res;
    }
  }

  async getEstimateFee(txnObject: Object): Promise<FeeResponse> {
    try {
      console.log('estimating gas..', txnObject);
      const estimatedGas = await this.getProvider().estimateGas(txnObject);
      console.log('gas', estimatedGas.toString());
      const gasPrice = await this.getProvider().getGasPrice();
      const tokenPrice = await getTokenPrice(this.chainName);
      const gasFeeInWei = estimatedGas.mul(gasPrice);
      const gasFeeInEth = ethers.utils.formatEther(gasFeeInWei); // string
      // console.log({ gasFeeInEth });

      let gasFeeInUsd;
      if (tokenPrice?.usd) {
        gasFeeInUsd = parseFloat(gasFeeInEth) * tokenPrice?.usd;
      }
      return { success: true, fee: { eth: gasFeeInEth, usd: gasFeeInUsd?.toString() } };
    } catch (err) {
      // throw err;
      return {
        success: false,
        message: 'Insufficient gas or error while estimating fee',
        error: err,
      };
    }
  }

  async getSwapTargets(
    fromTokenAddress: string | null,
    listLength: number,
    query?: string
  ): Promise<SwapTargetResponse[]> {
    try {
      const { data } = await axios.get(`${this.triaApiBaseUrl}/chain/${this.chainId}/tokens`);
      const tokens = data?.tokens;
      let swapTargets: SwapTargetResponse[] = [];
      for (let [key, token] of Object.entries(tokens)) {
        // @ts-ignore
        const tokenAddress = token?.address;
        const target = {
          // @ts-ignore
          name: token?.name,
          // @ts-ignore
          symbol: token?.symbol,
          tokenAddress:
            tokenAddress !== '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'
              ? checksumAddress(tokenAddress)
              : null,
          // @ts-ignore
          logoUrl: token?.logoURI,
          // decimals
        };

        if (target.tokenAddress === fromTokenAddress) continue;

        if (!query) swapTargets.push(target);
        // @ts-ignore
        else if (query && token?.symbol.toLowerCase().includes(query.toLowerCase())) {
          swapTargets.push(target);
        }
      }
      return swapTargets.slice(0, listLength);
    } catch (error: any) {
      // throw new Error(`Error swapping token ${fromTokenAddress}: `);
      throw new Error(error);
    }
  }

  async stake(
    signer: ethers.Wallet | ethers.providers.JsonRpcSigner,
    address: string,
    amount: number
  ): Promise<TxnResponse> {
    const MY_REWARDS_ADDRESS = address; // same as user // 'YOUR_REWARDS_ADDRESS';
    const { contract: lidoContract } = await this.getContract(LIDO_ADDRESS, signer, LIDO_ABI as []);

    const txnObject = lidoContract.submit(MY_REWARDS_ADDRESS, {
      from: address,
      value: ethers.utils.parseEther(amount.toString()),
    });

    const txnRes = await this.broadcastTransaction(signer, txnObject);
    return txnRes;
  }

  /**
   * Approve tokens to be spent by 1inch router contract
   *
   * @param signer
   * @param tokenAddress - token contract address to be swapped
   * @param accountAddress
   * @returns
   */
  async approve({
    signer,
    fromAddress,
    tokenAddress,
    amount,
    spender,
  }: ApprovePayload): Promise<TxnResponse> {
    if (!tokenAddress) return { success: false, message: 'Token address is null' };
    console.log({ fromAddress, tokenAddress, amount });

    const res = await this.getApproveTxnObject(
      fromAddress as string,
      tokenAddress,
      amount,
      spender
    );
    if (res.success && res?.txnObject) {
      console.log('broadcasting approve');
      console.log('res?.txnObject ', res?.txnObject);
      const txnRes = await this.broadcastTransaction(signer, res?.txnObject);
      return txnRes;
    } else return res;
  }

  async getApproveFee(
    fromAddress: string,
    tokenAddress: string,
    amount: number,
    spender: string
  ): Promise<FeeResponse> {
    if (!tokenAddress) return { success: false, message: 'Token address is null' };
    const res = await this.getApproveTxnObject(
      fromAddress as string,
      tokenAddress,
      amount,
      spender
    );
    if (res.success) {
      console.log('res.txnObject ', res.txnObject);
      const fee = await this.getEstimateFee(res.txnObject as Object);
      return fee;
    } else {
      return res;
    }
  }

  async getApproveTxnObject(
    fromAddress: string,
    tokenAddress: string,
    amount: number,
    spender: string
  ): Promise<TxnObjectResponse> {
    const { contract } = await this.getContract(tokenAddress);
    const decimals = await contract.decimals();
    const parsedAmount = ethers.utils.parseUnits(amount.toString(), decimals);
    try {
      const txnObject = await contract.populateTransaction.approve(spender, parsedAmount);
      return { success: true, txnObject: { ...txnObject, from: fromAddress } };
    } catch (error: any) {
      // throw error;
      return { success: false, message: `Error approving token.` };
    }
  }

  // async getApproveTxnObject(
  //   fromAddress: string,
  //   tokenAddress: string,
  //   amount: number,
  //   contractAddress: string
  // ): Promise<TxnObjectResponse> {
  //   const { contract } = await this.getContract(tokenAddress);
  //   const decimals = await contract.decimals();
  //   const parsedAmount = ethers.utils.parseUnits(amount.toString(), decimals);
  //   try {
  //     /* or get spenderAddress, i.e., 1inch router contract address
  //       and call approve function
  //     */
  //     let txnObject;
  //     if (this.chainId == 66) {
  //       // OKX
  //       const res = await this.approveOnOkx({
  //         tokenAddress,
  //         parsedAmount: parsedAmount.toString(),
  //         fromAddress,
  //       });
  //       if (res.success) {
  //         txnObject = res?.txnObject;
  //       } else return res;
  //     } else {
  //       // Other EVMs except CELO
  //       const res = await this.approveOn1inch({ tokenAddress, parsedAmount });
  //       if (res.success) {
  //         txnObject = res?.txnObject;
  //       } else return res;
  //     }
  //     console.log({ parsedAmount, txnObject, fromAddress });
  //     return {
  //       success: true,
  //       txnObject: {
  //         ...txnObject,
  //         from: fromAddress,
  //         gasPrice: ethers.utils.hexlify(parseInt(txnObject?.gasPrice)),
  //         value: ethers.utils.hexlify(parseInt(txnObject?.value)),
  //       },
  //     };
  //   } catch (error: any) {
  //     // throw error;
  //     return { success: false, message: `Error approving tokens on 1inch ${tokenAddress}` };
  //   }
  // }

  private async swapOn1inch({
    fromTokenAddress,
    toTokenAddress,
    parsedAmount,
    fromAddress,
    slippage,
  }: any): Promise<TxnObjectResponse> {
    console.log('swapOn1inch');
    try {
      const { data } = await axios.get(`${this.triaApiBaseUrl}/chain/${this.chainId}/swap`, {
        params: {
          fromTokenAddress,
          toTokenAddress,
          fromAddress,
          parsedAmount,
          slippage,
        },
      });
      const swapTxnObject = {
        ...data.tx,
        gasLimit: ethers.utils.hexlify(data.tx.gas),
        // not working hexlifying these.
        gasPrice: ethers.utils.hexlify(parseInt(data.tx.gasPrice)),
        value: ethers.utils.hexlify(parseInt(data.tx.value)),
      };
      delete swapTxnObject['gas'];

      console.log({ swapOn1inch: swapTxnObject });

      return { success: true, txnObject: swapTxnObject };
    } catch (error: any) {
      // throw new Error(`Error swapping token ${fromTokenAddress}: `);
      // throw error;
      return {
        success: false,
        message: error?.data?.description || 'Error estimating swap details, check if enough gas',
      };
    }
  }

  private async swapOnOkx({
    fromTokenAddress,
    toTokenAddress,
    parsedAmount,
    fromAddress,
    slippage,
  }: any) {
    try {
      const { data: swapData } = await axios.get(`${this.okxDexApiUrl}/swap`, {
        params: {
          chainId: this.chainId,
          fromTokenAddress,
          toTokenAddress,
          amount: parsedAmount,
          userWalletAddress: fromAddress,
          slippage: slippage, // in percent 0.5 -> 0.5%
        },
      });

      const { data, from, gasPrice, gas, to, value } = swapData.data[0].tx;

      // console.log({ gasPrice, gas });
      const swapTxnObject = {
        data,
        from,
        gasPrice: ethers.utils.hexlify(parseInt(gasPrice)),
        gasLimit: ethers.utils.hexlify(parseInt(gas)),
        to,
        value: ethers.utils.hexlify(parseInt(value)),
      };

      return { success: true, txnObject: swapTxnObject };
    } catch (error: any) {
      // throw new Error(`Error swapping token ${fromTokenAddress}: `);
      // throw new Error(error);
      return {
        success: false,
        message:
          error?.data?.description || 'Error estimating swap details, try increasing slippage',
      };
    }
  }

  async approveOn1inch({ tokenAddress, parsedAmount }: any) {
    try {
      /* or get spenderAddress, i.e., 1inch router contract address
        and call approve function
      */
      const { data: approveTxnObject } = await axios.get(
        `${this.triaApiBaseUrl}/chain/${this.chainId}/approve/transaction`,
        {
          params: {
            tokenAddress,
            parsedAmount /* if not mentioned, approves infinite amount */,
          },
        }
      );
      return { success: true, txnObject: approveTxnObject };
    } catch (error: any) {
      // throw new Error(`Error approving tokens on 1inch ${tokenAddress}: `);
      // throw new Error(error);
      return { success: false, message: 'Error creating approve txn object' };
    }
  }

  async approveOnOkx({ tokenAddress, parsedAmount, fromAddress }: any) {
    try {
      /* or get spenderAddress, i.e., 1inch router contract address
        and call approve function
      */
      const { data } = await axios.get(`${this.okxDexApiUrl}/approve-transaction`, {
        params: {
          chainId: this.chainId,
          tokenContractAddress: tokenAddress,
          approveAmount: parsedAmount /* if not mentioned, approves infinite amount */,
        },
      });
      const txnRes = data.data[0];
      const txnObject = {
        data: txnRes.data,
        from: fromAddress,
        to: tokenAddress,
        gasLimit: ethers.utils.hexlify(parseInt(txnRes.gasLimit)),
        gasPrice: ethers.utils.hexlify(parseInt(txnRes.gasPrice)),
        value: 0,
      };
      return { success: true, txnObject };
    } catch (error: any) {
      // throw new Error(`Error approving tokens on 1inch ${tokenAddress}: `);
      // throw new Error(error);
      return { success: false, message: 'Error making approve txn object on OKX' };
    }
  }

  /**
   *
   * Checks allowance for the 1inch router contract address
   *
   * @param accountAddress - account holding tokens
   * @param tokenAddress - token to check allowance
   * @param amount - amount to be spent, e.g. 0.1 ETH
   *
   * @returns bool if allowance needed or not
   */
  async checkTokenAllowance({
    accountAddress,
    tokenAddress,
    amount,
    spender,
  }: CheckTokenAllowance): Promise<boolean> {
    if (!tokenAddress) return true;
    const { contract } = await this.getContract(tokenAddress);
    const amountToSpend = ethers.utils.parseUnits(amount.toString(), await contract.decimals());
    // let allowance;
    console.log('checkTokenAllowance', { accountAddress, tokenAddress, amount, spender });
    // if (this.chainId == 66) {
    //   // OKX
    //   allowance = await this.getAllowanceOnOkx({ accountAddress, tokenAddress });
    //   allowance = ethers.BigNumber.from(allowance);
    // } else {
    //   // allowance = await this.getAllowanceOn1inch({ accountAddress, tokenAddress });
    //   // const spender = await this.get1inchRouterContractAddress();
    //   allowance = await contract.allowance(accountAddress, spender);
    // }

    const allowance = await contract.allowance(accountAddress, spender);

    console.log({
      allowanceNum: allowance.toString(),
      amountToSpendString: amountToSpend.toString(),
    });
    return allowance >= amountToSpend;
  }

  // async getAllowanceOn1inch({ accountAddress, tokenAddress }: any) {
  //   try {
  //     const {
  //       data: { allowance },
  //     } = await axios.get(`${this.oneinchApiBaseUrl}/${this.chainId}/approve/allowance`, {
  //       headers: {
  //         Accept: 'application/json',
  //         Authorization: `Bearer ${this.oneinchApiKey}`,
  //       },
  //       params: {
  //         tokenAddress: tokenAddress,
  //         walletAddress: accountAddress,
  //       },
  //     });
  //     console.log(allowance);
  //     return allowance;
  //   } catch (err) {
  //     throw err;
  //   }
  // }

  async getAllowanceOnOkx({ accountAddress, tokenAddress }: any) {
    try {
      const { data } = await axios.get(`${this.okxDexApiUrl}/get-allowance`, {
        params: {
          chainId: this.chainId,
          userWalletAddress: accountAddress,
          tokenContractAddress: tokenAddress,
        },
      });
      const allowance = data.data[0].allowanceAmount; // string "0"
      return allowance;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Broadcasts the txn on-chain.
   *
   * @param signer
   * @param txnObject - Txn object data to broadcast
   * @returns
   */
  async broadcastTransaction(
    signer: ethers.Wallet | ethers.providers.JsonRpcSigner,
    txnObject: Object
  ): Promise<TxnResponse> {
    try {
      const txn = await signer.sendTransaction(txnObject);
      // await txn.wait();
      return {
        success: true,
        data: {
          txnId: txn.hash,
          // @ts-ignore
          viewInExplorer: `${txnBaseUrl[this.chainName]}/${txn.hash}`,
          wait: txn.wait,
        },
      };
    } catch (error) {
      // throw error;
      return {
        success: false,
        message: 'Error signing transaction.',
      };
    }
  }

  /**
   * Helper function for creating contract instance
   *
   * Returns the contract instance
   *
   * TODO - add error handling for invalid erc20 contract addresss
   *
   * @param contractAddress - An account address.
   * @param abi - A asset contract address
   * @returns The contract instance.
   */
  async getContract(
    contractAddress: string,
    signer?: ethers.Wallet | ethers.providers.JsonRpcSigner,
    abi?: Object[]
  ): Promise<{ contract: ethers.Contract }> {
    try {
      const contractAbi = abi || erc20Abi;
      const contract = new ethers.Contract(
        contractAddress,
        contractAbi,
        signer ? signer : this.getProvider()
      );
      return {
        contract,
      };
    } catch (err) {
      throw new Error('Error making contract instance');
    }
  }

  async callContract(
    contractDetails: ContractDetails,
    signer: ethers.Wallet | ethers.providers.JsonRpcSigner
  ): Promise<TxnResponse> {
    try {
      const fromAddress = await signer.getAddress();
      const res = await this.createCallContractTxnObject(contractDetails, fromAddress);
      if (res.success && res?.txnObject) {
        const txnRes = await this.broadcastTransaction(signer, res?.txnObject);
        return txnRes;
      } else return res;
    } catch (error) {
      console.error('Error interacting with the contract:', error);
      throw error;
    }
  }

  async getCallContractFee(
    contractDetails: ContractDetails,
    fromAddress: string
  ): Promise<FeeResponse> {
    const res = await this.createCallContractTxnObject(contractDetails, fromAddress);
    if (res.success) {
      const fee = await this.getEstimateFee(res.txnObject as Object);
      return fee;
    } else {
      return res;
    }
  }

  async createCallContractTxnObject(
    contractDetails: ContractDetails,
    fromAddress: string
  ): Promise<TxnObjectResponse> {
    try {
      const { contractAddress, abi, functionName, args, value } = contractDetails;
      const { contract } = await this.getContract(contractAddress, undefined, abi);
      const { gasPrice, nonce } = await this.getGasDetailsAndNonce(fromAddress);

      // Invoke the contract function
      const txnObject = await contract.populateTransaction[functionName](...args, {
        value: value ? ethers.utils.parseEther(value.toString()) : 0,
        gasPrice,
        nonce,
      });

      // Handle the result
      console.log('createCallContractTxnObject', txnObject);
      return { success: true, txnObject: { ...txnObject, from: fromAddress } };
    } catch (error) {
      console.error(error);
      return { success: false, message: 'Error creating contract calling txn object' };
    }
  }

  async readContract(contractDetails: ContractDetails): Promise<ReadContractResponse> {
    try {
      const { contractAddress, abi, functionName, args } = contractDetails;
      const { contract } = await this.getContract(contractAddress, undefined, abi);

      // Invoke the contract function
      const data = await contract[functionName](...args);

      // Handle the result
      console.log('readContract', data);
      return { success: true, data };
    } catch (error) {
      console.error(error);
      return { success: false, message: 'Error reading contract', error };
    }
  }

  /**
   * Helper function for creating signer and getting nonce and gas
   *
   * @param privateKey - A private key.
   * @returns The signer, nonce, gas, gasPrice.
   */
  async getSigner(privateKey?: string) {
    const signer = privateKey
      ? new ethers.Wallet(privateKey, this.getProvider())
      : ((await getEthersSigner({ chainId: this.chainId })) as ethers.providers.JsonRpcSigner);

    // const { nonce, gasPrice, gasLimit } = await this.getGasDetailsAndNonce(
    //   await signer.getAddress()
    // );

    return {
      signer,
      // nonce,
      // gasPrice,
      // gasLimit,
    };
  }

  async getGasDetailsAndNonce(fromAddress: string) {
    const gasPrice = (await this.getProvider().getFeeData()).gasPrice; // await getProvider().getGasPrice();
    const gasLimit = 21000;
    const nonce = await this.getProvider().getTransactionCount(fromAddress);

    return {
      nonce,
      gasPrice,
      gasLimit,
    };
  }

  async signMessage(
    signer: ethers.Wallet | ethers.providers.JsonRpcSigner,
    message: string | ethers.utils.Bytes
  ): Promise<string> {
    const signature = await signer.signMessage(message);
    return signature;
  }

  async getTxnDetails(txnHash: string) {
    const txn = await this.getProvider().getTransactionReceipt(txnHash);
    return txn; // status -> 0,1
  }

  async isContractAddress(address: string) {
    try {
      const checkSumAddress = ethers.utils.getAddress(address);
      const code = await this.getProvider().getCode(checkSumAddress);
      if (code !== '0x') return true;
      else return false;
    } catch (error) {
      // throw error;
      return false;
    }
  }

  async isERC20Address(address: string) {
    try {
      const checkSumAddress = ethers.utils.getAddress(address);
      const { contract } = await this.getContract(checkSumAddress);
      await contract.balanceOf(checkSumAddress);
      await contract.decimals();
      await contract.totalSupply();
      return true;
    } catch (error) {
      console.log('Not erc20 contract');
      return false;
    }
  }

  async is1inchRouterContract(address: string) {
    try {
      const routerAddress = await this.get1inchRouterContractAddress();
      if (address.toLowerCase() === routerAddress.toLowerCase()) return true;
      else return false;
    } catch (error) {
      return false;
    }
  }

  async get1inchRouterContractAddress() {
    try {
      const {
        data: { address: routerAddress },
      } = await axios.get(`${this.triaApiBaseUrl}/chain/${this.chainId}/approve/spender`);
      return routerAddress;
    } catch (err) {
      throw new Error('Unable to fetch 1inch router contract address');
    }
  }

  async getSendNFTFee(
    fromAddress: string,
    recipientAddress: string,
    nftDetails: NFTDetails
  ): Promise<FeeResponse> {
    const res = await this.getSendNFTTxnObject(fromAddress, recipientAddress, nftDetails);
    if (res.success) {
      const fee = await this.getEstimateFee(res?.txnObject as Object);
      return fee;
    } else return res;
  }

  async sendNFT(
    signer: ethers.Wallet | ethers.providers.JsonRpcSigner,
    fromAddress: string,
    recipientAddress: string,
    nftDetails: NFTDetails
  ): Promise<TxnResponse> {
    const res = await this.getSendNFTTxnObject(fromAddress, recipientAddress, nftDetails);
    if (res.success) {
      const txnRes = await this.broadcastTransaction(signer, res?.txnObject as Object);
      return txnRes;
    } else return res;
  }

  async getSendNFTTxnObject(
    fromAddress: string,
    recipientAddress: string,
    { type, tokenAddress, tokenId, amount }: NFTDetails
  ): Promise<TxnObjectResponse> {
    let txnObject;
    const { gasPrice, nonce } = await this.getGasDetailsAndNonce(fromAddress);
    try {
      if (type == 'ERC1155') {
        const { contract } = await this.getContract(tokenAddress, undefined, erc1155ABI);
        txnObject = await contract.populateTransaction.safeTransferFrom(
          fromAddress,
          recipientAddress,
          tokenId,
          amount,
          '0x',
          {
            gasPrice,
            nonce,
          }
        );
      } else if (type == 'ERC721') {
        const { contract } = await this.getContract(tokenAddress, undefined, erc721ABI);
        txnObject = await contract.populateTransaction.safeTransferFrom(
          fromAddress,
          recipientAddress,
          tokenId,
          {
            gasPrice,
            nonce,
          }
        );
      } else {
        return { success: false, message: 'NFT type not mentioned' };
      }

      txnObject = { ...txnObject, from: fromAddress };

      return {
        success: true,
        txnObject,
      };
    } catch (err) {
      return {
        success: false,
        message: 'Error creating NFT send txn Object',
      };
    }
  }

  /**
   * Bali beta specific.
   * To redeem food coupons.
   *
   */
  async burnNFT(
    signer: ethers.Wallet | ethers.providers.JsonRpcSigner,
    { type, tokenAddress, tokenId, amount }: NFTDetails
  ): Promise<TxnResponse> {
    const fromAddress = await signer.getAddress();
    let txnObject;
    if (type == 'ERC1155') {
      try {
        const { contract } = await this.getContract(tokenAddress, undefined, CouponsABI);
        const { gasPrice, nonce } = await this.getGasDetailsAndNonce(fromAddress);
        txnObject = await contract.populateTransaction.burn(tokenId, amount, { gasPrice, nonce });
      } catch (err) {
        return { success: false, message: 'BURN not supported', error: err };
      }
    }
    //  else if (type == 'ERC721') {
    //   const { contract } = await this.getContract(tokenAddress, undefined, erc721ABI);
    //   txnObject = await contract.populateTransaction.burn(tokenId);
    // }
    else return { success: false, message: 'NFT type not supported.' };

    const txnRes = await this.broadcastTransaction(signer, txnObject as Object);
    return txnRes;
  }
}
