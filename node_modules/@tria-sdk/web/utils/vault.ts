import { ChaCha20Poly1305_Dcrypt, combine, decryptAES, generateSHA256 } from "./crypto";
import { shamir } from '../utils/crypto';
//@ts-ignore
import { Buffer } from '../core-lib/buffer';
import IPFSService from "../services/ipfs"
import ArweaveService from "../services/arweave"
import { AccountKeys, NONEvmAccountKeys } from "../types";
//@ts-ignore
import * as secrets from 'sss-tria';

export const reconstruct = async (tID: string, shadowHash: Buffer, apiUrl: string) => {
    try {
        const ipfs = new IPFSService(apiUrl);
        const arweave = new ArweaveService(apiUrl);
        const SHA256ShadowHash = generateSHA256(shadowHash.toString('hex'));
        console.log("1");
        const { keyLinkShare1IPNS, keyLinkShare2IPNS } = await ipfs.getKeyLinkShards(tID, SHA256ShadowHash);
        console.log("2");
        const pathShare1IPNS = await ipfs.resolveName(keyLinkShare1IPNS[0].keyLinkShare1IPNS);
        //console.log(pathShare1IPNS)
        console.log("3");
        const pathShare2IPNS = await ipfs.resolveName(keyLinkShare2IPNS[0].keyLinkShare2IPNS);
        //console.log(pathShare2IPNS)

        console.log("4");
        const keyLinkShare1Content = await ipfs.fetchIPFSData(pathShare1IPNS);
        console.log("5");
        const keyLinkShare2Content = await ipfs.fetchIPFSData(pathShare2IPNS);

        const encryptedKeyLink = combine([keyLinkShare1Content, keyLinkShare2Content]);
        //console.log(secrets.hex2str(encryptedKeyLink))
        const encryptedText = secrets.hex2str(encryptedKeyLink);
        console.log("decryptAES...")
        const decryptedData = await decryptAES(
            encryptedText.split(':')[1],
            shadowHash,
            Buffer.from(encryptedText.split(':')[0], 'hex'),
        );

        const keyLinks = JSON.parse(decryptedData);
        //console.log({ keyLinks });
        const vaultEncryptedShares: string[] = [];
        console.log("6");
        const vaultShare1IPNSPath = await ipfs.resolveName(keyLinks.ipns[0]);
        console.log("7");
        const vaultShare2IPNSPath = await ipfs.resolveName(keyLinks.ipns[1]);
        //console.log({ vaultShare1IPNSPath, vaultShare2IPNSPath })
        console.log("8");
        vaultEncryptedShares.push(JSON.parse(await ipfs.fetchIPFSData(vaultShare1IPNSPath))); 9
        console.log("9");
        vaultEncryptedShares.push(JSON.parse(await ipfs.fetchIPFSData(vaultShare2IPNSPath)));
        // console.log("vaultEncryptedShares1", vaultEncryptedShares);
        // console.log("keyLinks.arweaveTxId[0]", keyLinks.arweaveTxId[0]);
        // console.log("keyLinks.arweaveTxId[1]", keyLinks.arweaveTxId[1]);
        console.log("10");
        vaultEncryptedShares.push(await arweave.getData(keyLinks.arweaveTxId[0].id));
        console.log("11");
        vaultEncryptedShares.push(await arweave.getData(keyLinks.arweaveTxId[1].id));
        // console.log("vaultEncryptedShares2", vaultEncryptedShares);
        // console.log("keyLinks.ChaChaKey.data", keyLinks.ChaChaKey.data)
        const decryptedShares: string[] = [];
        console.log("chacha...")
        vaultEncryptedShares.map((encryptedShare) => {
            //@ts-ignore
            const parsedData = JSON.parse(JSON.stringify(encryptedShare));
            // console.log("parsedData", parsedData)
            decryptedShares.push(
                ChaCha20Poly1305_Dcrypt(
                    keyLinks.ChaChaKey.data,
                    parsedData.nonce,
                    new Uint8Array(Buffer.from(parsedData.encryptedShare, 'hex')),
                ),
            );
            // console.log(data)
        });

        const encryptedVault = combine(decryptedShares.slice(0, 3));
        const encryptedVaultText = secrets.hex2str(encryptedVault);
        // console.log("encryptedVaultText", encryptedVaultText)
        const decryptedVaultData = await decryptAES(
            encryptedVaultText.split(':')[1],
            shadowHash,
            Buffer.from(encryptedVaultText.split(':')[0], 'hex'),
        );
        const parsedDecryptedVaultData = JSON.parse(decryptedVaultData);
        // console.log({ parsedDecryptedVaultData });
        delete parsedDecryptedVaultData.keyPairs1;
        delete parsedDecryptedVaultData.keyPairs2;
        return {
            vault: parsedDecryptedVaultData
        };
    } catch (err) {
        console.log(err);
    }
}

export const shardNonEvmVaultKeys = async (nonEVMValut: AccountKeys): Promise<{ nonEvmShard1Vault: NONEvmAccountKeys, nonEvmShard2Vault: NONEvmAccountKeys }> => {
    let nonEvmShard1Vault: NONEvmAccountKeys = {};
    let nonEvmShard2Vault: NONEvmAccountKeys = {};

    for (let triaName of Object.keys(nonEVMValut)) {
        nonEvmShard1Vault[triaName] = {};
        nonEvmShard2Vault[triaName] = {};
        for (let chain of Object.keys(nonEVMValut[triaName])) {
            const privateKey = nonEVMValut[triaName][chain].privateKey;
            if (privateKey) {
                const pkShards = shamir(secrets.str2hex(privateKey), 2, 2);
                delete nonEVMValut[triaName][chain].privateKey;
                nonEvmShard1Vault[triaName][chain] = {
                    ...nonEVMValut[triaName][chain],
                    shard: pkShards[0]
                };
                nonEvmShard2Vault[triaName][chain] = {
                    ...nonEVMValut[triaName][chain],
                    shard: pkShards[1]
                };
            }
        }
    }
    // api request
    return { nonEvmShard1Vault, nonEvmShard2Vault };
}