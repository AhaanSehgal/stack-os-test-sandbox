export type WalletType = {
  embedded: boolean;
};

export type ENV = 'testnet' | 'mainnet-staging' | 'mainnet';

export interface TriaArgs {
  baseUrl: string;
  sentryDns?: string;
  walletType?: WalletType;
  selectedChainName?: string;
  environment?: ENV;
}

export interface InitParams {
  loginType?: 'social' | 'native' | 'otp';
  input?: string;
  socialName?: string;
  userId?: string;
  triaName?: string;
}

export interface Send {
  fromTriaName?: string;
  recipientTriaName: string;
  amount: number;
  tokenAddress?: string | number | Object;
}

export interface Approve {
  tokenAddress: string;
  amount: number;
  spender: string;
}

export interface CreateDIDArgs {
  did: string;
  evmChainData: EvmChainData;
  nonEvmChainsData: NonEvmChainsDatum[];
}
export interface CreateDIDResponse {
  success: boolean;
}

export interface ShardStorageArgs {
  hash: string;
  link: string;
}

export interface OAuthDataArgs {
  userOauthId: string;
  success: boolean;
  isPasswordRequired: boolean;
  password: string;
}

export interface ShardStorageResponse {
  success: boolean;
}

export interface ShardExistsResponse {
  success: boolean;
  response: boolean;
}

export interface Vault {
  triaName: string;
  mnemonic: string;
  evm: {
    address: string;
    privateKey: string;
  };
}

export type EvmChainData = {
  address: string;
  message: Message;
  signature: string;
};

export type Message = {
  address: string;
  timestamp: number;
};

export type NonEvmChainsDatum = {
  chainIndex: number;
  nonEvmAddress: string;
};

export interface Swap {
  triaName?: string;
  fromTokenAddress: string;
  toTokenAddress: string;
  fromAmount: number;
  slippage: number;
}

export interface Login {
  triaName: string;
  password: string;
  pin: string;
}

export interface Register {
  username: string;
  usernameExtension: string;
  passwordVerify: string;
  password: string;
  pin: string;
}

export interface UpdateSubNameArgs {
  password: string;
  pin: string;
  oldSubName: string;
  newSubName: string;
}

export interface RemoveAddressArgs {
  subname: string;
  password: string;
  pin: string;
}

export interface UpdatePassword {
  oldPassword: string;
  newPassword: string;
  pin: string;
}

export interface UpdatePin {
  oldPin: string;
  newPin: string;
  password: string;
}

export interface ResolveTriaName {
  lookUpTriaName: string;
  chainName: string;
}

export interface AccountKeys {
  [index: string]: {
    [index: string]: Key;
  };
}

export interface Key {
  address?: string;
  privateKey?: string;
  publicKey?: string;
}

export interface NONEvmAccountKeys {
  [index: string]: {
    [index: string]: sharKey;
  };
}

export interface AddNonEvmShards {
  accountKeys: NONEvmAccountKeys;
}

export interface sharKey {
  address?: string;
  shard?: string;
  publicKey?: string;
}

export interface ReconstructResponse {
  success: boolean;
}

export interface SocialLoginResponse {
  success: boolean;
  data: any;
}
export interface UpdatedWalletAddresses {
  list: UpdatedWalletInfoList;
  success: boolean;
}

export interface AddWalletResponse {
  list: UpdatedWalletInfoList;
  success: boolean;
}

interface UpdatedWalletInfoList extends Array<WalletInfo> {}
interface WalletInfo {
  creationMethod: CreationMethod;
  addresses: AddressList;
}
interface AddressList extends Array<Address> {}
interface Address {
  subname: Nullable<string>;
  address: string;
  isDeleted: Nullable<boolean>;
  chain: string;
}
enum CreationMethod {
  Onboarding = 1, // start from 1 not from zero, because it is falsy
  ManualCreation = 2,
  ManualImport = 3,
}
type Nullable<T> = T | undefined | null;

export interface ExportPrivateKeyResponse {
  success: boolean;
  privateKey: string | null;
}

export interface ExportMnemonicResponse {
  success: boolean;
  mnemonic: string | null;
}

export interface FeeResponse {
  success: boolean;
  fee?: {
    eth: string;
    usd?: string;
  };
  message?: string;
  error?: any;
}

export interface CheckTokenAllowanceResponse {
  success: boolean;
  allowance?: boolean;
  message?: string;
}

export interface TxnObjectResponse {
  success: boolean;
  txnObject?: Object;
  message?: string;
}

export interface TxnResponse {
  success: boolean;
  data?: {
    txnId: string;
    viewInExplorer: string;
    wait: Function;
  };
  message?: string;
  error?: any;
}

export interface TxnResponseSuccess {
  success: boolean;
  data?: {
    txnId: string;
    viewInExplorer: string;
  };
  message?: string;
  error?: any;
}

export interface ReadContractResponse {
  success: boolean;
  data?: any;
  message?: string;
  error?: any;
}

export interface SwapTargetResponse {
  name: string;
  symbol: string;
  tokenAddress: string | null;
  logoUrl: string;
}

export interface NFTDetails {
  type: string;
  tokenAddress: string;
  tokenId: string;
  amount: number;
}

export interface NFTDetail {
  type: string;
  tokenAddress: string;
  tokenUri: string;
}

export interface checkDIDResponse {
  success: boolean;
  response: {
    did: string;
    availabilityStatus: boolean;
  };
}

export interface ContractDetails {
  contractAddress: string;
  abi: Object[];
  functionName: string;
  args: any[];
  value?: number;
}

export interface KeyringControllerInterface {
  apiUrl: string;
  reconstruct(password: string, pin: string): Promise<ReconstructResponse>;
  addWallet(password: string, pin: string, chainName: string): Promise<UpdatedWalletAddresses>;
  // getTotalBalance(triaName: string): Promise<void>;

  getSendFee(chainName: string, payload: Send): Promise<FeeResponse>;
  send(pin: string, chainName: string, payload: Send): Promise<TxnResponse>;

  updateSubName(args: UpdateSubNameArgs): Promise<UpdatedWalletAddresses>;
  removeAddress(args: RemoveAddressArgs): Promise<UpdatedWalletAddresses>;

  checkTokenAllowance(
    triaName: string,
    chainName: string,
    tokenAddress: string | null,
    amount: number
  ): Promise<CheckTokenAllowanceResponse>;
  getApproveFee(
    triaName: string,
    chainName: string,
    tokenAddress: string,
    amount: number
  ): Promise<FeeResponse>;
  approve(
    pin: string,
    triaName: string,
    chainName: string,
    tokenAddress: string,
    amount: number
  ): Promise<TxnResponse>;

  getSwapTargets(
    chainName: string,
    fromTokenAddress: string | null,
    listLength: number,
    query?: string
  ): Promise<SwapTargetResponse[]>;
  getSwapFee(chainName: string, payload: Swap): Promise<FeeResponse>;
  swap(pin: string, chainName: string, payload: Swap): Promise<TxnResponse>;
  resolveTriaName(triaName: string, chainName: string): Promise<string>;
  exportMemonic(password: string, pin: string): Promise<ExportMnemonicResponse>;
  exportPrivateKey(
    triaName: string,
    password: string,
    pin: string,
    chainName: string
  ): Promise<ExportPrivateKeyResponse>;
  getSendNFTFee(
    chainName: string,
    fromTriaName: string,
    recipientTriaName: string,
    nftDetails: NFTDetails
  ): Promise<FeeResponse>;
  sendNFT(
    pin: string,
    chainName: string,
    fromTriaName: string,
    recipientTriaName: string,
    nftDetails: NFTDetails
  ): Promise<TxnResponse>;
  /** Bali beta specific */
  burnNFT(
    pin: string,
    chainName: string,
    fromTriaName: string,
    nftDetails: NFTDetails
  ): Promise<TxnResponse>;
  claimNFT(
    pin: string,
    chainName: string,
    fromTriaName: string,
    nftDetails: NFTDetails
  ): Promise<TxnResponse>;
  createNFT(
    pin: string,
    chainName: string,
    fromTriaName: string,
    nftDetail: NFTDetail
  ): Promise<TxnResponse>;
}
