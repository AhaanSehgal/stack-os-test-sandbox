import { isChainSupported } from '@tria-sdk/core';
import {
  Approve,
  ContractDetails,
  ENV,
  NFTDetails,
  ReadContractResponse,
  Send,
  Swap,
  TriaArgs,
  TxnResponse,
  TxnResponseSuccess,
} from '../types';
import { checksumAddress } from '../utils/helper/checksum';
import { isValidAddress } from '../utils/helper/isValidAddress';
import { ApprovePayload, SendPayload, SwapPayload } from '../types/chain';
import { KeyringController } from './keyring.controller';

// 1. Extending Keyring only for memStore for tempVault in embedded wallet case, and getSigner function

export class WalletController extends KeyringController {
  selectedChainName: string | undefined;

  constructor({ baseUrl, walletType, selectedChainName, environment = 'mainnet' }: TriaArgs) {
    super({ baseUrl, walletType, selectedChainName, environment });
    if (isChainSupported(selectedChainName as string))
      this.selectedChainName = selectedChainName as string;
  }

  async signMessage(message: string, chainName?: string) {
    try {
      const { signer, chainInstance, triaName } = await this.getSigner(
        (this.selectedChainName || chainName) as string
      );
      console.log({ signer });
      // @ts-ignore
      const res = await chainInstance.signMessage(signer, message);

      if (this.walletType?.embedded) {
        this.postMessage({
          type: 'Sign Message',
          success: true,
          data: { triaName, message, signature: res },
        });
      }

      return res;
    } catch (err: any) {
      console.error(err);
      if (this.walletType?.embedded) {
        this.postMessage({
          type: 'Sign Message',
          success: false,
          data: { message: err.message || 'Error signing message!' },
        });
      }
    }
  }

  async waitForTransaction(txn: TxnResponse): Promise<TxnResponseSuccess> {
    await txn?.data?.wait();
    if (this.walletType?.embedded) {
      this.postMessage({
        type: 'Send',
        success: true,
        data: { res: txn as TxnResponseSuccess },
      });
    }
    return txn as TxnResponseSuccess;
  }

  async send(payload: Send, chainName?: string): Promise<TxnResponse> {
    if (payload.amount <= 0) return { success: false, message: 'Invalid amount' };

    const chain = (this.selectedChainName || chainName) as string;

    const { signer, chainInstance, triaName, address: fromAddress } = await this.getSigner(chain);
    console.log({ payload });

    if (isChainSupported(chain)) {
      const { recipientTriaName } = payload;
      let recipientAddress;

      if (!recipientTriaName.includes('@tria') && isValidAddress(recipientTriaName))
        recipientAddress = checksumAddress(payload.recipientTriaName);
      else recipientAddress = await this.resolveTriaName(payload.recipientTriaName, chain);

      const sendPayload: SendPayload = {
        signer, // half shard // hex string
        recipientAddress,
        fromAddress,
        amount: payload.amount,
        tokenAddress: payload.tokenAddress,
      };
      const res = await chainInstance.send(sendPayload);
      if (res.success)
        this.userService.addUserActivity(
          (triaName || payload.fromTriaName) as string,
          recipientTriaName
        );
      return res;
    } else {
      return { success: false, message: 'Chain not supported.' };
    }
  }

  async approve(payload: Approve, chainName?: string): Promise<TxnResponse> {
    const { amount, tokenAddress, spender } = payload;
    if (amount <= 0) return { success: false, message: 'Invalid amount' };

    const chain = (this.selectedChainName || chainName) as string;

    const { signer, chainInstance, address: fromAddress } = await this.getSigner(chain);

    //@ts-ignore
    const res = await chainInstance?.approve({
      signer,
      fromAddress,
      tokenAddress,
      amount,
      spender,
    } as ApprovePayload);
    return res;
  }

  async swap(payload: Swap, chainName?: string): Promise<TxnResponse> {
    if (payload.fromAmount <= 0) return { success: false, message: 'Invalid amount' };

    const chain = (this.selectedChainName || chainName) as string;

    const { signer, chainInstance, address: fromAddress } = await this.getSigner(chain);

    const swapPayload: SwapPayload = {
      signer, // privateKey shard
      fromAddress,
      fromTokenAddress: payload.fromTokenAddress,
      toTokenAddress: payload.toTokenAddress,
      amount: payload.fromAmount,
      slippage: payload.slippage || 1, // default 1%
    };
    // @ts-ignore
    const res = await chainInstance?.swap(swapPayload);
    return res;
    /** API call /swap (chainName, swapPayload) */
    // const tx = this.nonEVMService.swap("SHARD1", "CHAINAME", "PAYLOAD");
  }

  async sendNFT(
    recipientTriaName: string,
    nftDetails: NFTDetails,
    chainName?: string
  ): Promise<TxnResponse> {
    if (nftDetails.amount <= 0) return { success: false, message: 'Invalid amount' };

    const chain = (this.selectedChainName || chainName) as string;

    const { signer, chainInstance, address: fromAddress } = await this.getSigner(chain);

    if (isChainSupported(chain)) {
      let recipientAddress;

      if (!recipientTriaName.includes('@tria') && isValidAddress(recipientTriaName))
        recipientAddress = checksumAddress(recipientTriaName);
      else recipientAddress = await this.resolveTriaName(recipientTriaName, chain);

      // @ts-ignore
      const res = await chainInstance?.sendNFT(signer, fromAddress, recipientAddress, nftDetails);
      return res;
    } else {
      return { success: false, message: 'Chain not supported.' };
    }
  }

  /**
   * Bali beta specific
   *
   */
  async burnNFT(nftDetails: NFTDetails, chainName?: string): Promise<TxnResponse> {
    if (nftDetails.amount <= 0) return { success: false, message: 'Invalid amount' };
    const chain = (this.selectedChainName || chainName) as string;
    const { signer, chainInstance } = await this.getSigner(chain);
    if (isChainSupported(chain)) {
      // @ts-ignore
      const res = await chainInstance?.burnNFT(signer, nftDetails);
      return res;
    } else {
      return { success: false, message: 'Chain not supported.' };
    }
  }

  /**
   * Interact with any external contract
   * @param contractDetails
   * @param chainName
   * @returns
   */
  async callContract(contractDetails: ContractDetails, chainName?: string): Promise<TxnResponse> {
    const chain = (this.selectedChainName || chainName) as string;
    const { signer, chainInstance } = await this.getSigner(chain);
    if (isChainSupported(chain)) {
      // @ts-ignore
      const res = await chainInstance?.callContract(contractDetails, signer);
      return res;
    } else {
      return { success: false, message: 'Chain not supported.' };
    }
  }

  async readContract(
    contractDetails: ContractDetails,
    chainName?: string
  ): Promise<ReadContractResponse> {
    const chain = (this.selectedChainName || chainName) as string;
    const chainInstance = this.chains[chain];
    if (isChainSupported(chain)) {
      // @ts-ignore
      const res = await chainInstance?.readContract(contractDetails);
      return res;
    } else {
      return { success: false, message: 'Chain not supported.' };
    }
  }
}
