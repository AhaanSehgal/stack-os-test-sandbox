import { Multichain } from '../utils/helper/multichain';
import {
  CheckTokenAllowanceResponse,
  SwapTargetResponse,
  FeeResponse,
  TriaArgs,
  Send,
  Swap,
  NFTDetails,
  ContractDetails,
  Approve,
  ENV,
} from '../types';
import WalletService from '../services/wallet';
import { isChainSupported } from '@tria-sdk/core';
import { checksumAddress } from '../utils/helper/checksum';
import { isValidAddress } from '../utils/helper/isValidAddress';

export class FeeController extends Multichain {
  apiUrl: string;
  walletService: WalletService;
  selectedChainName: string | undefined;
  environment: ENV;

  /**
   * Constructs a new instance of the Tria class.
   * @param apiUrl - The URL of the API.
   */
  constructor({ baseUrl, walletType, selectedChainName, environment = 'mainnet' }: TriaArgs) {
    super(baseUrl, walletType);
    this.apiUrl = baseUrl;
    this.walletService = new WalletService(this.apiUrl);
    if (isChainSupported(selectedChainName as string))
      this.selectedChainName = selectedChainName as string;
    this.environment = environment;
  }

  /**
   * @param triaName triaName
   * @param chainName chainName
   */

  async resolveTriaName(triaName: string, chainName: string): Promise<string> {
    const res = await this.walletService.resolveTriaName(
      { chainName, lookUpTriaName: triaName },
      this.environment
    );
    return res.address;
  }

  async checkTokenAllowance(
    triaName: string,
    chainName: string,
    payload: Approve
  ): Promise<CheckTokenAllowanceResponse> {
    const chain = (this.selectedChainName || chainName) as string;
    const { tokenAddress, amount, spender } = payload;
    if (amount <= 0) return { success: false, message: 'Invalid amount' };
    if (!tokenAddress) return { success: true, allowance: true };
    const address = await this.resolveTriaName(triaName, chain);
    // @ts-ignore
    const res = await this.chains[chain]?.checkTokenAllowance({
      accountAddress: address,
      tokenAddress,
      amount,
      spender,
    });
    return { success: true, allowance: res };
  }

  async getSendFee(chainName: string, payload: Send): Promise<FeeResponse> {
    const chain = (this.selectedChainName || chainName) as string;
    if (payload.amount <= 0) return { success: false, message: 'Invalid amount' };
    console.log('getSendFee ', { chain, payload });

    if (isChainSupported(chain)) {
      const fromAddress = await this.resolveTriaName(payload?.fromTriaName as string, chain);

      const { recipientTriaName } = payload;
      let recipientAddress;

      if (!recipientTriaName.includes('@tria') && isValidAddress(recipientTriaName))
        recipientAddress = checksumAddress(payload.recipientTriaName);
      else recipientAddress = await this.resolveTriaName(payload.recipientTriaName, chain);

      // const recipientAddress = await this.resolveTriaName(payload.recipientTriaName, chain);

      const res = await this.chains[chain].getSendFee(
        fromAddress,
        recipientAddress,
        payload.amount,
        payload?.tokenAddress as string
      );
      return res;
    } else {
      return { success: false, message: 'Chain not supported' };
    }
  }

  async getApproveFee(triaName: string, chainName: string, payload: Approve): Promise<FeeResponse> {
    const chain = (this.selectedChainName || chainName) as string;
    const { amount, tokenAddress, spender } = payload;
    if (amount <= 0) return { success: false, message: 'Invalid amount' };
    const fromAddress = await this.resolveTriaName(triaName, chain);
    // @ts-ignore
    const res = await this.chains[chain]?.getApproveFee(fromAddress, tokenAddress, amount, spender);
    return res;
  }

  async getCallContractFee(
    triaName: string,
    chainName: string,
    contractDetails: ContractDetails
  ): Promise<FeeResponse> {
    const chain = (this.selectedChainName || chainName) as string;
    const fromAddress = await this.resolveTriaName(triaName, chain);
    // @ts-ignore
    const res = await this.chains[chain]?.getCallContractFee(contractDetails, fromAddress);
    return res;
  }

  async getSwapTargets(
    chainName: string,
    fromTokenAddress: string | null,
    listLength: number,
    query?: string
  ): Promise<SwapTargetResponse[]> {
    const chain = (this.selectedChainName || chainName) as string;
    // @ts-ignore
    const res = await this.chains[chain]?.getSwapTargets(fromTokenAddress, listLength, query);
    return res;
  }

  async getSwapFee(chainName: string, payload: Swap): Promise<FeeResponse> {
    const chain = (this.selectedChainName || chainName) as string;
    if (payload.fromAmount <= 0) return { success: false, message: 'Invalid amount' };
    const fromAddress = await this.resolveTriaName(payload?.triaName as string, chain);
    const { fromTokenAddress, toTokenAddress, fromAmount, slippage } = payload;
    // @ts-ignore
    const res = await this.chains[chain]?.getSwapFee(
      fromAddress,
      fromTokenAddress,
      toTokenAddress,
      fromAmount,
      slippage
    );
    return res;
  }

  async getSendNFTFee(
    chainName: string,
    fromTriaName: string,
    recipientTriaName: string,
    nftDetails: NFTDetails
  ): Promise<FeeResponse> {
    const chain = (this.selectedChainName || chainName) as string;
    if (nftDetails.amount <= 0) return { success: false, message: 'Invalid amount' };
    if (isChainSupported(chain)) {
      const fromAddress = await this.resolveTriaName(fromTriaName, chain);
      let recipientAddress;
      if (!recipientTriaName.includes('@tria') && isValidAddress(recipientTriaName))
        recipientAddress = checksumAddress(recipientTriaName);
      else recipientAddress = await this.resolveTriaName(recipientTriaName, chain);

      // @ts-ignore
      const res = await this.chains[chain]?.getSendNFTFee(
        fromAddress,
        recipientAddress,
        nftDetails
      );
      return res;
    } else if (isChainSupported(chain)) {
      return { success: false, message: 'Chain not supported' };
    } else {
      return { success: false, message: 'Chain not supported' };
    }
  }
}
