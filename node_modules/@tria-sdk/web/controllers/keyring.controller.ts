import { PersistStorage } from '../storage/storage';
import WalletService from '../services/wallet';
import UserService from '../services/user';
import {
  RemoveAddressArgs,
  TriaArgs,
  UpdateSubNameArgs,
  ReconstructResponse,
  AddWalletResponse,
  ExportMnemonicResponse,
  ExportPrivateKeyResponse,
  UpdatedWalletAddresses,
  KeyringControllerInterface,
  SocialLoginResponse,
  Vault,
  EvmChainData,
  CreateDIDResponse,
  ShardStorageResponse,
  OAuthDataArgs,
  InitParams,
  ShardExistsResponse,
  ENV,
} from '../types';

import generatePassword from 'generate-password';

//@ts-ignore
import ObservableStore from 'obs-store';
import {
  generateShadowHash,
  decryptAES,
  encryptAES256,
  shamir,
  generateSHA256,
  combine,
} from '../utils/crypto';
import { reconstruct, shardNonEvmVaultKeys } from '../utils/vault';
import {
  VAULT,
  NON_EVM_LIST,
  NON_EVM_VAULT,
  KEY_STORE,
  TEMP_MEM_STORE,
  KSTORE,
  getConfigForShardStorage,
} from '../utils/constants';
import NONEVMService from '../services/nonevm';
import AuthService from '../services/auth';
import { filterNonEVM } from '../utils/helper';
//@ts-ignore
import crypto from '../core-lib/crypto';
import { Multichain } from '../utils/helper/multichain';
//@ts-ignore
import { Buffer } from '../core-lib/buffer';
import * as bip39 from 'bip39';
import dscAbi from '../interfaces/abis/dsc.json';

import { ethers } from 'ethers';
//@ts-ignore
import * as secrets from 'sss-tria';
import { fetchContent, pinToIpfs } from '../utils/ipfs';
import DIDService from '../services/did';
import { AuthController, isEvmChain } from '@tria-sdk/core';
import * as Sentry from '@sentry/browser';
import { Integrations } from '@sentry/tracing';

// 1. Extending Multichain only for getSigner for evmChainData for did creation
export class KeyringController extends Multichain {
  // implements KeyringControllerInterface
  apiUrl: string;
  memStore: ObservableStore<Object>;
  store: PersistStorage;
  nonEVMService: NONEVMService;
  walletService: WalletService;
  userService: UserService;
  didService: DIDService;
  authController: AuthController;
  environment: ENV;

  /**
   * Constructs a new instance of the Tria class.
   * @param apiUrl - The URL of the API.
   */
  constructor({ baseUrl, walletType, sentryDns, environment }: TriaArgs) {
    super(baseUrl, walletType);
    this.apiUrl = baseUrl;
    this.store = new PersistStorage();
    this.nonEVMService = new NONEVMService(this.apiUrl);
    this.walletService = new WalletService(this.apiUrl);
    this.userService = new UserService(this.apiUrl);
    this.didService = new DIDService(this.apiUrl);
    this.authController = new AuthController(this.apiUrl);
    this.environment = environment || 'mainnet';

    if (sentryDns) {
      console.log('sentryDns', sentryDns);
      Sentry.init({
        dsn: sentryDns,
        release: 'tria-sdk/web',
        integrations: [new Sentry.BrowserTracing(), new Sentry.Replay()],
        tracesSampleRate: 1.0,
        tracePropagationTargets: ['localhost', /^https:\/\/yourserver\.io\/api/],
        replaysSessionSampleRate: 0.1,
        replaysOnErrorSampleRate: 1.0,
      });
    }
    // const oldMemData = this.store.getValue(TEMP_MEM_STORE);
    // this.store.removeValue(TEMP_MEM_STORE);
  }

  async init() {
    const init = this.store.getValue('init');
    const { loginType, triaName, socialName, userId, input }: InitParams = init;
    const tempVault = this.store.getValue('tempVault');
    const accessToken = this.store.getValue('accessToken');
    console.log('tempVault', tempVault);
    if (tempVault) {
      const data = await this.authController.getKey(accessToken);
      try {
        const cipherText = tempVault.split(':')[1];
        const iv = tempVault.split(':')[0];
        const decryptedVault = await decryptAES(
          cipherText,
          Buffer.from(data.key, 'hex'),
          Buffer.from(iv, 'hex')
        );
        this.memStore = new ObservableStore(decryptedVault);
        const { hashLocalKey, shard2LocalKey } = this.getLocalKeys({
          loginType,
          triaName,
          socialName,
          userId,
          input,
        });
        if (this.store.getValue(hashLocalKey)) {
          this.deleteShardAfterSaved({
            hash: this.store.getValue(hashLocalKey),
            localStorageKeyForHash: hashLocalKey,
            localStorageKeyForShard2: shard2LocalKey,
          });
        }
        console.log('this.memStore', JSON.parse(this.memStore.getState()));
      } catch (err) {
        console.log('err', err);
        throw err;
      }
    } else {
      this.memStore = new ObservableStore({
        vault: {},
      });
    }
  }

  async fullUpdate(password: string, pin: string) {
    await this.reconstruct(password, pin);
    const addresses = await this.userService.getAllAddresses();
    return addresses;
  }

  getLocalKeys({ loginType, triaName, socialName, userId, input }: InitParams) {
    switch (loginType) {
      case 'native':
        if (triaName) {
          const shard2LocalKey = `${triaName}:native:$2`;
          const hashLocalKey = `${triaName}:native:hash`;
          return { shard2LocalKey, hashLocalKey };
        } else {
          throw new Error('TriaName Required for native');
        }
      case 'otp':
        if (input) {
          const shard2LocalKey = `${input}:otp:$2`;
          const hashLocalKey = `${input}:otp:hash`;
          return { shard2LocalKey, hashLocalKey };
        } else {
          throw new Error('Input Required for Otp creation method');
        }
      case 'social':
        if (socialName && userId) {
          const shard2LocalKey = `${socialName}:${userId}:$2`;
          const hashLocalKey = `${socialName}:${userId}:hash`;
          return { shard2LocalKey, hashLocalKey };
        } else {
          throw new Error('socialName && userId Social method');
        }
      default:
        throw new Error(`Invalid Login Type: ${loginType}`);
    }
  }

  generateNewPassword() {
    const newPassword = generatePassword.generate({
      length: 12, // Adjust the desired length
      numbers: true, // Include numbers
      symbols: true, // Include special characters
      uppercase: true, // Include uppercase letters
      excludeSimilarCharacters: true, // Exclude similar characters (e.g., 'i', 'l', '1', 'L', etc.)
    });

    return newPassword;
  }

  /**
   * @version 2
   * @description use to generate the vault so that it can be call sepreately for DID creation
   */
  async generateVault(
    triaName: string,
    importedMnemonic?: string
  ): Promise<{ vault: Vault; publicVault: any }> {
    try {
      console.log(triaName, importedMnemonic);
      console.log('generating mnemonic');
      const mnemonic = importedMnemonic || bip39.generateMnemonic();
      console.log('mnemonic');
      // const mnemonic = 'design large bone swallow frost wisdom evoke bike lunch okay report tomato';
      const wallet = ethers.Wallet.fromMnemonic(mnemonic, `m/44'/60'/0'/0/0`);
      const publicVault = { triaName, evm: { address: wallet.address } };
      const vault = {
        triaName: triaName,
        mnemonic: mnemonic,
        evm: {
          address: wallet.address,
          privateKey: wallet.privateKey,
        },
      };
      return { vault, publicVault };
    } catch (err) {
      console.log(err);
      //@ts-ignore
      Sentry.captureException(new Error(err.message), {
        tags: { key: 'generateVault' },
      });
      throw err;
    }
  }

  async getSigner(chainName: string, privateKey?: string) {
    const chainInstance = this.chains[chainName];
    let signer, triaName, address;
    if (this.walletType?.embedded || !this.walletType) {
      console.log('embedded walet with password');
      if (!privateKey) {
        ({ privateKey, triaName, address } = await this.#resolveTriaName(chainName));
        console.log({ privateKey });
      }
      // @ts-ignore
      ({ signer } = await chainInstance.getSigner(privateKey));
    } else {
      // @ts-ignore
      ({ signer } = await chainInstance.getSigner());
      address = await signer.getAddress();
      triaName = null;
    }
    return { signer, chainInstance, triaName, address };
  }

  /**
   * @version 2
   * @description use to generate the evmChainData for did
   */
  async generateEVMChainData(vault: Vault): Promise<EvmChainData> {
    const evmAddress = ethers.utils.getAddress(vault.evm.address);
    const evmMessage = {
      address: evmAddress,
      timestamp: new Date().getTime(),
    };

    const chainName = this.environment == 'testnet' ? 'MUMBAI' : 'POLYGON';
    const { signer, chainInstance } = await this.getSigner(chainName, vault?.evm?.privateKey);

    // @ts-ignore
    const signature = await chainInstance.signMessage(signer, JSON.stringify(evmMessage));

    return {
      address: evmAddress,
      message: evmMessage,
      signature,
    } as EvmChainData;
  }

  /**
   * @version 2
   * @description native wallet creation using triaName and password
   * @todo Push shard to contract using relayer
   */

  async createAccount({
    triaName,
    password,
    mnemonic,
    origin,
  }: {
    triaName: string;
    password: string;
    mnemonic?: string;
    origin?: string;
  }) {
    try {
      if (!triaName && !password) {
        throw Error('TriaName and Password Required');
      }
      //checking DID exist or not
      let isAvailable = await this.didService.checkDID(triaName);
      if (!isAvailable) {
        throw Error('DID not Available!');
      }

      const { vault, publicVault } = await this.generateVault(triaName, mnemonic);

      const evmChainData = await this.generateEVMChainData(vault);

      // DID creation
      const args = {
        did: triaName,
        evmChainData: evmChainData,
        nonEvmChainsData: [],
      };
      let res = (await this.didService.createDID(args)) as CreateDIDResponse;
      if (!res.success) {
        throw Error('DID creation failed!');
      }
      const dsc_key = generateSHA256(`${triaName}:${password}`);
      const shard1LocalKey = `${triaName}:native:$1`;
      const shard2LocalKey = `${triaName}:native:$2`;
      const hashLocalKey = `${triaName}:native:hash`;
      const ress = await this.shardAndPushTheVault({
        vault: vault,
        dsc_hash: dsc_key,
        password: password,
        shard1LocalKey: shard1LocalKey,
        shard2LocalKey: shard2LocalKey,
        hashLocalKey: hashLocalKey,
      });
      // shard management
      // will replace this my secure random number

      if (ress.success) {
        this.storeInTriaStore(publicVault);
        this.store.setValue(
          'init',
          JSON.stringify({ loginType: 'native', triaName, socialName: '', userId: '', input: '' })
        );
        this.postMessage({
          type: 'Tria Sign up',
          success: true,
          data: publicVault,
        });
        this.storeConnectedAppInSession(origin);
        await this.deleteShardAfterSaved({
          hash: dsc_key,
          localStorageKeyForShard2: shard2LocalKey,
          localStorageKeyForHash: hashLocalKey,
        });
        // await this.generateUserSession({ vault: vault });
        return { success: true, data: publicVault };
      } else {
        throw ress.error;
      }
    } catch (err: any) {
      console.error(err);
      //@ts-ignore
      Sentry.captureException(new Error(err.message), {
        tags: { key: 'createAccount' },
      });
      this.postMessage({
        type: 'Tria Sign up',
        success: false,
        data: { triaName, message: err.message || 'Error signing up, please try again!' },
      });
      throw err;
    }
  }

  /**
   * @version 2
   * @description For wallet creation using socails
   * @todo verify user already exist ONCHAIN
   * @todo Push shard to contract using relayer
   */
  async socialogin({
    triaName,
    password,
    platform,
    userId,
    isPasswordLess,
    accessToken,
    origin,
  }: {
    triaName: string;
    password: string;
    platform: string;
    userId: string;
    accessToken: string;
    isPasswordLess: boolean;
    origin?: string;
  }): Promise<SocialLoginResponse> {
    try {
      console.log('keyring socialogin', { triaName, password, platform, userId, isPasswordLess });
      let isAvailable = await this.didService.checkDID(triaName);
      if (!isAvailable) {
        throw Error('DID not Available!');
      }
      if (isPasswordLess) {
        password = this.generateNewPassword();
        console.log('generated password', password);
      }
      const { vault, publicVault } = await this.generateVault(triaName);
      const evmChainData = await this.generateEVMChainData(vault);

      // DID creation
      const args = {
        did: triaName,
        evmChainData: evmChainData,
        nonEvmChainsData: [],
      };
      let res = (await this.didService.createDID(args)) as CreateDIDResponse;
      if (!res.success) {
        throw Error('DID creation failed!');
      }
      const dsc_key = generateSHA256(`${userId}:${password}`);
      const shard1LocalKey = `${platform}:${userId}:$1`;
      const shard2LocalKey = `${platform}:${userId}:$2`;
      const hashLocalKey = `${platform}:${userId}:hash`;
      // const oauthData: OAuthDataArgs = {
      //   userOauthId: userId,
      //   success: true,
      //   isPasswordRequired: !isPasswordLess,
      //   password: isPasswordLess ? password : '',
      // };
      const ress = await this.shardAndPushTheVault({
        vault: vault,
        dsc_hash: dsc_key,
        password: password,
        shard1LocalKey: shard1LocalKey,
        shard2LocalKey: shard2LocalKey,
        hashLocalKey: hashLocalKey,
      });
      console.log('userId', userId);
      const triaNameHash = generateSHA256(triaName);
      await this.authController.saveOauthUser({
        triaNameHash: triaNameHash,
        userOauthId: userId,
        isPasswordRequired: !isPasswordLess,
        password: isPasswordLess ? password : '',
        platform: platform,
        accessToken: accessToken,
      });
      if (ress.success) {
        this.storeInTriaStore(publicVault);
        this.store.setValue(
          'init',
          JSON.stringify({ loginType: 'social', triaName, socialName: platform, userId, input: '' })
        );
        this.postMessage(
          {
            type: 'Social Sign up',
            success: true,
            data: publicVault,
          },
          true
        );
        this.storeConnectedAppInSession(origin);
        await this.generateUserSession({ vault: vault, accessToken: accessToken });
        return { success: true, data: vault.evm.address };
      } else {
        throw ress.error;
      }
    } catch (err: any) {
      console.error(err);
      //@ts-ignore
      Sentry.captureException(new Error(err.message), {
        tags: { key: 'socialogin' },
      });
      this.postMessage(
        {
          type: 'Social Sign up',
          success: false,
          data: { triaName, message: err.message || 'Error signing up, please try again!' },
        },
        true
      );
      return { success: false, data: null };
    }
  }

  /**
   * @description Get the account
   * @param triaName triaName for native users
   * @param password password required for encrypt/decrypt in native case user will enter password and in all other case tria managing
   * @param userId In social login
   * @param socialName platform name twitter, google ...
   * @param input email or phone number in case of OTP login otherwise provide null
   * @param hash hash from the server in case of OTP login
   */
  async getVault({
    triaName,
    password,
    userId,
    socialName,
    input,
    hash,
    link,
    native,
    origin,
    accessToken,
  }: {
    triaName?: string;
    password: string;
    userId?: string;
    socialName?: string | null;
    input?: string | null;
    hash?: string | null;
    link?: boolean;
    native?: boolean;
    origin?: string;
    accessToken?: string;
  }): Promise<{ exists: boolean; data: Vault | null }> {
    try {
      console.log({
        triaName,
        password,
        userId,
        socialName,
        input,
        hash,
        link,
        native,
        origin,
      });
      //console.log(`${userId || triaName}:${password}`);
      let dsc_key;
      if (userId) {
        dsc_key = generateSHA256(`${userId}:${password}`);
      } else if (triaName && native) {
        dsc_key = generateSHA256(`${triaName}:${password}`);
      } else if (input) {
        dsc_key = hash;
      }
      let salt;
      console.log('input && link', input && link);
      console.log('input && link', link);
      if (userId) salt = this.store.getValue(`SALT:${socialName}:${userId}:$`);
      else if (triaName && native) salt = this.store.getValue(`SALT:${triaName}:native:$`);
      else if (input && !link) salt = this.store.getValue(`SALT:${input}:otp:$`);
      else if (input && link) salt = this.store.getValue(`SALT:${input}:link:$`);

      console.log('SALT:${input}:link:$', `SALT:${input}:link:$`);
      console.log('salt', salt);
      console.log('derived key', password, salt.toString('hex'), 5000, 32, 'sha512');
      let derivedKey = crypto.pbkdf2Sync(password, salt.toString('hex'), 5000, 32, 'sha512');
      const { DSC_ADDRESS, RPC_URL } = getConfigForShardStorage(this.environment);
      const provider = new ethers.providers.JsonRpcProvider(RPC_URL);
      const contract = new ethers.Contract(DSC_ADDRESS, dscAbi, provider);
      // console.log('dsc_key', dsc_key);
      let ipfsPath = await contract.hashToLink(dsc_key);
      console.log('ipfsPath', ipfsPath);
      let encRandomNumber;
      if (!ipfsPath) {
        if (userId) {
          console.log('`${socialName}:${userId}:$2`', `${socialName}:${userId}:$2`);
          ipfsPath = this.store.getValue(`${socialName}:${userId}:$2`);
          encRandomNumber = this.store.getValue(`encyRandomNumber:${socialName}:${userId}:$`);
        } else if (triaName && native) {
          console.log('${triaName}:native:$2', `${triaName}:native:$2`);
          ipfsPath = this.store.getValue(`${triaName}:native:$2`);
          encRandomNumber = this.store.getValue(`encyRandomNumber:${triaName}:native:$`);
        } else if (input && !link) {
          console.log('${input}:otp:$2', `${input}:otp:$2`);
          ipfsPath = this.store.getValue(`${input}:otp:$2`);
          encRandomNumber = this.store.getValue(`encyRandomNumber:${input}:otp:$`);
        } else if (input && link) {
          console.log('${input}:link:$2', `${input}:link:$2`);
          ipfsPath = this.store.getValue(`${input}:link:$2`);
          encRandomNumber = this.store.getValue(`encyRandomNumber:${input}:link:$`);
        }
      }

      if (userId) {
        console.log('`${socialName}:${userId}:$2`', `${socialName}:${userId}:$2`);
        encRandomNumber = this.store.getValue(`encyRandomNumber:${socialName}:${userId}:$`);
      } else if (triaName && native) {
        console.log('${triaName}:native:$2', `${triaName}:native:$2`);
        encRandomNumber = this.store.getValue(`encyRandomNumber:${triaName}:native:$`);
      } else if (input && !link) {
        console.log('${input}:otp:$2', `${input}:otp:$2`);
        encRandomNumber = this.store.getValue(`encyRandomNumber:${input}:otp:$`);
      } else if (input && link) {
        console.log('${input}:link:$2', `${input}:link:$2`);
        encRandomNumber = this.store.getValue(`encyRandomNumber:${input}:link:$`);
      }

      console.log('ipfsPath', ipfsPath);
      if (!ipfsPath) {
        return { exists: false, data: null };
      }
      let lshard;
      if (userId) lshard = this.store.getValue(`${socialName}:${userId}:$1`).encyShard;
      else if (triaName && native) lshard = this.store.getValue(`${triaName}:native:$1`).encyShard;
      else if (input && !link) lshard = this.store.getValue(`${input}:otp:$1`).encyShard;
      else if (input && link) lshard = this.store.getValue(`${input}:link:$1`).encyShard;
      const ipfsShard = await fetchContent(ipfsPath);
      console.log('lshard', lshard);
      const encryptedVault = secrets.hex2str(combine([lshard, ipfsShard]));
      console.log('encryptedVault', encryptedVault.toString());
      console.log("encryptedVault.split(':')[1]", encryptedVault.split(':')[1]);
      console.log(Buffer.from(encryptedVault.split(':')[0], 'hex'));
      console.log('derivedKey', derivedKey.toString('hex'));
      console.log('encryptedVault', encryptedVault);

      console.log('encRandomNumber', encRandomNumber);
      let decRandomNumber = await decryptAES(
        encRandomNumber.split(':')[1],
        derivedKey,
        Buffer.from(encRandomNumber.split(':')[0], 'hex')
      );
      console.log('decRandomNumber', decRandomNumber);
      decRandomNumber = decRandomNumber.replace(/^"|"$/g, '');
      // console.log('decRandomNumber', decRandomNumber.length);
      console.log('ipfsPath', ipfsPath);
      console.log({ lshard, ipfsShard });
      console.log({ encryptedVault });
      const decryptedData = await decryptAES(
        encryptedVault.split(':')[1],
        Buffer.from(decRandomNumber, 'hex'),
        Buffer.from(encryptedVault.split(':')[0], 'hex')
      );

      console.log('decryptedData', decryptedData);
      const vault = JSON.parse(decryptedData);
      console.log('decryptedData', vault);
      const publicVault = { triaName: vault?.triaName, evm: { address: vault?.evm?.address } };
      if (userId) {
        this.store.setValue(
          'init',
          JSON.stringify({
            loginType: 'social',
            triaName,
            socialName: socialName,
            userId,
            input: '',
          })
        );
      } else if (triaName && native) {
        this.store.setValue(
          'init',
          JSON.stringify({ loginType: 'native', triaName, socialName: '', userId: '', input: '' })
        );
      } else if (input && !link) {
        this.store.setValue(
          'init',
          JSON.stringify({ loginType: 'otp', triaName, socialName: '', userId: '', input })
        );
      } else if (input && link) {
        this.store.setValue(
          'init',
          JSON.stringify({ loginType: 'link', triaName, socialName: '', userId: '', input })
        );
      }
      this.storeInTriaStore(publicVault);
      this.postMessage(
        {
          type: 'Log in',
          success: true,
          data: publicVault,
        },
        userId || socialName ? true : false
      );
      this.storeConnectedAppInSession(origin);
      if (!userId) {
        await this.generateUserSession({ vault: vault });
      } else if (userId) {
        await this.generateUserSession({ vault: vault, accessToken: accessToken });
      }
      return { exists: true, data: vault };
    } catch (err: any) {
      console.error(err);
      //@ts-ignore
      Sentry.captureException(new Error(err.message), {
        tags: { key: 'getVault' },
        // extra: {
        //   functionArgs: {
        //     triaName,
        //     password,
        //     userId,
        //     socialName,
        //     input,
        //     hash,
        //     link,
        //     native,
        //     origin,
        //   }
        // }
      });
      this.postMessage(
        {
          type: 'Log in',
          success: false,
          data: { triaName, message: err.message || 'Incorrect username or password' },
        },
        userId || socialName ? true : false
      );
      return { exists: false, data: null };
    }
  }

  /**
   * @version 2
   */
  async getOTP(input: string): Promise<String> {
    const { session } = await this.authController.initiateOTP(input);
    return session;
  }

  /**
   * @version 2
   */
  async verifyOTP({ otp, session, input }: { otp: string; session: string; input: string }) {
    const { hash, password } = await this.authController.verifyOTP({ otp, session, input });
    return { hash, password };
  }

  /**
   * @version 2
   */
  async initiateEmailLinkAuth({
    email,
    password,
    origin,
  }: {
    email: string;
    password: string;
    origin?: string;
  }): Promise<String> {
    const res = await this.authController.initiateEmailLinkAuth({ email, password, origin });
    return res;
  }

  /**
   * @version 2
   */
  async emailLinkVerification({ code, email }: { code: string; email: string }) {
    try {
      const { verify } = await this.authController.emailLinkVerification({ code, email });
      // this.postMessage(
      //   {
      //     type: 'Email Link Sign up',
      //     success: true,
      //     data: { verify },
      //   },
      //   true
      // );
      return { verify };
    } catch (err) {
      console.log(err);
      // this.postMessage(
      //   {
      //     type: 'Email Link Sign up',
      //     success: false,
      //     data: null,
      //   },
      //   true
      // );
    }
  }

  /**
   * @version 2
   * @param hash We get from backend
   * @param input user email or phone number
   * @param password to encrypt the data will get from backend
   * @param triaName users triaName
   * @param type ["LINK", "OTP"]
   *
   */
  async generateAccountByOTPOrLINK({
    hash,
    input,
    password,
    triaName,
    type,
    origin,
  }: {
    triaName: string;
    input: string;
    hash: string;
    password: string;
    type: string;
    origin?: string;
  }) {
    const TYPES = ['link', 'otp'];
    if (!TYPES.includes(type)) {
      throw new Error('Invalid account creation method');
    }
    const { vault, publicVault } = await this.generateVault(triaName);
    const evmChainData = await this.generateEVMChainData(vault);

    // DID creation
    const args = {
      did: triaName,
      evmChainData: evmChainData,
      nonEvmChainsData: [],
    };
    let res = (await this.didService.createDID(args)) as CreateDIDResponse;
    if (!res.success) {
      throw Error('DID creation failed!');
    }
    const shard1LocalKey = `${input}:${type}:$1`;
    const shard2LocalKey = `${input}:${type}:$2`;
    const hashLocalKey = `${input}:${type}:hash`;
    const ress = await this.shardAndPushTheVault({
      vault,
      dsc_hash: hash,
      password,
      shard1LocalKey,
      shard2LocalKey: shard2LocalKey,
      hashLocalKey: hashLocalKey,
    });
    if (ress.success) {
      this.storeInTriaStore(publicVault);
      this.store.setValue(
        'init',
        JSON.stringify({ loginType: TYPES, triaName, socialName: '', userId: '', input })
      );
      this.storeConnectedAppInSession(origin);
      // this.postMessage({
      //   type: `${type} Sign up`,
      //   success: true,
      //   data: publicVault,
      // });
      //await this.generateUserSession({ vault: vault });
      return { success: true };
    } else {
      throw ress.error;
    }
  }

  /**
   * @description shard the vault and call the ShardStorage api
   */
  async shardAndPushTheVault({
    vault,
    dsc_hash,
    password,
    shard1LocalKey,
    shard2LocalKey,
    oauthData,
    hashLocalKey,
  }: {
    vault: Vault;
    dsc_hash: string;
    password: string;
    shard1LocalKey: string;
    shard2LocalKey: string;
    hashLocalKey: string;
    oauthData?: OAuthDataArgs;
  }) {
    try {
      const salt = crypto.randomBytes(16);
      const randomNumber = crypto.randomBytes(32);
      console.log('password', password);
      let derivedKey = crypto.pbkdf2Sync(password, salt.toString('hex'), 5000, 32, 'sha512');
      console.log('randomNumber.toString', JSON.stringify(randomNumber.toString('hex')));
      console.log('derivedKey', derivedKey.toString('hex'));
      const encryptedRandomNumber = encryptAES256(
        derivedKey,
        JSON.stringify(randomNumber.toString('hex'))
      );
      this.store.setValue(`encyRandomNumber:${shard1LocalKey.slice(0, -1)}`, encryptedRandomNumber);
      // enctrypt the vault
      const encryptedWallet = encryptAES256(randomNumber, JSON.stringify(vault));

      // shard the encrypted vault
      const [lshard, ipfsShard] = shamir(secrets.str2hex(encryptedWallet), 2, 2);
      const lstore = {
        encyShard: lshard,
      };
      const ipfsPath = await pinToIpfs(ipfsShard);
      // save the shard to local storage
      this.store.setValue(shard1LocalKey, JSON.stringify(lstore));
      this.store.setValue(shard2LocalKey, JSON.stringify(ipfsPath));
      this.store.setValue(hashLocalKey, JSON.stringify(dsc_hash));
      this.store.setValue(
        `SALT:${shard1LocalKey.slice(0, -1)}`,
        JSON.stringify(salt.toString('hex'))
      );
      // call the shard storage
      let shardStorageRes = (await this.didService.shardStorage({
        hash: dsc_hash,
        link: ipfsPath,
      })) as ShardStorageResponse;
      if (!shardStorageRes.success) {
        throw Error('DID creation failed!');
      }
      return { success: true };
    } catch (err) {
      //@ts-ignore
      Sentry.captureException(new Error(err.message), {
        tags: { key: 'shardAndPushTheVault' },
        // extra: {
        //   functionArgs: {
        //     triaName,
        //     password,
        //     userId,
        //     socialName,
        //     input,
        //     hash,
        //     link,
        //     native,
        //     origin,
        //   }
        // }
      });
      return { success: false, error: err };
    }
  }

  /**
   * @description delete shard
   */
  async deleteShardAfterSaved({
    hash,
    localStorageKeyForHash,
    localStorageKeyForShard2,
  }: {
    hash: string;
    localStorageKeyForHash: string;
    localStorageKeyForShard2: string;
  }) {
    let intervalID = setInterval(async () => {
      let shardElement = await this.isShardPresent(hash);

      if (shardElement) {
        console.log('Shard is present!');
        //delete data from localStorage
        this.store.removeValue(localStorageKeyForHash);
        this.store.removeValue(localStorageKeyForShard2);
        clearInterval(intervalID);
      } else {
        console.log('Shard is not saved yet');
      }
    }, 10000);
  }

  /**
   * @version 2
   * @returns Boolean
   */
  async isShardPresent(hash: string) {
    try {
      let shardExistsResponse = (await this.didService.shardExists(hash)) as ShardExistsResponse;
      if (!shardExistsResponse.success) {
        throw Error('Check Shard API Error!');
      }
      return shardExistsResponse.response;
    } catch (err) {
      throw err;
    }
  }

  async getUserSession() {
    const data = await this.authController.getSession();
    return data;
  }

  /**
   *
   */
  async generateUserSession({ vault, accessToken }: { vault: Vault; accessToken?: string }) {
    //api request for cookie set and it will return key too
    const { key } = await this.authController.getKey(accessToken);
    console.log('key', key);
    const keyBytes = Buffer.from(key, 'hex');
    // store the decrypted vault in obsStore
    this.memStore = new ObservableStore({
      vault: vault,
    });
    //use the key and salt to encrypt the vault
    const encryptedVault = encryptAES256(keyBytes, JSON.stringify(vault));
    //store the encrypted vault in localstorage for now
    this.store.setValue('tempVault', JSON.stringify(encryptedVault));
  }

  async detectLoggedInAccount() {
    let vault = this.memStore?.getState();
    vault = JSON.parse(vault);

    const account = { triaName: vault?.triaName, evm: { address: vault?.evm?.address } };

    this.postMessage({
      type: 'Detected Logged in Tria account',
      success: true,
      data: account,
    });
  }

  /**
   * Asynchronously reconstructs User Vault.
   * @param tID - The ID of the User.
   * @param triaName - The Tria name of the User.
   * @param password - The password for authentication.
   * @returns A Promise that resolves to the reconstructed Decrypted Vault.
   */
  async reconstruct(password: string, pin: string): Promise<ReconstructResponse> {
    try {
      const { tID } = await this.userService.get_tID();
      const shadowHash = await generateShadowHash({
        secret: `${password}:${pin}`,
        salt: tID,
      });
      console.log('reconstructing...');
      let decryptedVault = await reconstruct(tID, shadowHash, this.apiUrl);
      const nonEvmVault = filterNonEVM(decryptedVault?.vault.accountKeys, NON_EVM_LIST);
      const { nonEvmShard1Vault, nonEvmShard2Vault } = await shardNonEvmVaultKeys(nonEvmVault);
      console.log({ nonEvmShard1Vault, nonEvmShard2Vault });
      await this.walletService.addNonEvmShards({ accountKeys: nonEvmShard2Vault });
      // const keyForVault = await generateShadowHash({
      //   secret: `${pin}`,
      //   salt: tID,
      // });
      let encryptedVault = encryptAES256(shadowHash, JSON.stringify(decryptedVault));
      this.store.setValue(VAULT, JSON.stringify(encryptedVault));
      this.store.setValue(NON_EVM_VAULT, JSON.stringify(nonEvmShard1Vault));
      delete decryptedVault?.vault.memonic;
      const memData = { vault: {}, nEVMVault: {} };
      memData[VAULT] = decryptedVault?.vault;
      memData[NON_EVM_VAULT] = nonEvmShard1Vault;
      this.memStore.putState(memData);
      this.store.setValue(
        KEY_STORE,
        JSON.stringify(decryptedVault?.vault.accountKeysdecryptedVault?.vault.accountKeys)
      );
      return { success: true };
    } catch (err) {
      console.log(err);
      return { success: false };
    }
  }

  /**
   *
   * @param username users tria name
   * @param password users password
   * @param pin user pin
   * @param chainName chain name for which user want to add wallet
   */

  async addWallet(
    password: string,
    pin: string,
    chainName: string
  ): Promise<UpdatedWalletAddresses> {
    const walletService = new WalletService(this.apiUrl);
    try {
      await walletService.add(password, pin, chainName);
      return await this.fullUpdate(password, pin);
    } catch (err) {
      console.log(err);
      return { success: false, list: [] };
    }
  }

  async updateSubName({
    newSubName,
    oldSubName,
    password,
    pin,
  }: UpdateSubNameArgs): Promise<AddWalletResponse> {
    await this.walletService.updateSubName({ newSubName, oldSubName, password, pin });
    return await this.fullUpdate(password, pin);
  }

  async removeAddress({ subname, password, pin }: RemoveAddressArgs): Promise<AddWalletResponse> {
    await this.walletService.removeSubname({ subname, password, pin });
    return await this.userService.getAllAddresses();
  }

  /**
   * Private method use to get users key from memory
   * @param triaName Trianame
   * @param chainName Chain name for which users password needed
   * @returns keypair
   */

  /**
   * @todo Password & pin verification
   * @param password Password
   * @param pin Pin
   */
  async exportMemonic(password: string, pin: string): Promise<ExportMnemonicResponse> {
    try {
      const { tID } = await this.userService.get_tID();
      const shadowHash = await generateShadowHash({
        secret: `${password}:${pin}`,
        salt: tID,
      });
      const encryptedVault = await this.store.getValue(VAULT);
      const hexIV = encryptedVault.split(':')[0];
      const cipher = encryptedVault.split(':')[1];
      const IV = Buffer.from(hexIV, 'hex');
      const decryptedVault = await decryptAES(cipher, shadowHash, IV);
      const parsedVault = JSON.parse(decryptedVault);
      const memonic = parsedVault.vault.memonic;
      return {
        success: true,
        mnemonic: memonic,
      };
    } catch (err) {
      console.log(err);
      return {
        success: false,
        mnemonic: null,
      };
    }
  }

  /**
   * @todo Password & pin verification
   * @param triaName triaName
   * @param password Password
   * @param pin Pin
   * @param chainName chainName
   */

  async exportPrivateKey(
    triaName: string,
    password: string,
    pin: string,
    chainName: string
  ): Promise<ExportPrivateKeyResponse> {
    try {
      const { tID } = await this.userService.get_tID();
      const shadowHash = await generateShadowHash({
        secret: `${password}:${pin}`,
        salt: tID,
      });
      const encryptedVault = await this.store.getValue(VAULT);
      const hexIV = encryptedVault.split(':')[0];
      const cipher = encryptedVault.split(':')[1];
      const IV = Buffer.from(hexIV, 'hex');
      const decryptedVault = await decryptAES(cipher, shadowHash, IV);
      const parsedVault = JSON.parse(decryptedVault);
      console.log('parsedVault', parsedVault);
      const accountKeys = parsedVault.vault.accountKeys;
      const privateKey = accountKeys[triaName][chainName]['privateKey'];
      return {
        success: true,
        privateKey: privateKey,
      };
    } catch (err) {
      console.log(err);
      return {
        success: false,
        privateKey: null,
      };
    }
  }

  /**
   *@description this function is for inMemory data persist
   */
  async persistMemoryData() {
    this.store.setValue(TEMP_MEM_STORE, JSON.stringify(this.memStore.getState()));
  }

  /**
   * In v2 we have triaName stored in vault itself
   */
  async #resolveTriaName(
    chainName: string
  ): Promise<{ privateKey: string; address: string; triaName: string }> {
    console.log('fetching vault');
    let vault = await this.memStore?.getState();
    if (vault) vault = JSON.parse(vault);
    console.log({ vault });

    let privateKey, address;
    if (isEvmChain(chainName)) {
      privateKey = vault?.evm?.privateKey;
      address = vault?.evm?.address;
    } // else implement for non evm

    return {
      privateKey: privateKey as string,
      address: address as string,
      triaName: vault?.triaName,
    };
  }

  async logout() {
    const res = await this.authController.logout();
    this.cleanOnLogout();
    this.postMessage({
      type: 'Logout',
      success: true,
    });
    return { success: true };
  }

  async cleanOnLogout() {
    this.store.removeValue('tempVault');
    this.store.removeValue('tria.wallet.store');
    this.memStore = new ObservableStore({});
    return { success: true };
  }

  /**
   * @param triaName triaName
   * @param chainName chainName
   */

  async resolveTriaName(triaName: string, chainName: string): Promise<string> {
    const res = await this.walletService.resolveTriaName(
      { chainName, lookUpTriaName: triaName },
      this.environment
    );
    return res.address;
  }

  /**
   * For message passing between windows and iframes
   * @param windowTo
   * @param message
   */
  postMessage(message: Object, sameOrigin: boolean = false) {
    console.log('postMessage', message);
    console.log({ sameOrigin });
    if (sameOrigin) {
      const bc = new BroadcastChannel('Tria Auth Channel');
      bc.postMessage(JSON.stringify(message));
      if (window?.opener?.postMessage) {
        window.opener.postMessage(JSON.stringify(message), '*');
      }
      return;
    }

    if (window?.opener?.postMessage) {
      window.opener.postMessage(JSON.stringify(message), '*');
    } else if (window?.parent) {
      window.parent.postMessage(JSON.stringify(message), document.referrer);
    }
  }

  storeInTriaStore(publicVault: Object) {
    this.store.setValue('tria.wallet.store', JSON.stringify(publicVault));
  }

  storeConnectedAppInSession(dappUrl?: string) {
    const connectedApps = 'tria.connected.apps';
    try {
      const appUrl = dappUrl || document.referrer;
      let prevApps = window.localStorage.getItem(connectedApps);
      let allApps;
      if (prevApps) {
        console.log(prevApps);
        const apps = JSON.parse(prevApps);
        // to avoid duplicates
        if (apps.includes(appUrl)) return;
        apps.push(appUrl);
        allApps = JSON.stringify(apps);
      } else {
        allApps = JSON.stringify([appUrl]);
      }
      console.log({ allApps });
      window.localStorage.setItem(connectedApps, allApps);
    } catch (err) {
      window.localStorage.removeItem(connectedApps);
    }
  }
}
