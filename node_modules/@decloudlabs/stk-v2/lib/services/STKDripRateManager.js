"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var ethers_1 = require("ethers");
var utils_1 = require("../utils/utils");
var STKDripRateManager = /** @class */ (function () {
    function STKDripRateManager(stepUpFactor, contractService) {
        var _this = this;
        if (stepUpFactor === void 0) { stepUpFactor = "0"; }
        this.getWalletBalance = function (walletAddress) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.XCT.balanceOf(walletAddress), function (res) { return res.toString(); })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.getSubscriptionBalance = function (nftID) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.SubscriptionBalance.totalPrevBalance(nftID), function (res) { return res.toString(); })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.getSupportFeesForNFT = function (supportAddress, nftID) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.Subscription.getSupportFeesForNFT(supportAddress, nftID), function (res) { return [res[0].toNumber(), res[1].toNumber()]; })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.estimateDripRatePerSec = function (subnetListBatch, factors, multipliedResourceBatch, resourceTypeBatch) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.SubscriptionBalanceCalculator.estimateDripRatePerSec(subnetListBatch, factors, multipliedResourceBatch, resourceTypeBatch), function (res) { return res.toString(); })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.getSubscribeTime = function (nftID) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.Subscription.getCreateTime(nftID), function (res) { return res.toNumber(); })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.getPlatformFactors = function (platformAddress) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.Subscription.platformAddressMap(platformAddress), function (res) {
                            return {
                                platformPercentage: res.platformPercentage.toNumber(),
                                referralPercentage: res.referralPercentage.toNumber(),
                                discountPercentage: res.discountPercentage.toNumber(),
                                referralExpiryDuration: res.referralExpiryDuration.toNumber(),
                            };
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.getPlatformAddress = function (nftID) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.Subscription.getNFTFactorAddress(nftID, 0), function (res) { return res; })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.getSupportAddress = function (nftID) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.Subscription.getNFTFactorAddress(nftID, 1), function (res) { return res; })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.getLicenseAddress = function (nftID) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.Subscription.getNFTFactorAddress(nftID, 2), function (res) { return res; })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.getReferralAddress = function (nftID) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.Subscription.getNFTFactorAddress(nftID, 3), function (res) { return res; })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.getSupportFactor = function (nftID) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.Subscription.getSupportFactor(nftID), function (res) { return [
                            res[0].toNumber(),
                            res[1].toNumber(),
                        ]; })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.getLicenseFactor = function (nftID) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.Subscription.getLicenseFactor(nftID), function (res) { return [
                            res[0].toNumber(),
                            res[1].toNumber(),
                        ]; })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.estimateETHForXCT = function (uniswapRouterV2Address, wethAddress, netXCTRequired) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.XCTMinter.estimateETHForXCT(uniswapRouterV2Address, wethAddress, netXCTRequired), function (res) { return res.toString(); })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.getStepUpFactor = function () { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.XCTMinter.stepUpFactor(), function (res) { return res.toString(); })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.buyXCTWithETH = function (uniswapRouterV2Address, wethAddress, usdcRequired, deadline, ethRequired) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)((function () { return __awaiter(_this, void 0, void 0, function () {
                            var tr, rc;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.etherContracts.XCTMinter.easyBuyXCT(uniswapRouterV2Address, wethAddress, usdcRequired, deadline, {
                                            value: ethRequired,
                                        })];
                                    case 1:
                                        tr = _a.sent();
                                        return [4 /*yield*/, tr.wait()];
                                    case 2:
                                        rc = _a.sent();
                                        return [2 /*return*/, rc];
                                }
                            });
                        }); })(), function (res) { return res; })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.approveXCT = function (approvedAddress, xctRequired) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)((function () { return __awaiter(_this, void 0, void 0, function () {
                            var tr, rc;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        tr = this.etherContracts.XCT.approve(approvedAddress, xctRequired);
                                        return [4 /*yield*/, tr.wait()];
                                    case 1:
                                        rc = _a.sent();
                                        return [2 /*return*/, rc];
                                }
                            });
                        }); })(), function (res) { return res; })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.addSubscriptionBalance = function (accountAddress, nftID, xctRequired) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)((function () { return __awaiter(_this, void 0, void 0, function () {
                            var tr, rc;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.etherContracts.SubscriptionBalance.addBalance(accountAddress, nftID, xctRequired)];
                                    case 1:
                                        tr = _a.sent();
                                        return [4 /*yield*/, tr.wait()];
                                    case 2:
                                        rc = _a.sent();
                                        return [2 /*return*/, rc];
                                }
                            });
                        }); })(), function (res) { return res; })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.getBalanceEndTime = function (nftID) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.SubscriptionBalance.getBalanceEndTime(nftID), function (res) { return res.toNumber(); })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        }); };
        this.calcSubnetComputes = function (contractAppList) {
            var subnetListBatch = [];
            var multipliedResourceBatch = [];
            var resourceTypeBatch = [];
            var subnetMultResMap = {};
            for (var c = 0; c < contractAppList.length; c++) {
                var contractApp = contractAppList[c];
                var resourceType = contractApp.resourceType, resourceCount = contractApp.resourceCount, multiplier = contractApp.multiplier, subnetList = contractApp.subnetList;
                for (var i = 0; i < subnetList.length; i++) {
                    var subnetID = subnetList[i];
                    var curReplica = multiplier[i] || [];
                    if (!subnetMultResMap[subnetID]) {
                        subnetListBatch.push(subnetID);
                        subnetMultResMap[subnetID] = {};
                    }
                    for (var j = 0; j < resourceType.length; j++) {
                        var resType = resourceType[j];
                        var resCount = resourceCount[j];
                        var curRep = curReplica[j];
                        var multRes = curRep * resCount || 0;
                        if (!subnetMultResMap[subnetID][resType]) {
                            subnetMultResMap[subnetID][resType] = 0;
                        }
                        subnetMultResMap[subnetID][resType] += multRes;
                    }
                }
            }
            var _loop_1 = function (i) {
                var subnetID = subnetListBatch[i];
                var subnetResourceTypeList = Object.keys(subnetMultResMap[subnetID]).map(function (x) { return Number(x); });
                var resourceCount = [];
                subnetResourceTypeList.forEach(function (subnetResType) {
                    resourceCount.push(subnetMultResMap[subnetID][subnetResType]);
                });
                resourceTypeBatch.push(subnetResourceTypeList);
                multipliedResourceBatch.push(resourceCount);
            };
            for (var i = 0; i < subnetListBatch.length; i++) {
                _loop_1(i);
            }
            return {
                subnetListBatch: subnetListBatch,
                multipliedResourceBatch: multipliedResourceBatch,
                resourceTypeBatch: resourceTypeBatch,
            };
        };
        this.stepUpFactor = stepUpFactor;
        this.etherContracts = contractService;
    }
    STKDripRateManager.prototype.estimateDripRate = function (contractAppList, dripRateFactors, subscriptionParam) {
        return __awaiter(this, void 0, void 0, function () {
            var referralExpiry, currentTime, _a, subnetListBatch, multipliedResourceBatch, resourceTypeBatch, factors, estimDripRateResp;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        referralExpiry = dripRateFactors.referralFactor + dripRateFactors.createTime * 1000;
                        currentTime = Date.now();
                        _a = this.calcSubnetComputes(contractAppList), subnetListBatch = _a.subnetListBatch, multipliedResourceBatch = _a.multipliedResourceBatch, resourceTypeBatch = _a.resourceTypeBatch;
                        factors = [
                            dripRateFactors.licenseFactor[0],
                            dripRateFactors.licenseFactor[1],
                            dripRateFactors.supportFactor[0],
                            dripRateFactors.supportFactor[1],
                            dripRateFactors.referralFactor,
                            dripRateFactors.platformFactor,
                            0,
                        ];
                        if (referralExpiry > currentTime &&
                            subscriptionParam.platformAddress !==
                                "0x0000000000000000000000000000000000000000") {
                            factors.push(dripRateFactors.discountFactor);
                        }
                        else {
                            factors.push(0);
                        }
                        console.log("factors: ", factors);
                        console.log("resource:", subnetListBatch, multipliedResourceBatch, resourceTypeBatch);
                        return [4 /*yield*/, this.estimateDripRatePerSec(subnetListBatch, factors, multipliedResourceBatch, resourceTypeBatch)];
                    case 1:
                        estimDripRateResp = _b.sent();
                        return [2 /*return*/, estimDripRateResp];
                }
            });
        });
    };
    STKDripRateManager.prototype.estimateBalanceEndTime = function (balancesForSubscription, dripRate) {
        var subscriptionBalance = ethers_1.ethers.BigNumber.from(balancesForSubscription.subscriptionBalance);
        var estimDripRate = ethers_1.ethers.BigNumber.from(dripRate);
        var estimBalEndTime = subscriptionBalance.div(estimDripRate);
        return estimBalEndTime.toString();
    };
    STKDripRateManager.prototype.getBalancesForSubscription = function (nftID) {
        return __awaiter(this, void 0, void 0, function () {
            var subBalResp, walletBalResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getSubscriptionBalance(nftID)];
                    case 1:
                        subBalResp = _a.sent();
                        if (subBalResp.success == false)
                            return [2 /*return*/, subBalResp];
                        return [4 /*yield*/, this.getWalletBalance(this.etherContracts.selectedAccount)];
                    case 2:
                        walletBalResp = _a.sent();
                        if (walletBalResp.success == false)
                            return [2 /*return*/, walletBalResp];
                        return [2 /*return*/, {
                                success: true,
                                data: {
                                    subscriptionBalance: subBalResp.data,
                                    walletBalance: walletBalResp.data,
                                },
                            }];
                }
            });
        });
    };
    STKDripRateManager.prototype.getSubscriptionParam = function (nftID) {
        return __awaiter(this, void 0, void 0, function () {
            var createTimeResp, createTime, platformAddressResp, platformAddress, suppAddrResp, supportAddress, licAddrResp, licenseAddress, refAddrResp, referralAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getSubscribeTime(nftID)];
                    case 1:
                        createTimeResp = _a.sent();
                        if (createTimeResp.success == false)
                            return [2 /*return*/, createTimeResp];
                        createTime = createTimeResp.data;
                        if (createTime == 0) {
                            return [2 /*return*/, {
                                    success: true,
                                    data: {
                                        licenseAddress: "0x0000000000000000000000000000000000000000",
                                        supportAddress: "0x0000000000000000000000000000000000000000",
                                        platformAddress: "0x0000000000000000000000000000000000000000",
                                        referralAddress: "0x0000000000000000000000000000000000000000",
                                        createTime: 0,
                                    },
                                }];
                        }
                        return [4 /*yield*/, this.getPlatformAddress(nftID)];
                    case 2:
                        platformAddressResp = _a.sent();
                        if (platformAddressResp.success == false)
                            return [2 /*return*/, platformAddressResp];
                        platformAddress = platformAddressResp.data;
                        return [4 /*yield*/, this.getSupportAddress(nftID)];
                    case 3:
                        suppAddrResp = _a.sent();
                        if (suppAddrResp.success == false)
                            return [2 /*return*/, suppAddrResp];
                        supportAddress = suppAddrResp.data;
                        return [4 /*yield*/, this.getLicenseAddress(nftID)];
                    case 4:
                        licAddrResp = _a.sent();
                        if (licAddrResp.success == false)
                            return [2 /*return*/, licAddrResp];
                        licenseAddress = licAddrResp.data;
                        return [4 /*yield*/, this.getReferralAddress(nftID)];
                    case 5:
                        refAddrResp = _a.sent();
                        if (refAddrResp.success == false)
                            return [2 /*return*/, refAddrResp];
                        referralAddress = refAddrResp.data;
                        return [2 /*return*/, {
                                success: true,
                                data: {
                                    platformAddress: platformAddress,
                                    supportAddress: supportAddress,
                                    licenseAddress: licenseAddress,
                                    referralAddress: referralAddress,
                                    createTime: createTime,
                                },
                            }];
                }
            });
        });
    };
    STKDripRateManager.prototype.getDripRateFactors = function (nftID, subscriptionParam) {
        return __awaiter(this, void 0, void 0, function () {
            var supportFactorResp_1, supportFactor_1, platformFactorResp_1, _a, platformPercentage_1, referralPercentage_1, discountPercentage_1, referralExpiryDuration_1, supportFactorResp, supportFactor, licenseFactorResp, licenseFactor, platformFactorResp, _b, platformPercentage, referralPercentage, discountPercentage, referralExpiryDuration;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!(subscriptionParam.createTime === 0)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getSupportFeesForNFT(subscriptionParam.supportAddress, nftID)];
                    case 1:
                        supportFactorResp_1 = _c.sent();
                        if (supportFactorResp_1.success == false)
                            return [2 /*return*/, supportFactorResp_1];
                        supportFactor_1 = supportFactorResp_1.data;
                        console.log("platform: ", subscriptionParam.platformAddress, supportFactor_1);
                        return [4 /*yield*/, this.getPlatformFactors(subscriptionParam.platformAddress)];
                    case 2:
                        platformFactorResp_1 = _c.sent();
                        if (platformFactorResp_1.success == false)
                            return [2 /*return*/, platformFactorResp_1];
                        _a = platformFactorResp_1.data, platformPercentage_1 = _a.platformPercentage, referralPercentage_1 = _a.referralPercentage, discountPercentage_1 = _a.discountPercentage, referralExpiryDuration_1 = _a.referralExpiryDuration;
                        return [2 /*return*/, {
                                success: true,
                                data: {
                                    createTime: subscriptionParam.createTime,
                                    supportFactor: [supportFactor_1[0], supportFactor_1[1]],
                                    licenseFactor: [0, 0],
                                    platformFactor: platformPercentage_1,
                                    referralFactor: referralPercentage_1,
                                    discountFactor: discountPercentage_1,
                                    referralExpiryDuration: referralExpiryDuration_1,
                                },
                            }];
                    case 3: return [4 /*yield*/, this.getSupportFactor(nftID)];
                    case 4:
                        supportFactorResp = _c.sent();
                        if (supportFactorResp.success == false)
                            return [2 /*return*/, supportFactorResp];
                        supportFactor = supportFactorResp.data;
                        return [4 /*yield*/, this.getLicenseFactor(nftID)];
                    case 5:
                        licenseFactorResp = _c.sent();
                        if (licenseFactorResp.success == false)
                            return [2 /*return*/, licenseFactorResp];
                        licenseFactor = licenseFactorResp.data;
                        return [4 /*yield*/, this.getPlatformFactors(subscriptionParam.platformAddress)];
                    case 6:
                        platformFactorResp = _c.sent();
                        if (platformFactorResp.success == false)
                            return [2 /*return*/, platformFactorResp];
                        _b = platformFactorResp.data, platformPercentage = _b.platformPercentage, referralPercentage = _b.referralPercentage, discountPercentage = _b.discountPercentage, referralExpiryDuration = _b.referralExpiryDuration;
                        return [2 /*return*/, {
                                success: true,
                                data: {
                                    createTime: subscriptionParam.createTime,
                                    supportFactor: supportFactor,
                                    licenseFactor: licenseFactor,
                                    platformFactor: platformPercentage,
                                    referralFactor: referralPercentage,
                                    discountFactor: discountPercentage,
                                    referralExpiryDuration: referralExpiryDuration,
                                },
                            }];
                }
            });
        });
    };
    STKDripRateManager.prototype.estimateETHRequired = function (timePeriod, balancesForSubscription, dripRate, uniswapRouterV2Address, wethAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var dripRateBN, xctRequired, netETHRequired, netXCTRequired, subscriptionBalanceBN, walletBalanceBN, estimETHResp, subBalanceEstimate;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        dripRateBN = ethers_1.ethers.BigNumber.from(dripRate);
                        xctRequired = dripRateBN.mul(timePeriod);
                        netETHRequired = "0";
                        netXCTRequired = "0";
                        subscriptionBalanceBN = ethers_1.ethers.BigNumber.from(balancesForSubscription.subscriptionBalance);
                        walletBalanceBN = ethers_1.ethers.BigNumber.from(balancesForSubscription.walletBalance);
                        if (!xctRequired.gt(walletBalanceBN)) return [3 /*break*/, 2];
                        netXCTRequired = xctRequired.sub(walletBalanceBN).toString();
                        return [4 /*yield*/, this.estimateETHForXCT(uniswapRouterV2Address, wethAddress, netXCTRequired)];
                    case 1:
                        estimETHResp = _a.sent();
                        if (estimETHResp.success == false)
                            return [2 /*return*/, estimETHResp];
                        netETHRequired = estimETHResp.data;
                        netETHRequired = ethers_1.ethers.BigNumber.from(netETHRequired)
                            .mul(110)
                            .div(100)
                            .toString();
                        _a.label = 2;
                    case 2:
                        subBalanceEstimate = {
                            netETHRequired: netETHRequired,
                            netXCTRequired: netXCTRequired,
                            xctRequired: xctRequired.toString(),
                            timePeriod: timePeriod,
                        };
                        return [2 /*return*/, {
                                success: true,
                                data: subBalanceEstimate,
                            }];
                }
            });
        });
    };
    STKDripRateManager.prototype.convertXCTToUSDC = function (xctRequired) {
        return __awaiter(this, void 0, void 0, function () {
            var stepUpResp, xctRequiredBN, stepUpFactorBN, usdcAmountBN;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.stepUpFactor === "0")) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getStepUpFactor()];
                    case 1:
                        stepUpResp = _a.sent();
                        if (!stepUpResp.success)
                            return [2 /*return*/, stepUpResp];
                        this.stepUpFactor = stepUpResp.data;
                        _a.label = 2;
                    case 2:
                        xctRequiredBN = ethers_1.ethers.BigNumber.from(xctRequired);
                        stepUpFactorBN = ethers_1.ethers.BigNumber.from(this.stepUpFactor);
                        usdcAmountBN = xctRequiredBN.div(stepUpFactorBN);
                        // Return the result as a string
                        return [2 /*return*/, {
                                success: true,
                                data: usdcAmountBN.toString(),
                            }];
                }
            });
        });
    };
    STKDripRateManager.prototype.purchaseXCT = function (nftID, subBalanceEstimate, uniswapRouterV2Address, wethAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var balSubResp, deadline, convertXCTResp, usdcRequired, buyXCTResp, balancesForSubscription;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!ethers_1.ethers.BigNumber.from(subBalanceEstimate.netETHRequired).eq(0)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getBalancesForSubscription(nftID)];
                    case 1:
                        balSubResp = _a.sent();
                        if (balSubResp.success == false)
                            return [2 /*return*/, balSubResp];
                        return [2 /*return*/, {
                                success: true,
                                data: {
                                    subBalanceEstimate: subBalanceEstimate,
                                    balancesForSubscription: balSubResp.data,
                                },
                            }];
                    case 2:
                        deadline = (0, utils_1.getBlockTimestamp)();
                        return [4 /*yield*/, this.convertXCTToUSDC(subBalanceEstimate.netXCTRequired)];
                    case 3:
                        convertXCTResp = _a.sent();
                        if (convertXCTResp.success == false)
                            return [2 /*return*/, convertXCTResp];
                        usdcRequired = convertXCTResp.data;
                        console.log("easyBuyXCT: ", uniswapRouterV2Address, wethAddress, usdcRequired, deadline, {
                            value: subBalanceEstimate.netETHRequired,
                        });
                        return [4 /*yield*/, this.buyXCTWithETH(uniswapRouterV2Address, wethAddress, usdcRequired, deadline, subBalanceEstimate.netETHRequired)];
                    case 4:
                        buyXCTResp = _a.sent();
                        if (!buyXCTResp.success)
                            return [2 /*return*/, buyXCTResp];
                        return [4 /*yield*/, this.getBalancesForSubscription(nftID)];
                    case 5:
                        balancesForSubscription = _a.sent();
                        if (balancesForSubscription.success == false) {
                            return [2 /*return*/, balancesForSubscription];
                        }
                        return [2 /*return*/, {
                                success: true,
                                data: {
                                    subBalanceEstimate: subBalanceEstimate,
                                    balancesForSubscription: balancesForSubscription.data,
                                },
                            }];
                }
            });
        });
    };
    STKDripRateManager.prototype.addSubscriptionCredit = function (nftID, subBalanceEstimate) {
        return __awaiter(this, void 0, void 0, function () {
            var xctRequired, approveXCTResp, addSubResp, balancesForSubscription, balEndResp, balanceEndTime;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        xctRequired = subBalanceEstimate.xctRequired;
                        if (!ethers_1.ethers.BigNumber.from(xctRequired).gt(0)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.approveXCT(this.etherContracts.SubscriptionBalance.address, xctRequired)];
                    case 1:
                        approveXCTResp = _a.sent();
                        if (!approveXCTResp.success)
                            return [2 /*return*/, approveXCTResp];
                        return [4 /*yield*/, this.addSubscriptionBalance(this.etherContracts.selectedAccount, nftID, xctRequired)];
                    case 2:
                        addSubResp = _a.sent();
                        if (!addSubResp.success)
                            return [2 /*return*/, addSubResp];
                        // Reset xctRequired and netXCTRequired
                        subBalanceEstimate.xctRequired = "0";
                        subBalanceEstimate.netXCTRequired = "0";
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this.getBalancesForSubscription(nftID)];
                    case 4:
                        balancesForSubscription = _a.sent();
                        if (balancesForSubscription.success == false) {
                            return [2 /*return*/, balancesForSubscription];
                        }
                        return [4 /*yield*/, this.getBalanceEndTime(nftID)];
                    case 5:
                        balEndResp = _a.sent();
                        if (balEndResp.success == false)
                            return [2 /*return*/, balEndResp];
                        balanceEndTime = balEndResp.data;
                        return [2 /*return*/, {
                                success: true,
                                data: {
                                    subBalanceEstimate: subBalanceEstimate,
                                    balancesForSubscription: balancesForSubscription.data,
                                    balanceEndTime: balanceEndTime,
                                },
                            }];
                }
            });
        });
    };
    return STKDripRateManager;
}());
exports.default = STKDripRateManager;
