import { APICallReturn, AppModifier, AppPayload, CRUD_APP_STAGE, ContractApp, DripRateFactors, ETHAddress, EncryptedPayload, EncryptedPayloadWithKeys, EtherContracts, SubnetPKMap, SubscriptionParam, UrsulaAuth, UrsulaParams } from "../types/types";
import { STKAppCache } from "./STKAppCache";
import { STKAppStorage } from "./STKAppStorage";
import STKAppEncrypt from "./STKAppEncrypt";
import { ethers } from "ethers";
import STKAppDecrypt from "./STKAppDecrypt";
export default class STKAppManager {
    appCache: STKAppCache;
    appStorage: STKAppStorage;
    appEncrypt: STKAppEncrypt;
    appDecryptor: STKAppDecrypt;
    etherContracts: EtherContracts;
    saveAppToLocal: (appList: ContractApp) => Promise<APICallReturn<string>>;
    saveSubParamToLocal: (subParam: SubscriptionParam) => Promise<APICallReturn<string>>;
    removeAppFromLocal: (nftID: string, appID: string) => Promise<APICallReturn<string>>;
    constructor(appCache: STKAppCache, appStorage: STKAppStorage, contractService: EtherContracts, appEncrypt: STKAppEncrypt, appDecryptor: STKAppDecrypt, saveAppToLocal: (app: ContractApp) => Promise<APICallReturn<string>>, saveSubParamToLocal: (subParam: SubscriptionParam) => Promise<APICallReturn<string>>, removeAppFromLocal: (nftID: string, appID: string) => Promise<APICallReturn<string>>);
    validateContractApp(contractApp: ContractApp): APICallReturn<string>;
    contractCall: {
        createApp: (balanceToAdd: string, nftID: string, appName: string, path: [string, string], subnetList: string[], multiplier: number[][], resourceCount: number[], resourceType: number[], cidLock: boolean) => Promise<APICallReturn<string>>;
        subscribeAndCreateApp: (balanceToAdd: string, nftID: string, rlsAddresses: [string, string, string, string], licenseFactor: [number, number], appName: string, path: [string, string], subnetList: string[], multiplier: number[][], resourceCount: number[], resourceType: number[], cidLock: boolean) => Promise<APICallReturn<string>>;
        getAppList: (nftID: string) => Promise<APICallReturn<any, Error>>;
        getCreateTime: (nftID: string) => Promise<APICallReturn<any, Error>>;
        updateApp: (balanceToAdd: string, nftID: string, appID: string, path: [string, string], subnetList: string[], multiplier: number[][], resourceCount: number[], resourceType: number[]) => Promise<APICallReturn<string>>;
        deleteApp: (nftID: string, appID: string) => Promise<APICallReturn<string>>;
        getSubnetAttributes: (subnetID: string) => Promise<APICallReturn<any, Error>>;
        getXCTAllowance: (allowAddress: ETHAddress, toAddress: ETHAddress) => Promise<APICallReturn<ethers.BigNumber, Error>>;
        approveXCT: (approveAddress: string, allowanceVal: string) => Promise<APICallReturn<string>>;
    };
    getSubnetKeys(subnetList: string[]): Promise<APICallReturn<SubnetPKMap>>;
    saveAppToCache(contractApp: ContractApp, encryptedApp: EncryptedPayloadWithKeys, appPayload: AppPayload, encryptedAppModifier: EncryptedPayload, appModifier: AppModifier): Promise<APICallReturn<{
        warning: Error[];
    }>>;
    deleteAppFromCache(nftID: string, appID: string): Promise<APICallReturn<{
        warning: Error[];
    }>>;
    approveBalanceWithdraw(balanceToAdd: string): Promise<APICallReturn<string>>;
    encryptNewApp(address: ETHAddress, ursulaParam: UrsulaParams, contractApp: ContractApp, appPayload: AppPayload, appModifier: AppModifier): Promise<APICallReturn<{
        appPayload: EncryptedPayloadWithKeys;
        appModifier: EncryptedPayload;
    }>>;
    encryptAppModifier(address: ETHAddress, ursulaParam: UrsulaParams, contractApp: ContractApp, appPayload: AppPayload, appModifier: AppModifier): Promise<APICallReturn<{
        appPayload: EncryptedPayloadWithKeys;
        appModifier: EncryptedPayload;
    }>>;
    encryptApp(address: ETHAddress, ursulaParam: UrsulaParams, contractApp: ContractApp, appPayload: AppPayload, appModifier: AppModifier, cidLock: boolean): Promise<APICallReturn<{
        appPayload: EncryptedPayloadWithKeys;
        appModifier: EncryptedPayload;
    }>>;
    sendEncryptedApp(contractApp: ContractApp, encryptedApp: EncryptedPayloadWithKeys, encryptedAppModifier: EncryptedPayload, cidLock: boolean): Promise<APICallReturn<{
        appPath: string;
        modPath: string;
    }>>;
    callSubscribeAndCreateApp(balanceToAdd: string, contractApp: ContractApp, subscriptionParam: SubscriptionParam, dripRateFactors: DripRateFactors): Promise<APICallReturn<string>>;
    callCreateApp(balanceToAdd: string, contractApp: ContractApp): Promise<APICallReturn<string>>;
    fetchContractAppAndSaveToLocal(transactionHash: string, contractApp: ContractApp): Promise<APICallReturn<string>>;
    saveSubscriptionParam(subscriptionParam: SubscriptionParam, contractApp: ContractApp): Promise<APICallReturn<string>>;
    createApp(balanceToAdd: string, contractApp: ContractApp, subscriptionParam: SubscriptionParam, dripRateFactors: DripRateFactors, appPayload: AppPayload, appModifier: AppModifier, ursulaParam: UrsulaParams, setCurrentStatus: (status: CRUD_APP_STAGE) => Promise<void>): Promise<APICallReturn<{
        warnings: {
            stage: CRUD_APP_STAGE;
            error: Error;
        }[];
    }, {
        stage: CRUD_APP_STAGE;
        error: Error;
    }>>;
    updateApp(balanceToAdd: string, contractApp: ContractApp, appPayload: AppPayload, appModifier: AppModifier, ursulaParam: UrsulaParams, setCurrentStatus: (status: CRUD_APP_STAGE) => Promise<void>): Promise<APICallReturn<{
        warnings: {
            stage: CRUD_APP_STAGE;
            error: Error;
        }[];
    }, {
        stage: CRUD_APP_STAGE;
        error: Error;
    }>>;
    deleteApp(nftID: string, appID: string, setCurrentStatus: (status: CRUD_APP_STAGE) => Promise<void>): Promise<APICallReturn<{
        warnings: {
            stage: CRUD_APP_STAGE;
            error: Error;
        }[];
    }>>;
    getUrsulaAuth(userAddress: string): Promise<APICallReturn<UrsulaAuth>>;
    fetchAndDecryptApp(contractApp: ContractApp, userAddress: ETHAddress): Promise<APICallReturn<{
        appPayload: AppPayload;
        appModifier: AppModifier;
    }>>;
    getDeploymentStatusFromLogger(nftID: string, appID: string, loggerURL: string, timeSinceCRUD: Date, probeInterval?: number): Promise<APICallReturn<APICallReturn<string, string>>>;
}
