import { APICallReturn, AppPayload, CallerRole, ETHAddress, UrsulaKFrag, UrsulaParams, UrsulaReturnMap, UrsulaAuth, VerifiedCFrag, EncryptedPayloadWithKeys, EncryptedPayload, AppModifier } from "../types/types";
import { MessageTypes, TypedMessage } from "@metamask/eth-sig-util";
import { ethers } from "ethers";
import STKETHKeyEncrypter from "./STKETHKeyEncrypter";
import UmbralService from "./umbralService";
type DecryptedData = any;
export default class STKAppDecrypt {
    dec: TextDecoder;
    ethKeyEncrypt: STKETHKeyEncrypter;
    umbralService: UmbralService;
    constructor(ethKeyEncrypt: STKETHKeyEncrypter, umbralService: UmbralService);
    decryptByCreatorKeys(encryptPayload: EncryptedPayloadWithKeys, creatorSK: string): Promise<APICallReturn<DecryptedData>>;
    decryptReencrypted(encryptedPayload: EncryptedPayloadWithKeys, callerSK: number[], cfragList: VerifiedCFrag[]): Promise<APICallReturn<DecryptedData>>;
    decryptPayload(nftID: string, appID: string, encryptedPayload: EncryptedPayloadWithKeys, callerRole: CallerRole, ursulaAuth: UrsulaAuth): Promise<APICallReturn<DecryptedData, {
        error?: Error | undefined;
        ursulaError?: UrsulaReturnMap;
    } | Error>>;
    decryptApp(nftID: string, appID: string, encryptedApp: EncryptedPayloadWithKeys, encryptedAppModifier: EncryptedPayload | null, callerRole: CallerRole, ursulaAuth: UrsulaAuth): Promise<APICallReturn<{
        appPayload: AppPayload;
        appModifier?: AppModifier;
    }, {
        error?: Error | undefined;
        ursulaError?: UrsulaReturnMap;
    } | Error>>;
    signUserForDecryption(provider: ethers.providers.Provider, address: ETHAddress): Promise<APICallReturn<UrsulaAuth>>;
    getCFragList(nftID: string, appID: string, encryptedApp: EncryptedPayloadWithKeys, ursulaAuth: UrsulaAuth, callerRole: CallerRole, maxTryCount: number): Promise<APICallReturn<VerifiedCFrag[], {
        error?: Error | undefined;
        ursulaError: UrsulaReturnMap;
    }>>;
    getCFragListBatch(nftID: string, appID: string[], callerRole: CallerRole, encryptedDataBatch: EncryptedPayloadWithKeys[], ursulaAuth: UrsulaAuth, ursulaParams: UrsulaParams): Promise<APICallReturn<VerifiedCFrag[][], {
        error?: Error | undefined;
        ursulaError: UrsulaReturnMap[];
    }>>;
    callUrsulas(nftID: string, appID: string, ursulaParams: UrsulaParams, callerRole: CallerRole, ursulaAuth: UrsulaAuth, capsuleBytes: number[], kFragList: UrsulaKFrag[], prevCallStatus: UrsulaReturnMap): Promise<{
        successCount: number;
        data: UrsulaReturnMap;
    }>;
    typedMessage: (timestamp: number, chainId: number) => TypedMessage<MessageTypes>;
}
export {};
