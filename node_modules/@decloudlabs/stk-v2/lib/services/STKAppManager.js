"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = require("../types/types");
var axios_1 = __importDefault(require("axios"));
var ethers_1 = require("ethers");
var utils_1 = require("../utils/utils");
var STKAppManager = /** @class */ (function () {
    function STKAppManager(appCache, appStorage, contractService, appEncrypt, appDecryptor, saveAppToLocal, saveSubParamToLocal, removeAppFromLocal) {
        var _this = this;
        this.contractCall = {
            createApp: function (balanceToAdd, nftID, appName, path, subnetList, multiplier, resourceCount, resourceType, cidLock) { return __awaiter(_this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, utils_1.callContractWrite)(this.etherContracts.AppDeployment.createApp(balanceToAdd, nftID, appName, path, subnetList, multiplier, resourceCount, resourceType, cidLock))];
                        case 1:
                            result = _a.sent();
                            return [2 /*return*/, result];
                    }
                });
            }); },
            subscribeAndCreateApp: function (balanceToAdd, nftID, rlsAddresses, licenseFactor, appName, path, subnetList, multiplier, resourceCount, resourceType, cidLock) { return __awaiter(_this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, utils_1.callContractWrite)(this.etherContracts.AppDeployment.subscribeAndCreateApp(balanceToAdd, nftID, rlsAddresses, licenseFactor, appName, path, subnetList, multiplier, resourceCount, resourceType, cidLock))];
                        case 1:
                            result = _a.sent();
                            return [2 /*return*/, result];
                    }
                });
            }); },
            getAppList: function (nftID) { return __awaiter(_this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.AppDeployment.getAppList(nftID), function (res) { return res; })];
                        case 1:
                            result = _a.sent();
                            return [2 /*return*/, result];
                    }
                });
            }); },
            getCreateTime: function (nftID) { return __awaiter(_this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.Subscription.getCreateTime(nftID), function (res) { return res; })];
                        case 1:
                            result = _a.sent();
                            return [2 /*return*/, result];
                    }
                });
            }); },
            updateApp: function (balanceToAdd, nftID, appID, path, subnetList, multiplier, resourceCount, resourceType) { return __awaiter(_this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    result = (0, utils_1.callContractWrite)(this.etherContracts.AppDeployment.updateApp(balanceToAdd, nftID, appID, path, subnetList, multiplier, resourceCount, resourceType));
                    return [2 /*return*/, result];
                });
            }); },
            deleteApp: function (nftID, appID) { return __awaiter(_this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, utils_1.callContractWrite)(this.etherContracts.AppDeployment.deleteApp(nftID, appID))];
                        case 1:
                            result = _a.sent();
                            return [2 /*return*/, result];
                    }
                });
            }); },
            getSubnetAttributes: function (subnetID) { return __awaiter(_this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.SubnetCluster.getSubnetAttributes(subnetID), function (res) { return res; })];
                        case 1:
                            result = _a.sent();
                            return [2 /*return*/, result];
                    }
                });
            }); },
            getXCTAllowance: function (allowAddress, toAddress) { return __awaiter(_this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, utils_1.apiCallWrapper)(this.etherContracts.XCT.allowance(allowAddress, toAddress), function (res) { return res; })];
                        case 1:
                            result = _a.sent();
                            return [2 /*return*/, result];
                    }
                });
            }); },
            approveXCT: function (approveAddress, allowanceVal) { return __awaiter(_this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, (0, utils_1.callContractWrite)(this.etherContracts.XCT.approve(approveAddress, allowanceVal))];
                        case 1:
                            result = _a.sent();
                            return [2 /*return*/, result];
                    }
                });
            }); },
        };
        this.appCache = appCache;
        this.appStorage = appStorage;
        this.etherContracts = contractService;
        this.appEncrypt = appEncrypt;
        this.appDecryptor = appDecryptor;
        this.saveAppToLocal = saveAppToLocal;
        this.saveSubParamToLocal = saveSubParamToLocal;
        this.removeAppFromLocal = removeAppFromLocal;
    }
    STKAppManager.prototype.validateContractApp = function (contractApp) {
        if (contractApp.resourceCount.length != contractApp.resourceType.length) {
            return {
                success: false,
                data: Error("Mismatch between resource count and resource type"),
            };
        }
        if (contractApp.multiplier.length != contractApp.subnetList.length) {
            return {
                success: false,
                data: Error("InvalidMultiplierLengthError"),
            };
        }
        return {
            success: true,
            data: "",
        };
    };
    STKAppManager.prototype.getSubnetKeys = function (subnetList) {
        return __awaiter(this, void 0, void 0, function () {
            var subnetKFragMap, i, subnetID, subnetAttribResp, subnetAttributes, publicKeyString, publicKey, publicKeyArr;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        subnetKFragMap = {};
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < subnetList.length)) return [3 /*break*/, 4];
                        subnetID = subnetList[i];
                        return [4 /*yield*/, this.contractCall.getSubnetAttributes(subnetID)];
                    case 2:
                        subnetAttribResp = _a.sent();
                        if (subnetAttribResp.success == false)
                            return [2 /*return*/, subnetAttribResp];
                        subnetAttributes = subnetAttribResp.data;
                        publicKeyString = subnetAttributes.publicKey;
                        publicKey = publicKeyString.substring(2);
                        publicKeyArr = Array.from(Buffer.from(publicKey, "hex"));
                        subnetKFragMap[subnetID] = publicKeyArr;
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, {
                            success: true,
                            data: subnetKFragMap,
                        }];
                }
            });
        });
    };
    STKAppManager.prototype.saveAppToCache = function (contractApp, encryptedApp, appPayload, encryptedAppModifier, appModifier) {
        return __awaiter(this, void 0, void 0, function () {
            var warnings, appPath, modPath, resp, err_1, error;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        warnings = [];
                        appPath = contractApp.appPath, modPath = contractApp.modPath;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        return [4 /*yield*/, this.appCache.setEncryptedApp(this.etherContracts.selectedAccount, contractApp.nftID, contractApp.appID, {
                                appPath: appPath,
                                encryptedApp: encryptedApp,
                            })];
                    case 2:
                        resp = _a.sent();
                        if (resp.success == false)
                            warnings.push(resp.data);
                        return [4 /*yield*/, this.appCache.setAppPayload(this.etherContracts.selectedAccount, contractApp.nftID, contractApp.appID, {
                                appPath: appPath,
                                appPayload: appPayload,
                            })];
                    case 3:
                        resp = _a.sent();
                        if (resp.success == false)
                            warnings.push(resp.data);
                        return [4 /*yield*/, this.appCache.setEncryptedAppModifier(this.etherContracts.selectedAccount, contractApp.nftID, contractApp.appID, {
                                appPath: modPath,
                                encryptedAppModifier: encryptedAppModifier,
                            })];
                    case 4:
                        resp = _a.sent();
                        if (resp.success == false)
                            warnings.push(resp.data);
                        return [4 /*yield*/, this.appCache.setAppModifier(this.etherContracts.selectedAccount, contractApp.nftID, contractApp.appID, {
                                modPath: modPath,
                                appModifier: appModifier,
                            })];
                    case 5:
                        resp = _a.sent();
                        if (resp.success == false)
                            warnings.push(resp.data);
                        return [2 /*return*/, {
                                success: true,
                                data: { warning: warnings },
                            }];
                    case 6:
                        err_1 = _a.sent();
                        error = err_1;
                        return [2 /*return*/, {
                                success: false,
                                data: error,
                            }];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    STKAppManager.prototype.deleteAppFromCache = function (nftID, appID) {
        return __awaiter(this, void 0, void 0, function () {
            var warnings, resp, err_2, error;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        warnings = [];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        return [4 /*yield*/, this.appCache.deleteEncryptedApp(this.etherContracts.selectedAccount, nftID, appID)];
                    case 2:
                        resp = _a.sent();
                        if (resp.success == false)
                            warnings.push(resp.data);
                        return [4 /*yield*/, this.appCache.deleteAppPayload(this.etherContracts.selectedAccount, nftID, appID)];
                    case 3:
                        resp = _a.sent();
                        if (resp.success == false)
                            warnings.push(resp.data);
                        return [4 /*yield*/, this.appCache.deleteEncryptedAppModifier(this.etherContracts.selectedAccount, nftID, appID)];
                    case 4:
                        resp = _a.sent();
                        if (resp.success == false)
                            warnings.push(resp.data);
                        return [4 /*yield*/, this.appCache.deleteAppModifier(this.etherContracts.selectedAccount, nftID, appID)];
                    case 5:
                        resp = _a.sent();
                        if (resp.success == false)
                            warnings.push(resp.data);
                        return [2 /*return*/, {
                                success: true,
                                data: { warning: warnings },
                            }];
                    case 6:
                        err_2 = _a.sent();
                        error = err_2;
                        return [2 /*return*/, {
                                success: false,
                                data: error,
                            }];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    STKAppManager.prototype.approveBalanceWithdraw = function (balanceToAdd) {
        return __awaiter(this, void 0, void 0, function () {
            var allowanceResp, allowance, xctRequired, netAllowance, approveResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.contractCall.getXCTAllowance(this.etherContracts.selectedAccount, this.etherContracts.SubscriptionBalance.address)];
                    case 1:
                        allowanceResp = _a.sent();
                        allowance = allowanceResp.success
                            ? allowanceResp.data
                            : ethers_1.ethers.BigNumber.from("0");
                        xctRequired = ethers_1.ethers.BigNumber.from(balanceToAdd);
                        if (!allowance.lt(xctRequired)) return [3 /*break*/, 3];
                        netAllowance = xctRequired
                            .sub(allowance)
                            .mul(ethers_1.ethers.BigNumber.from("11"))
                            .div(ethers_1.ethers.BigNumber.from("10"));
                        return [4 /*yield*/, this.contractCall.approveXCT(this.etherContracts.SubscriptionBalance.address, netAllowance.toString())];
                    case 2:
                        approveResp = _a.sent();
                        if (!approveResp.success)
                            return [2 /*return*/, approveResp];
                        _a.label = 3;
                    case 3: return [2 /*return*/, {
                            success: true,
                            data: "",
                        }];
                }
            });
        });
    };
    STKAppManager.prototype.encryptNewApp = function (address, ursulaParam, contractApp, appPayload, appModifier) {
        return __awaiter(this, void 0, void 0, function () {
            var subnetPKResp, encryptedAppResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getSubnetKeys(contractApp.subnetList)];
                    case 1:
                        subnetPKResp = _a.sent();
                        if (subnetPKResp.success == false)
                            return [2 /*return*/, subnetPKResp];
                        return [4 /*yield*/, this.appEncrypt.encryptApp(address, ursulaParam, appPayload, appModifier, subnetPKResp.data)];
                    case 2:
                        encryptedAppResp = _a.sent();
                        return [2 /*return*/, encryptedAppResp];
                }
            });
        });
    };
    STKAppManager.prototype.encryptAppModifier = function (address, ursulaParam, contractApp, appPayload, appModifier) {
        return __awaiter(this, void 0, void 0, function () {
            var encryptedAppResp, encryptedApp, encryptedAppModResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.appStorage.setEncryptedAppToCache(address, [contractApp])];
                    case 1:
                        encryptedAppResp = _a.sent();
                        if (!encryptedAppResp.success)
                            return [2 /*return*/, encryptedAppResp];
                        encryptedApp = encryptedAppResp.data.encryptedAppList[0];
                        return [4 /*yield*/, this.appEncrypt.encryptWithCreatorKey(appModifier, encryptedApp.creator)];
                    case 2:
                        encryptedAppModResp = _a.sent();
                        if (!encryptedAppModResp.success)
                            return [2 /*return*/, encryptedAppModResp];
                        return [2 /*return*/, {
                                success: true,
                                data: {
                                    appPayload: encryptedApp,
                                    appModifier: encryptedAppModResp.data,
                                },
                            }];
                }
            });
        });
    };
    STKAppManager.prototype.encryptApp = function (address, ursulaParam, contractApp, appPayload, appModifier, cidLock) {
        return __awaiter(this, void 0, void 0, function () {
            var encryptResp, encryptResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!cidLock) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.encryptNewApp(address, ursulaParam, contractApp, appPayload, appModifier)];
                    case 1:
                        encryptResp = _a.sent();
                        return [2 /*return*/, encryptResp];
                    case 2: return [4 /*yield*/, this.encryptAppModifier(address, ursulaParam, contractApp, appPayload, appModifier)];
                    case 3:
                        encryptResp = _a.sent();
                        return [2 /*return*/, encryptResp];
                }
            });
        });
    };
    STKAppManager.prototype.sendEncryptedApp = function (contractApp, encryptedApp, encryptedAppModifier, cidLock) {
        return __awaiter(this, void 0, void 0, function () {
            var storageResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.appStorage.sendEncryptedApp(contractApp.appName, contractApp.nftID, contractApp.appID, encryptedApp, encryptedAppModifier, cidLock)];
                    case 1:
                        storageResp = _a.sent();
                        return [2 /*return*/, storageResp];
                }
            });
        });
    };
    STKAppManager.prototype.callSubscribeAndCreateApp = function (balanceToAdd, contractApp, subscriptionParam, dripRateFactors) {
        return __awaiter(this, void 0, void 0, function () {
            var createAppResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.contractCall.subscribeAndCreateApp(balanceToAdd, contractApp.nftID, [
                            subscriptionParam.platformAddress,
                            subscriptionParam.supportAddress,
                            subscriptionParam.licenseAddress,
                            subscriptionParam.referralAddress,
                        ], dripRateFactors.licenseFactor, ethers_1.ethers.utils.formatBytes32String(contractApp.appName), [contractApp.appPath, contractApp.modPath], contractApp.subnetList, contractApp.multiplier, contractApp.resourceCount, contractApp.resourceType, contractApp.cidLock)];
                    case 1:
                        createAppResp = _a.sent();
                        return [2 /*return*/, createAppResp];
                }
            });
        });
    };
    STKAppManager.prototype.callCreateApp = function (balanceToAdd, contractApp) {
        return __awaiter(this, void 0, void 0, function () {
            var createAppResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.contractCall.createApp(balanceToAdd, contractApp.nftID, ethers_1.ethers.utils.formatBytes32String(contractApp.appName), [contractApp.appPath, contractApp.modPath], contractApp.subnetList, contractApp.multiplier, contractApp.resourceCount, contractApp.resourceType, contractApp.cidLock)];
                    case 1:
                        createAppResp = _a.sent();
                        return [2 /*return*/, createAppResp];
                }
            });
        });
    };
    STKAppManager.prototype.fetchContractAppAndSaveToLocal = function (transactionHash, contractApp) {
        return __awaiter(this, void 0, void 0, function () {
            var appListResp, fetchedContractAppList, contractAppList, i, formattedApp, error;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.contractCall.getAppList(contractApp.nftID)];
                    case 1:
                        appListResp = _a.sent();
                        if (appListResp.success == true) {
                            fetchedContractAppList = appListResp.data;
                            contractAppList = [];
                            for (i = 0; i < fetchedContractAppList.length; i++) {
                                formattedApp = (0, utils_1.formatAppParams)(contractApp.nftID, fetchedContractAppList[i]);
                                contractAppList.push(formattedApp);
                                if (formattedApp.appName === contractApp.appName) {
                                    contractApp = formattedApp;
                                }
                            }
                            try {
                                this.saveAppToLocal(contractApp);
                            }
                            catch (err) {
                                error = err;
                                return [2 /*return*/, {
                                        success: false,
                                        data: error,
                                    }];
                            }
                        }
                        else {
                            return [2 /*return*/, appListResp];
                        }
                        return [2 /*return*/, {
                                success: true,
                                data: "",
                            }];
                }
            });
        });
    };
    STKAppManager.prototype.saveSubscriptionParam = function (subscriptionParam, contractApp) {
        return __awaiter(this, void 0, void 0, function () {
            var createTimeResp, saveSubParamResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.contractCall.getCreateTime(contractApp.nftID)];
                    case 1:
                        createTimeResp = _a.sent();
                        if (!(createTimeResp.success == true)) return [3 /*break*/, 3];
                        subscriptionParam.createTime = createTimeResp.data;
                        return [4 /*yield*/, this.saveSubParamToLocal(subscriptionParam)];
                    case 2:
                        saveSubParamResp = _a.sent();
                        if (saveSubParamResp.success == false)
                            return [2 /*return*/, saveSubParamResp];
                        return [3 /*break*/, 4];
                    case 3: return [2 /*return*/, createTimeResp];
                    case 4: return [2 /*return*/, {
                            success: true,
                            data: "",
                        }];
                }
            });
        });
    };
    STKAppManager.prototype.createApp = function (balanceToAdd, contractApp, subscriptionParam, dripRateFactors, appPayload, appModifier, ursulaParam, setCurrentStatus) {
        return __awaiter(this, void 0, void 0, function () {
            var warnings, validateContAppResp, encryptedAppResp, _a, encryptedApp, encryptedAppModifier, storageResp, _b, appPath, modPath, allowResp, transactionHash, createAppResp, createAppResp, timeSinceCreate, saveLocalResp, saveSubParamResp, resp, i, deployStatus;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        warnings = [];
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.CREATING_APP)];
                    case 1:
                        _c.sent();
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.VALIDATE_CONTRACT_APP)];
                    case 2:
                        _c.sent();
                        validateContAppResp = this.validateContractApp(contractApp);
                        if (!validateContAppResp.success)
                            return [2 /*return*/, {
                                    success: false,
                                    data: {
                                        stage: types_1.CRUD_APP_STAGE.VALIDATE_CONTRACT_APP,
                                        error: validateContAppResp.data,
                                    },
                                }];
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.ENCRYPTING_APP)];
                    case 3:
                        _c.sent();
                        return [4 /*yield*/, this.encryptApp(this.etherContracts.selectedAccount, ursulaParam, contractApp, appPayload, appModifier, false)];
                    case 4:
                        encryptedAppResp = _c.sent();
                        if (!encryptedAppResp.success)
                            return [2 /*return*/, {
                                    success: false,
                                    data: {
                                        stage: types_1.CRUD_APP_STAGE.ENCRYPTING_APP,
                                        error: encryptedAppResp.data,
                                    },
                                }];
                        _a = encryptedAppResp.data, encryptedApp = _a.appPayload, encryptedAppModifier = _a.appModifier;
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.SEND_APP_PAYLOAD_TO_STORAGE)];
                    case 5:
                        _c.sent();
                        return [4 /*yield*/, this.sendEncryptedApp(contractApp, encryptedApp, encryptedAppModifier, false)];
                    case 6:
                        storageResp = _c.sent();
                        if (!storageResp.success)
                            return [2 /*return*/, {
                                    success: false,
                                    data: {
                                        stage: types_1.CRUD_APP_STAGE.SEND_APP_PAYLOAD_TO_STORAGE,
                                        error: storageResp.data,
                                    },
                                }];
                        _b = storageResp.data, appPath = _b.appPath, modPath = _b.modPath;
                        contractApp.appPath = appPath;
                        contractApp.modPath = modPath;
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.APPROVE_BALANCE_WITHDRAW)];
                    case 7:
                        _c.sent();
                        return [4 /*yield*/, this.approveBalanceWithdraw(balanceToAdd)];
                    case 8:
                        allowResp = _c.sent();
                        if (!allowResp.success)
                            return [2 /*return*/, {
                                    success: false,
                                    data: {
                                        stage: types_1.CRUD_APP_STAGE.APPROVE_BALANCE_WITHDRAW,
                                        error: allowResp.data,
                                    },
                                }];
                        transactionHash = "";
                        if (!(subscriptionParam.createTime > 0)) return [3 /*break*/, 11];
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.CREATING_APP)];
                    case 9:
                        _c.sent();
                        return [4 /*yield*/, this.callCreateApp(balanceToAdd, contractApp)];
                    case 10:
                        createAppResp = _c.sent();
                        if (!createAppResp.success)
                            return [2 /*return*/, {
                                    success: false,
                                    data: {
                                        stage: types_1.CRUD_APP_STAGE.CREATING_APP,
                                        error: createAppResp.data,
                                    },
                                }];
                        transactionHash = createAppResp.data;
                        return [3 /*break*/, 14];
                    case 11: return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.SUBSCRIBING_CREATING_APP)];
                    case 12:
                        _c.sent();
                        return [4 /*yield*/, this.callSubscribeAndCreateApp(balanceToAdd, contractApp, subscriptionParam, dripRateFactors)];
                    case 13:
                        createAppResp = _c.sent();
                        if (!createAppResp.success)
                            return [2 /*return*/, {
                                    success: false,
                                    data: {
                                        stage: types_1.CRUD_APP_STAGE.SUBSCRIBING_CREATING_APP,
                                        error: createAppResp.data,
                                    },
                                }];
                        transactionHash = createAppResp.data;
                        _c.label = 14;
                    case 14:
                        timeSinceCreate = new Date();
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.CREATE_SUCCESSFUL)];
                    case 15:
                        _c.sent();
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.SAVING_CONTRACT_APP_LOCAL)];
                    case 16:
                        _c.sent();
                        return [4 /*yield*/, this.fetchContractAppAndSaveToLocal(transactionHash, contractApp)];
                    case 17:
                        saveLocalResp = _c.sent();
                        if (!saveLocalResp.success)
                            warnings.push({
                                stage: types_1.CRUD_APP_STAGE.SAVING_CONTRACT_APP_LOCAL,
                                error: saveLocalResp.data,
                            });
                        if (!(subscriptionParam.createTime === 0)) return [3 /*break*/, 20];
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.SAVING_SUBSCRIPTION_LOCAL)];
                    case 18:
                        _c.sent();
                        return [4 /*yield*/, this.saveSubscriptionParam(subscriptionParam, contractApp)];
                    case 19:
                        saveSubParamResp = _c.sent();
                        if (!saveSubParamResp.success)
                            warnings.push({
                                stage: types_1.CRUD_APP_STAGE.SAVING_SUBSCRIPTION_LOCAL,
                                error: saveSubParamResp.data,
                            });
                        _c.label = 20;
                    case 20: return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.SAVE_APP_TO_CACHE)];
                    case 21:
                        _c.sent();
                        return [4 /*yield*/, this.saveAppToCache(contractApp, encryptedApp, appPayload, encryptedApp, appModifier)];
                    case 22:
                        resp = _c.sent();
                        if (resp.success) {
                            for (i = 0; i < resp.data.warning.length; i++) {
                                warnings.push({
                                    stage: types_1.CRUD_APP_STAGE.SAVE_APP_TO_CACHE,
                                    error: resp.data.warning[i],
                                });
                            }
                        }
                        else {
                            warnings.push({
                                stage: types_1.CRUD_APP_STAGE.SAVE_APP_TO_CACHE,
                                error: resp.data,
                            });
                        }
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.GET_APP_DEPLOY_STATUS)];
                    case 23:
                        _c.sent();
                        if (!appModifier.loggerURL) return [3 /*break*/, 25];
                        return [4 /*yield*/, this.getDeploymentStatusFromLogger(contractApp.nftID, contractApp.appID, appModifier.loggerURL, timeSinceCreate)];
                    case 24:
                        deployStatus = _c.sent();
                        if (deployStatus.success) {
                            if (!deployStatus.data.success) {
                                warnings.push({
                                    stage: types_1.CRUD_APP_STAGE.GET_APP_DEPLOY_STATUS,
                                    error: new Error(deployStatus.data.data),
                                });
                            }
                        }
                        else {
                            warnings.push({
                                stage: types_1.CRUD_APP_STAGE.GET_APP_DEPLOY_STATUS,
                                error: deployStatus.data,
                            });
                        }
                        _c.label = 25;
                    case 25: return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.CREATE_SUCCESSFUL)];
                    case 26:
                        _c.sent();
                        return [2 /*return*/, { success: true, data: { warnings: warnings } }];
                }
            });
        });
    };
    STKAppManager.prototype.updateApp = function (balanceToAdd, contractApp, appPayload, appModifier, ursulaParam, setCurrentStatus) {
        return __awaiter(this, void 0, void 0, function () {
            var warnings, validateContAppResp, encryptedAppResp, _a, encryptedApp, encryptedAppModifier, storageResp, _b, appPath, modPath, allowResp, updateResp, timeSinceUpdate, saveLocalResp, resp, i, deployStatus;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        warnings = [];
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.STARTING_UPDATE_APP)];
                    case 1:
                        _c.sent();
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.VALIDATE_CONTRACT_APP)];
                    case 2:
                        _c.sent();
                        validateContAppResp = this.validateContractApp(contractApp);
                        if (!validateContAppResp.success)
                            return [2 /*return*/, {
                                    success: false,
                                    data: {
                                        stage: types_1.CRUD_APP_STAGE.VALIDATE_CONTRACT_APP,
                                        error: validateContAppResp.data,
                                    },
                                }];
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.ENCRYPTING_APP)];
                    case 3:
                        _c.sent();
                        return [4 /*yield*/, this.encryptApp(this.etherContracts.selectedAccount, ursulaParam, contractApp, appPayload, appModifier, contractApp.cidLock)];
                    case 4:
                        encryptedAppResp = _c.sent();
                        if (!encryptedAppResp.success)
                            return [2 /*return*/, {
                                    success: false,
                                    data: {
                                        stage: types_1.CRUD_APP_STAGE.ENCRYPTING_APP,
                                        error: encryptedAppResp.data,
                                    },
                                }];
                        _a = encryptedAppResp.data, encryptedApp = _a.appPayload, encryptedAppModifier = _a.appModifier;
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.SEND_APP_PAYLOAD_TO_STORAGE)];
                    case 5:
                        _c.sent();
                        return [4 /*yield*/, this.sendEncryptedApp(contractApp, encryptedApp, encryptedAppModifier, false)];
                    case 6:
                        storageResp = _c.sent();
                        if (!storageResp.success)
                            return [2 /*return*/, {
                                    success: false,
                                    data: {
                                        stage: types_1.CRUD_APP_STAGE.SEND_APP_PAYLOAD_TO_STORAGE,
                                        error: storageResp.data,
                                    },
                                }];
                        _b = storageResp.data, appPath = _b.appPath, modPath = _b.modPath;
                        if (!contractApp.cidLock)
                            contractApp.appPath = appPath;
                        contractApp.modPath = modPath;
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.APPROVE_BALANCE_WITHDRAW)];
                    case 7:
                        _c.sent();
                        return [4 /*yield*/, this.approveBalanceWithdraw(balanceToAdd)];
                    case 8:
                        allowResp = _c.sent();
                        if (!allowResp.success)
                            return [2 /*return*/, {
                                    success: false,
                                    data: {
                                        stage: types_1.CRUD_APP_STAGE.APPROVE_BALANCE_WITHDRAW,
                                        error: allowResp.data,
                                    },
                                }];
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.UPDATING_APP)];
                    case 9:
                        _c.sent();
                        return [4 /*yield*/, this.contractCall.updateApp(balanceToAdd, contractApp.nftID, contractApp.appID, [contractApp.appPath, contractApp.modPath], contractApp.subnetList, contractApp.multiplier, contractApp.resourceCount, contractApp.resourceType)];
                    case 10:
                        updateResp = _c.sent();
                        if (!updateResp.success)
                            return [2 /*return*/, {
                                    success: false,
                                    data: {
                                        stage: types_1.CRUD_APP_STAGE.UPDATING_APP,
                                        error: updateResp.data,
                                    },
                                }];
                        timeSinceUpdate = new Date();
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.SAVING_CONTRACT_APP_LOCAL)];
                    case 11:
                        _c.sent();
                        return [4 /*yield*/, this.saveAppToLocal(contractApp)];
                    case 12:
                        saveLocalResp = _c.sent();
                        if (!saveLocalResp.success)
                            warnings.push({
                                stage: types_1.CRUD_APP_STAGE.SAVING_CONTRACT_APP_LOCAL,
                                error: saveLocalResp.data,
                            });
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.SAVE_APP_TO_CACHE)];
                    case 13:
                        _c.sent();
                        return [4 /*yield*/, this.saveAppToCache(contractApp, encryptedApp, appPayload, encryptedApp, appModifier)];
                    case 14:
                        resp = _c.sent();
                        if (resp.success) {
                            for (i = 0; i < resp.data.warning.length; i++) {
                                warnings.push({
                                    stage: types_1.CRUD_APP_STAGE.SAVE_APP_TO_CACHE,
                                    error: resp.data.warning[i],
                                });
                            }
                        }
                        else {
                            warnings.push({
                                stage: types_1.CRUD_APP_STAGE.SAVE_APP_TO_CACHE,
                                error: resp.data,
                            });
                        }
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.GET_APP_DEPLOY_STATUS)];
                    case 15:
                        _c.sent();
                        if (!appModifier.loggerURL) return [3 /*break*/, 17];
                        return [4 /*yield*/, this.getDeploymentStatusFromLogger(contractApp.nftID, contractApp.appID, appModifier.loggerURL, timeSinceUpdate)];
                    case 16:
                        deployStatus = _c.sent();
                        if (deployStatus.success) {
                            if (!deployStatus.data.success) {
                                warnings.push({
                                    stage: types_1.CRUD_APP_STAGE.GET_APP_DEPLOY_STATUS,
                                    error: new Error(deployStatus.data.data),
                                });
                            }
                        }
                        else {
                            warnings.push({
                                stage: types_1.CRUD_APP_STAGE.GET_APP_DEPLOY_STATUS,
                                error: deployStatus.data,
                            });
                        }
                        _c.label = 17;
                    case 17: return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.UPDATE_SUCCESSFUL)];
                    case 18:
                        _c.sent();
                        return [2 /*return*/, { success: true, data: { warnings: warnings } }];
                }
            });
        });
    };
    STKAppManager.prototype.deleteApp = function (nftID, appID, setCurrentStatus) {
        return __awaiter(this, void 0, void 0, function () {
            var warnings, deleteResp, removeCacheResp, removeLocalResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        warnings = [];
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.DELETING_APP)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.contractCall.deleteApp(nftID, appID)];
                    case 2:
                        deleteResp = _a.sent();
                        if (deleteResp.success == false)
                            return [2 /*return*/, deleteResp];
                        return [4 /*yield*/, setCurrentStatus(types_1.CRUD_APP_STAGE.DELETE_APP_FROM_CACHE)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, this.deleteAppFromCache(nftID, appID)];
                    case 4:
                        removeCacheResp = _a.sent();
                        if (removeCacheResp.success == false)
                            warnings.push({
                                stage: types_1.CRUD_APP_STAGE.DELETE_APP_FROM_CACHE,
                                error: removeCacheResp.data,
                            });
                        return [4 /*yield*/, this.removeAppFromLocal(nftID, appID)];
                    case 5:
                        removeLocalResp = _a.sent();
                        if (removeLocalResp.success == false)
                            warnings.push({
                                stage: types_1.CRUD_APP_STAGE.DELETE_CONTRACT_APP_LOCAL,
                                error: removeLocalResp.data,
                            });
                        return [2 /*return*/, {
                                success: true,
                                data: { warnings: warnings },
                            }];
                }
            });
        });
    };
    STKAppManager.prototype.getUrsulaAuth = function (userAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var authResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.appDecryptor.signUserForDecryption(this.etherContracts.Provider, userAddress)];
                    case 1:
                        authResp = _a.sent();
                        return [2 /*return*/, authResp];
                }
            });
        });
    };
    STKAppManager.prototype.fetchAndDecryptApp = function (contractApp, userAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var appStage, appModStage, cacheAppResp, setAppCacheResp, cacheModResp, setModCacheResp, setAppCacheResp, ursulaAuthResp, decryptAppResp, ursulaAuthResp, decryptAppResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.appCache.getAppPayload(userAddress, contractApp.nftID, contractApp.appID)];
                    case 1:
                        cacheAppResp = _a.sent();
                        if (!(cacheAppResp.success == false ||
                            cacheAppResp.data.appPath !== contractApp.appPath)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.appStorage.setEncryptedAppToCache(userAddress, [
                                contractApp,
                            ])];
                    case 2:
                        setAppCacheResp = _a.sent();
                        if (setAppCacheResp.success == false)
                            throw setAppCacheResp.data;
                        appStage = {
                            state: "encrypted",
                            encryptedApp: setAppCacheResp.data.encryptedAppList[0],
                        };
                        return [3 /*break*/, 4];
                    case 3:
                        appStage = {
                            state: "decrypted",
                            appPayload: cacheAppResp.data.appPayload,
                        };
                        _a.label = 4;
                    case 4: return [4 /*yield*/, this.appCache.getAppModifier(userAddress, contractApp.nftID, contractApp.appID)];
                    case 5:
                        cacheModResp = _a.sent();
                        if (!(cacheModResp.success == false ||
                            cacheModResp.data.modPath !== contractApp.modPath)) return [3 /*break*/, 10];
                        return [4 /*yield*/, this.appStorage.setEncryptedAppModifierToCache(userAddress, [contractApp])];
                    case 6:
                        setModCacheResp = _a.sent();
                        if (setModCacheResp.success == false)
                            throw setModCacheResp.data;
                        if (!(appStage.state === "encrypted")) return [3 /*break*/, 7];
                        appModStage = {
                            state: "encrypted",
                            encryptedApp: appStage.encryptedApp,
                            encryptedAppMod: setModCacheResp.data.encryptedAppModifierList[0],
                        };
                        return [3 /*break*/, 9];
                    case 7: return [4 /*yield*/, this.appStorage.setEncryptedAppToCache(userAddress, [
                            contractApp,
                        ])];
                    case 8:
                        setAppCacheResp = _a.sent();
                        if (setAppCacheResp.success == false)
                            throw setAppCacheResp.data;
                        appModStage = {
                            state: "encrypted",
                            encryptedApp: setAppCacheResp.data.encryptedAppList[0],
                            encryptedAppMod: setModCacheResp.data.encryptedAppModifierList[0],
                        };
                        _a.label = 9;
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        appModStage = {
                            state: "decrypted",
                            appModifier: cacheModResp.data.appModifier,
                        };
                        _a.label = 11;
                    case 11:
                        if (!(appStage.state === "encrypted")) return [3 /*break*/, 16];
                        return [4 /*yield*/, this.getUrsulaAuth(userAddress)];
                    case 12:
                        ursulaAuthResp = _a.sent();
                        if (ursulaAuthResp.success == false)
                            throw ursulaAuthResp.data;
                        console.log("appStage: ", appStage, appModStage);
                        return [4 /*yield*/, this.appDecryptor.decryptApp(contractApp.nftID, contractApp.appID, appStage.encryptedApp, appModStage.state == "encrypted"
                                ? appModStage.encryptedAppMod
                                : null, {
                                roleType: "OWNER",
                                callerAddress: userAddress,
                            }, ursulaAuthResp.data)];
                    case 13:
                        decryptAppResp = _a.sent();
                        if (decryptAppResp.success == false)
                            throw decryptAppResp.data;
                        appStage = {
                            state: "decrypted",
                            appPayload: decryptAppResp.data.appPayload,
                        };
                        return [4 /*yield*/, this.appCache.setAppPayload(userAddress, contractApp.nftID, contractApp.appID, {
                                appPath: contractApp.appPath,
                                appPayload: appStage.appPayload,
                            })];
                    case 14:
                        _a.sent();
                        if (!decryptAppResp.data.appModifier) return [3 /*break*/, 16];
                        appModStage = {
                            state: "decrypted",
                            appModifier: decryptAppResp.data.appModifier,
                        };
                        return [4 /*yield*/, this.appCache.setAppModifier(userAddress, contractApp.nftID, contractApp.appID, {
                                modPath: contractApp.modPath,
                                appModifier: appModStage.appModifier,
                            })];
                    case 15:
                        _a.sent();
                        _a.label = 16;
                    case 16:
                        if (!(appModStage.state === "encrypted")) return [3 /*break*/, 19];
                        return [4 /*yield*/, this.getUrsulaAuth(userAddress)];
                    case 17:
                        ursulaAuthResp = _a.sent();
                        if (ursulaAuthResp.success == false)
                            throw ursulaAuthResp.data;
                        return [4 /*yield*/, this.appDecryptor.decryptPayload(contractApp.nftID, contractApp.appID, __assign(__assign({}, appModStage.encryptedApp), appModStage.encryptedAppMod), {
                                roleType: "OWNER",
                                callerAddress: userAddress,
                            }, ursulaAuthResp.data)];
                    case 18:
                        decryptAppResp = _a.sent();
                        console.log("decrypt app resp: ", __assign(__assign({}, appModStage.encryptedApp), appModStage.encryptedAppMod));
                        if (decryptAppResp.success == false)
                            throw decryptAppResp.data;
                        appModStage = {
                            state: "decrypted",
                            appModifier: decryptAppResp.data,
                        };
                        _a.label = 19;
                    case 19: return [2 /*return*/, {
                            success: true,
                            data: {
                                appPayload: appStage.appPayload,
                                appModifier: appModStage.appModifier,
                            },
                        }];
                }
            });
        });
    };
    // APICallReturn<string, string>
    STKAppManager.prototype.getDeploymentStatusFromLogger = function (nftID, appID, loggerURL, timeSinceCRUD, probeInterval) {
        if (probeInterval === void 0) { probeInterval = 2000; }
        return __awaiter(this, void 0, void 0, function () {
            var MINUTE, res, appStatusLogResp, appStatusLogList, errorLog, err_3, error;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        MINUTE = 60 * 60 * 24 * 1000;
                        _a.label = 1;
                    case 1:
                        if (!true) return [3 /*break*/, 7];
                        if (new Date().getTime() - timeSinceCRUD.getTime() > MINUTE) {
                            return [2 /*return*/, {
                                    success: false,
                                    data: new Error("Error: Timed out at getting deployment status"),
                                }];
                        }
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 5, , 6]);
                        return [4 /*yield*/, axios_1.default.get("".concat(loggerURL, "/appStatus/").concat(nftID, "/").concat(appID, "/").concat(timeSinceCRUD.toISOString()))];
                    case 3:
                        res = _a.sent();
                        appStatusLogResp = res.data;
                        if (appStatusLogResp.success) {
                            appStatusLogList = appStatusLogResp.data;
                            if (appStatusLogList.find(function (appStatusLog) { return appStatusLog.logType === "success"; })) {
                                return [2 /*return*/, {
                                        success: true,
                                        data: {
                                            success: true,
                                            data: "",
                                        },
                                    }];
                            }
                            errorLog = appStatusLogList.find(function (appStatusLog) { return appStatusLog.logType === "error"; });
                            if (errorLog) {
                                return [2 /*return*/, {
                                        success: true,
                                        data: {
                                            success: false,
                                            data: errorLog.message,
                                        },
                                    }];
                            }
                        }
                        return [4 /*yield*/, (0, utils_1.sleep)(probeInterval)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        err_3 = _a.sent();
                        error = err_3;
                        return [2 /*return*/, { success: false, data: error }];
                    case 6: return [3 /*break*/, 1];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    return STKAppManager;
}());
exports.default = STKAppManager;
