import { APICallReturn, BalancesForSubscription, ContractApp, DripRateFactors, ETHAddress, EtherContracts, SubBalanceEstimate, SubscriptionParam } from "../types/types";
export default class STKDripRateManager {
    stepUpFactor: string;
    etherContracts: EtherContracts;
    constructor(stepUpFactor: string | undefined, contractService: EtherContracts);
    getWalletBalance: (walletAddress: ETHAddress) => Promise<APICallReturn<string, Error>>;
    getSubscriptionBalance: (nftID: string) => Promise<APICallReturn<string>>;
    getSupportFeesForNFT: (supportAddress: ETHAddress, nftID: string) => Promise<APICallReturn<[number, number]>>;
    estimateDripRatePerSec: (subnetListBatch: string[], factors: number[], multipliedResourceBatch: number[][], resourceTypeBatch: number[][]) => Promise<APICallReturn<string>>;
    getSubscribeTime: (nftID: string) => Promise<APICallReturn<number>>;
    getPlatformFactors: (platformAddress: ETHAddress) => Promise<APICallReturn<{
        platformPercentage: number;
        referralPercentage: number;
        discountPercentage: number;
        referralExpiryDuration: number;
    }>>;
    getPlatformAddress: (nftID: string) => Promise<APICallReturn<string, Error>>;
    getSupportAddress: (nftID: string) => Promise<APICallReturn<string, Error>>;
    getLicenseAddress: (nftID: string) => Promise<APICallReturn<string, Error>>;
    getReferralAddress: (nftID: string) => Promise<APICallReturn<string, Error>>;
    getSupportFactor: (nftID: string) => Promise<APICallReturn<[number, number], Error>>;
    getLicenseFactor: (nftID: string) => Promise<APICallReturn<[number, number], Error>>;
    estimateETHForXCT: (uniswapRouterV2Address: ETHAddress, wethAddress: ETHAddress, netXCTRequired: string) => Promise<APICallReturn<string, Error>>;
    getStepUpFactor: () => Promise<APICallReturn<string, Error>>;
    buyXCTWithETH: (uniswapRouterV2Address: ETHAddress, wethAddress: ETHAddress, usdcRequired: string, deadline: number, ethRequired: string) => Promise<APICallReturn<any, Error>>;
    approveXCT: (approvedAddress: string, xctRequired: string) => Promise<APICallReturn<any, Error>>;
    addSubscriptionBalance: (accountAddress: ETHAddress, nftID: string, xctRequired: string) => Promise<APICallReturn<any, Error>>;
    getBalanceEndTime: (nftID: string) => Promise<APICallReturn<number, Error>>;
    calcSubnetComputes: (contractAppList: ContractApp[]) => {
        subnetListBatch: string[];
        multipliedResourceBatch: number[][];
        resourceTypeBatch: number[][];
    };
    estimateDripRate(contractAppList: ContractApp[], dripRateFactors: DripRateFactors, subscriptionParam: SubscriptionParam): Promise<APICallReturn<string>>;
    estimateBalanceEndTime(balancesForSubscription: BalancesForSubscription, dripRate: string): string;
    getBalancesForSubscription(nftID: string): Promise<APICallReturn<BalancesForSubscription>>;
    getSubscriptionParam(nftID: string): Promise<APICallReturn<SubscriptionParam>>;
    getDripRateFactors(nftID: string, subscriptionParam: SubscriptionParam): Promise<APICallReturn<DripRateFactors>>;
    estimateETHRequired(timePeriod: number, balancesForSubscription: BalancesForSubscription, dripRate: string, uniswapRouterV2Address: ETHAddress, wethAddress: ETHAddress): Promise<APICallReturn<SubBalanceEstimate>>;
    convertXCTToUSDC(xctRequired: string): Promise<APICallReturn<string>>;
    purchaseXCT(nftID: string, subBalanceEstimate: SubBalanceEstimate, uniswapRouterV2Address: ETHAddress, wethAddress: ETHAddress): Promise<APICallReturn<{
        subBalanceEstimate: SubBalanceEstimate;
        balancesForSubscription: BalancesForSubscription;
    }>>;
    addSubscriptionCredit(nftID: string, subBalanceEstimate: SubBalanceEstimate): Promise<APICallReturn<{
        subBalanceEstimate: SubBalanceEstimate;
        balancesForSubscription: BalancesForSubscription;
        balanceEndTime: number;
    }>>;
}
