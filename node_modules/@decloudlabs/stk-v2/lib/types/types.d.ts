import { TypedMessage, MessageTypes } from "@metamask/eth-sig-util/dist/sign-typed-data";
import * as umbral from "@nucypher/umbral-pre";
import { ethers } from "ethers";
export type SecretKey = umbral.SecretKey;
export type PublicKey = umbral.PublicKey;
export type Signer = umbral.Signer;
export type Capsule = umbral.Capsule;
export type ETHAddress = string;
export type CipherText = Uint8Array;
export type CapsuleBytes = number[];
export type VerifiedCFrag = umbral.VerifiedCapsuleFrag;
export type VerifiedKFrag = umbral.VerifiedKeyFrag;
export type ETHPublicKey = string;
export type Provider = ethers.providers.Provider;
export type CFragBytes = number[];
export type CLUSTER_WALLET_ADDRESS = string;
export type SubnetPKMap = {
    [subnetID: string]: number[];
};
export type CallerRole = {
    roleType: "OWNER";
    callerAddress: ETHAddress;
} | {
    roleType: "READ";
    callerAddress: ETHAddress;
} | {
    roleType: "CLUSTER";
    subnetID: string;
    clusterID: string;
    clusterAddress: ETHAddress;
    secretKey: number[];
} | {
    roleType: "OWNER_URSULA";
    callerAddress: ETHAddress;
};
export interface ContractAddresses {
    stack: string;
    Registration: string;
    Subscription: string;
    xct: string;
    appNFT: string;
    darkMatterNFT: string;
    darkMatterNFTMinter: string;
    appNFTMinter: string;
    AppDeployment: string;
    SubscriptionBalance: string;
    SubnetDAODistributor: string;
    SubscriptionBalanceCalculator: string;
    xctMinter: string;
}
export interface EtherContracts {
    selectedAccount: ETHAddress;
    DarkMatterNFT: ethers.Contract;
    Stack: ethers.Contract;
    SubnetCluster: ethers.Contract;
    Subscription: ethers.Contract;
    XCT: ethers.Contract;
    AppNFT: ethers.Contract;
    AppNFTMinter: ethers.Contract;
    AppDeployment: ethers.Contract;
    SubscriptionBalance: ethers.Contract;
    SubnetDAODistributor: ethers.Contract;
    SubscriptionBalanceCalculator: ethers.Contract;
    XCTMinter: ethers.Contract;
    Provider: ethers.providers.Provider;
}
export interface UrsulaParams {
    kfragCount: number;
    kfragThreshold: number;
    ursulaNFTOwnerAPI: string;
    ursulaRoleAPI: string;
    ursulaClusterAPI: string;
    ursulaPKList: string[];
    ursulaURLList: string[];
}
export interface UrsulaKFrag {
    kfrag: number[];
}
export interface CreatorKey {
    creatorAddress: ETHAddress;
    publicKey: number[];
    secretKey: number[];
}
export interface ReaderKey {
    publicKey: number[];
    secretKey: number[];
    kFragList: UrsulaKFrag[];
}
export interface ContractApp {
    nftID: string;
    appID: string;
    appName: string;
    appPath: string;
    modPath: string;
    subnetList: string[];
    resourceCount: number[];
    resourceType: number[];
    cidLock: boolean;
    multiplier: number[][];
}
export interface SubnetKFragMap {
    [subnetID: string]: UrsulaKFrag[];
}
export interface EncryptedPayload {
    capsule: CapsuleBytes;
    cipherText: number[];
}
export interface EncryptedPayloadWithKeys {
    creator: CreatorKey;
    reader: ReaderKey;
    capsule: CapsuleBytes;
    cipherText: number[];
    ursulaParams: UrsulaParams;
    subnetKFragMap: SubnetKFragMap;
}
export interface SavedEncryptedPayloadWithKeys {
    creator: {
        creatorAddress: ETHAddress;
        publicKey: number[];
        secretKey: number[];
    };
    reader: {
        publicKey: number[];
        secretKey: number[];
        kFragList: UrsulaKFrag[];
    };
    capsule: number[];
    cipherText: number[];
    ursulaParams: UrsulaParams;
    subnetKFragMap: {
        [subnetID: string]: UrsulaKFrag[];
    };
}
export interface SavedEncryptedPayload {
    capsule: number[];
    cipherText: number[];
}
export interface CachedEncryptedApp {
    appPath: string;
    encryptedApp: EncryptedPayloadWithKeys;
}
export interface CachedEncryptedAppModifier {
    appPath: string;
    encryptedAppModifier: EncryptedPayload;
}
export interface ResourceUnit {
    memory: number;
    cpu: number;
    disk?: number;
}
export interface CreateAppVolumeMounts {
    mountPath: string;
    name: string;
}
export interface CreateAppEnvVariables {
    name: string;
    value: string;
}
export interface CreateAppImage {
    repository: string;
    tag: string;
}
export interface Port {
    containerPort: string;
    servicePort: string;
    hostUrl?: string;
}
export interface AttribVariableParam {
    name: string;
    condition: string;
    conditionDescription?: string;
    defaultValue?: string;
}
export interface AppPayload {
    appName: string;
    namespace: string;
    nftID: string;
    containers: {
        name: string;
        image: string;
        tcpPorts: Port[];
        httpPorts: Port[];
        args?: string[];
        commands?: string[];
        envVariables?: CreateAppEnvVariables[];
        volumeMounts?: CreateAppVolumeMounts[];
        resourceLimits: ResourceUnit;
        resourceRequests: ResourceUnit;
    }[];
    replicaCount: number;
    whitelistedIps: string[];
    persistence: {
        name: string;
        accessMode: "ReadWriteOnce";
        storageType: "standard" | "ssd-sc";
        storageSize?: string;
    }[];
    status: string;
    privateImage?: {
        registry: string;
        username: string;
        password: string;
    };
    attribVarList?: AttribVariableParam[];
    createHostURL?: {
        containerID: number;
        httpPortID: number;
    };
}
export interface CachedAppPayload {
    appPath: string;
    appPayload: AppPayload;
}
export interface CachedAppModifier {
    modPath: string;
    appModifier: AppModifier;
}
export interface AppModifier {
    modAttribVar: {
        [index: string]: any;
    };
    contractParam: {
        resourceCount?: number[];
        resourceType?: number[];
        multiplier?: {
            [subnetID: string]: number[];
        };
    };
    loggerURL: string;
}
export interface NFTLog {
    nftID: string;
    logType: "success" | "operation" | "validation" | "error";
    logID: string;
    timestamp: Date;
    appID?: string;
    appName?: string;
    operation: string;
    message: string;
}
export interface AppStatusLog extends NFTLog {
    appID: string;
    appName: string;
    logURL: string;
}
export interface SubscriptionParam {
    licenseAddress: ETHAddress;
    supportAddress: ETHAddress;
    platformAddress: ETHAddress;
    referralAddress: ETHAddress;
    createTime: number;
}
export interface APICallReturnSuccess<T> {
    success: true;
    data: T;
    statusCode?: number;
}
export interface APICallReturnError<E> {
    success: false;
    data: E;
    statusCode?: number;
}
export type APICallReturn<T, E = Error> = APICallReturnSuccess<T> | APICallReturnError<E>;
export interface UrsulaAuth {
    userAddress: string;
    signature: string;
    message: TypedMessage<MessageTypes>;
}
export interface UrsulaReturnMap {
    [index: number]: APICallReturn<CFragBytes, Error>;
}
export type APIResponse<K, E> = {
    resp: K;
    success: true;
} | {
    resp: E;
    success: false;
};
export declare enum RESTYPE_NAME_TO_ID_MAP {
    cpuStandard = 0,
    cpuIntensive = 1,
    gpuStandard = 2,
    storage = 3,
    bandwidth = 4,
    ipfsUpload = 5
}
export declare enum RESTYPE_ID_TO_NAME_MAP {
    cpuStandard = "cpuStandard",
    cpuIntensive = "cpuIntensive",
    gpuStandard = "gpuStandard",
    storage = "storage",
    bandwidth = "bandwidth",
    ipfsUpload = "ipfsUpload"
}
export type RESOURCE_CATEGORY_STRING = "cpuType" | "storageType" | "bandwidthType" | "fileType";
export declare const RESOURCE_CATEGORY: Record<RESOURCE_CATEGORY_STRING, number[]>;
export type SubnetReplicaMap = {
    [subnetId: string]: {
        [key in RESOURCE_CATEGORY_STRING]: number;
    };
};
export type resTypeAndCount<T extends RESOURCE_CATEGORY_STRING> = {
    resType: (typeof RESOURCE_CATEGORY)[T];
    resCount: number;
};
export type ResourceMap = {
    cpuType?: resTypeAndCount<"cpuType">;
    storageType?: resTypeAndCount<"storageType">;
    bandwidthType?: resTypeAndCount<"bandwidthType">;
    fileType?: resTypeAndCount<"fileType">;
};
export declare enum CRUD_APP_STAGE {
    STARTING_CREATE_APP = "STARTING_CREATE_APP",
    STARTING_UPDATE_APP = "STARTING_UPDATE_APP",
    STARTING_DELETE_APP = "STARTING_DELETE_APP",
    VALIDATE_CONTRACT_APP = "VALIDATE_CONTRACT_APP",
    CREATING_APP = "CREATING_APP",
    UPDATING_APP = "UPDATING_APP",
    UPDATING_CID = "UPDATING_CID",
    DELETING_APP = "DELETING_APP",
    APPROVE_BALANCE_WITHDRAW = "APPROVE_BALANCE_WITHDRAW",
    SUBSCRIBING_CREATING_APP = "SUBSCRIBING_CREATING_APP",
    SAVING_CONTRACT_APP_LOCAL = "SAVING_CONTRACT_APP_LOCAL",
    SAVING_SUBSCRIPTION_LOCAL = "SAVING_SUBSCRIPTION_LOCAL",
    DELETE_CONTRACT_APP_LOCAL = "DELETE_CONTRACT_APP_LOCAL",
    ENCRYPTING_APP = "ENCRYPTING_APP",
    SEND_APP_PAYLOAD_TO_STORAGE = "SEND_APP_PAYLOAD_TO_STORAGE",
    SAVE_APP_TO_CACHE = "SAVE_APP_TO_CACHE",
    DELETE_APP_FROM_CACHE = "DELETE_APP_FROM_CACHE",
    GET_APP_DEPLOY_STATUS = "GET_APP_DEPLOY_STATUS",
    DELETE_SUCCESSFUL = "DELETE_SUCCESSFUL",
    CREATE_SUCCESSFUL = "CREATE_SUCCESSFUL",
    UPDATE_SUCCESSFUL = "UPDATE_SUCCESSFUL"
}
export interface SubnetAttributes {
    CLUSTER_LIST_ROLE: string;
    PRICE_ROLE: string;
    SUBNET_ATTR_ROLE: string;
    SUBNET_DAO_ROLE: string;
    WHITELIST_ROLE: string;
    dnsip: string;
    maxClusters: number;
    otherAttributes: any;
    publicKey: string;
    stackFeesReqd: string;
    subnetLocalDAO: string;
    subnetName: string;
    subnetStatusListed: string;
    subnetType: string;
    subnetID: string;
}
export interface SubnetNameAndID {
    subnetName: string;
    subnetID: string;
}
export interface ClustersOfSubnet {
    clusterId: number;
    subnetId: string;
    wallet: ETHAddress;
    owner: ETHAddress;
    operator: ETHAddress;
    publicKey: ETHAddress;
    dnsIp: string;
    listed: string;
    NFTIdLocked: string;
    clusterName: string;
}
export type DripRateFactors = {
    licenseFactor: [number, number];
    supportFactor: [number, number];
    platformFactor: number;
    referralFactor: number;
    discountFactor: number;
    referralExpiryDuration: number;
    createTime: number;
};
export type ResTypeAndCount<T extends keyof typeof RESOURCE_CATEGORY> = {
    resType: (typeof RESOURCE_CATEGORY)[T];
    resCount: number;
};
export type BalancesForSubscription = {
    subscriptionBalance: string;
    walletBalance: string;
};
export type SubBalanceEstimate = {
    netETHRequired: string;
    netXCTRequired: string;
    xctRequired: string;
    timePeriod: number;
};
export type NFTSubBalance = {
    subscriptionBalance: string;
    walletBalance: string;
};
export type NFTDripRate = {
    estimDripRate: string;
    actualDripRate: string;
};
export interface NFTBundleOption {
    name: string;
    description: string;
    appContractParam?: ContractApp;
    appModParam?: AppModifier;
}
export interface NFTBundleParam {
    name: string;
    description: string;
    defaultOption?: string;
    optionList: NFTBundleOption[];
}
